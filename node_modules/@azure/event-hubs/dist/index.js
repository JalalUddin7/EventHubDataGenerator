'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var rheaPromise = require('rhea-promise');
var amqpCommon = require('@azure/amqp-common');
var tslib = require('tslib');
var crypto = _interopDefault(require('crypto'));
var debugModule = _interopDefault(require('debug'));
var msRestNodeauth = require('@azure/ms-rest-nodeauth');
var os = require('os');

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (EventData) {
    /**
     * Converts the AMQP message to an EventData.
     * @param {AmqpMessage} msg The AMQP message that needs to be converted to EventData.
     */
    function fromAmqpMessage(msg) {
        const data = {
            body: msg.body,
            _raw_amqp_mesage: msg
        };
        if (msg.message_annotations) {
            data.annotations = msg.message_annotations;
            if (msg.message_annotations[amqpCommon.Constants.partitionKey] != undefined) {
                data.partitionKey = msg.message_annotations[amqpCommon.Constants.partitionKey];
            }
            if (msg.message_annotations[amqpCommon.Constants.sequenceNumber] != undefined) {
                data.sequenceNumber = msg.message_annotations[amqpCommon.Constants.sequenceNumber];
            }
            if (msg.message_annotations[amqpCommon.Constants.enqueuedTime] != undefined) {
                data.enqueuedTimeUtc = new Date(msg.message_annotations[amqpCommon.Constants.enqueuedTime]);
            }
            if (msg.message_annotations[amqpCommon.Constants.offset] != undefined) {
                data.offset = msg.message_annotations[amqpCommon.Constants.offset];
            }
        }
        // Since rhea expects message properties as top level properties we will look for them and unflatten them inside properties.
        for (const prop of rheaPromise.messageProperties) {
            if (msg[prop] != undefined) {
                if (!data.properties) {
                    data.properties = {};
                }
                data.properties[prop] = msg[prop];
            }
        }
        // Since rhea expects message headers as top level properties we will look for them and unflatten them inside header.
        for (const prop of rheaPromise.messageHeader) {
            if (msg[prop] != undefined) {
                if (!data.header) {
                    data.header = {};
                }
                data.header[prop] = msg[prop];
            }
        }
        if (msg.application_properties) {
            data.applicationProperties = msg.application_properties;
        }
        if (msg.delivery_annotations) {
            data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;
            data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;
            data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc);
            data.retrievalTime = new Date(msg.delivery_annotations.runtime_info_retrieval_time_utc);
        }
        return data;
    }
    EventData.fromAmqpMessage = fromAmqpMessage;
    /**
     * Converts an EventData object to an AMQP message.
     * @param {EventData} data The EventData object that needs to be converted to an AMQP message.
     */
    function toAmqpMessage(data) {
        const msg = {
            body: data.body
        };
        // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,
        // it is equivalent to a message-annotations section containing anempty map of annotations.
        msg.message_annotations = {};
        msg.delivery_annotations = {};
        if (data.annotations) {
            msg.message_annotations = data.annotations;
        }
        if (data.properties) {
            // Set amqp message properties as top level properties, since rhea sends them as top level properties.
            for (const prop in data.properties) {
                msg[prop] = data.properties[prop];
            }
        }
        if (data.applicationProperties) {
            msg.application_properties = data.applicationProperties;
        }
        if (data.partitionKey != undefined) {
            msg.message_annotations[amqpCommon.Constants.partitionKey] = data.partitionKey;
            // Event Hub service cannot route messages to a specific partition based on the partition key
            // if AMQP message header is an empty object. Hence we make sure that header is always present
            // with atleast one property. Setting durable to true, helps us achieve that.
            msg.durable = true;
        }
        if (data.sequenceNumber != undefined) {
            msg.message_annotations[amqpCommon.Constants.sequenceNumber] = data.sequenceNumber;
        }
        if (data.enqueuedTimeUtc != undefined) {
            msg.message_annotations[amqpCommon.Constants.enqueuedTime] = data.enqueuedTimeUtc.getTime();
        }
        if (data.offset != undefined) {
            msg.message_annotations[amqpCommon.Constants.offset] = data.offset;
        }
        if (data.lastEnqueuedOffset != undefined) {
            msg.delivery_annotations.last_enqueued_offset = data.lastEnqueuedOffset;
        }
        if (data.lastSequenceNumber != undefined) {
            msg.delivery_annotations.last_enqueued_sequence_number = data.lastSequenceNumber;
        }
        if (data.lastEnqueuedTime != undefined) {
            msg.delivery_annotations.last_enqueued_time_utc = data.lastEnqueuedTime.getTime();
        }
        if (data.retrievalTime != undefined) {
            msg.delivery_annotations.runtime_info_retrieval_time_utc = data.retrievalTime.getTime();
        }
        if (data.header) {
            // Set amqp message header as top level properties, since rhea expects them as top level properties.
            for (const prop in data.header) {
                msg[prop] = data.header[prop];
            }
        }
        return msg;
    }
    EventData.toAmqpMessage = toAmqpMessage;
})(exports.EventData || (exports.EventData = {}));

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.



var rng = function nodeRNG() {
  return crypto.randomBytes(16);
};

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 * log statements for error
 */
const error = debugModule("azure:event-hubs:error");
/**
 * @ignore
 * log statements for management
 */
const mgmt = debugModule("azure:event-hubs:management");
/**
 * @ignore
 * log statements for sender
 */
const sender = debugModule("azure:event-hubs:sender");
/**
 * @ignore
 * log statements for receiver
 */
const receiver = debugModule("azure:event-hubs:receiver");
/**
 * @ignore
 * log statements for receiverbatching
 */
const batching = debugModule("azure:event-hubs:receiverbatching");
/**
 * @ignore
 * log statements for receiverstreaming
 */
const streaming = debugModule("azure:event-hubs:receiverstreaming");
/**
 * @ignore
 * log statements for linkEntity
 */
const link = debugModule("azure:event-hubs:linkEntity");
/**
 * @ignore
 * log statements for connectionContext
 */
const context = debugModule("azure:event-hubs:connectionContext");
/**
 * @ignore
 * log statements for client
 */
const client = debugModule("azure:event-hubs:client");
/**
 * @ignore
 * log statements for iothub client
 */
const iotClient = debugModule("azure:event-hubs:iothubClient");

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the base class for entities like EventHub Sender, Receiver and Management link.
 * @ignore
 * @class LinkEntity
 */
class LinkEntity {
    /**
     * Creates a new LinkEntity instance.
     * @ignore
     * @constructor
     * @param {ConnectionContext} context The connection context.
     * @param {LinkEntityOptions} [options] Options that can be provided while creating the LinkEntity.
     */
    constructor(context, options) {
        /**
         * @property {boolean} isConnecting Indicates whether the link is in the process of connecting
         * (establishing) itself. Default value: `false`.
         */
        this.isConnecting = false;
        if (!options)
            options = {};
        this._context = context;
        this.address = options.address || "";
        this.audience = options.audience || "";
        this.name = options.name || v4_1();
        this.partitionId = options.partitionId;
    }
    /**
     * Negotiates cbs claim for the LinkEntity.
     * @ignore
     * @protected
     * @param {boolean} [setTokenRenewal] Set the token renewal timer. Default false.
     * @return {Promise<void>} Promise<void>
     */
    _negotiateClaim(setTokenRenewal) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Acquire the lock and establish a cbs session if it does not exist on the connection.
            // Although node.js is single threaded, we need a locking mechanism to ensure that a
            // race condition does not happen while creating a shared resource (in this case the
            // cbs session, since we want to have exactly 1 cbs session per connection).
            link("[%s] Acquiring cbs lock: '%s' for creating the cbs session while creating the %s: " + "'%s' with address: '%s'.", this._context.connectionId, this._context.cbsSession.cbsLock, this._type, this.name, this.address);
            yield amqpCommon.defaultLock.acquire(this._context.cbsSession.cbsLock, () => {
                return this._context.cbsSession.init();
            });
            const tokenObject = yield this._context.tokenProvider.getToken(this.audience);
            link("[%s] %s: calling negotiateClaim for audience '%s'.", this._context.connectionId, this._type, this.audience);
            // Acquire the lock to negotiate the CBS claim.
            link("[%s] Acquiring cbs lock: '%s' for cbs auth for %s: '%s' with address '%s'.", this._context.connectionId, this._context.negotiateClaimLock, this._type, this.name, this.address);
            yield amqpCommon.defaultLock.acquire(this._context.negotiateClaimLock, () => {
                return this._context.cbsSession.negotiateClaim(this.audience, tokenObject);
            });
            link("[%s] Negotiated claim for %s '%s' with with address: %s", this._context.connectionId, this._type, this.name, this.address);
            if (setTokenRenewal) {
                yield this._ensureTokenRenewal();
            }
        });
    }
    /**
     * Ensures that the token is renewed within the predefined renewal margin.
     * @ignore
     * @protected
     * @returns {void}
     */
    _ensureTokenRenewal() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const tokenValidTimeInSeconds = this._context.tokenProvider.tokenValidTimeInSeconds;
            const tokenRenewalMarginInSeconds = this._context.tokenProvider.tokenRenewalMarginInSeconds;
            const nextRenewalTimeout = (tokenValidTimeInSeconds - tokenRenewalMarginInSeconds) * 1000;
            this._tokenRenewalTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._negotiateClaim(true);
                }
                catch (err) {
                    error("[%s] %s '%s' with address %s, an error occurred while renewing the token: %O", this._context.connectionId, this._type, this.name, this.address, err);
                }
            }), nextRenewalTimeout);
            link("[%s] %s '%s' with address %s, has next token renewal in %d seconds @(%s).", this._context.connectionId, this._type, this.name, this.address, nextRenewalTimeout / 1000, new Date(Date.now() + nextRenewalTimeout).toString());
        });
    }
    /**
     * Closes the Sender|Receiver link and it's underlying session and also removes it from the
     * internal map.
     * @ignore
     * @param {Sender | Receiver} [link] The Sender or Receiver link that needs to be closed and
     * removed.
     */
    _closeLink(link$1) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._tokenRenewalTimer);
            if (link$1) {
                try {
                    // Closing the link and its underlying sessionÂ if the link is open. This should also
                    // remove them from the internal map.
                    yield link$1.close();
                    link("[%s] %s '%s' with address '%s' closed.", this._context.connectionId, this._type, this.name, this.address);
                }
                catch (err) {
                    error("[%s] An error occurred while closing the %s '%s' with address '%s': %O", this._context.connectionId, this._type, this.name, this.address, err);
                }
            }
        });
    }
    /**
     * Provides the current type of the LinkEntity.
     * @return {string} The entity type.
     */
    get _type() {
        let result = "LinkEntity";
        if (this.constructor && this.constructor.name) {
            result = this.constructor.name;
        }
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Represents options can be set during the creation of a event hub receiver.
 * Defines a position of an @link~EventData in the event hub partition.
 * @class EventPosition
 */
class EventPosition {
    constructor(options) {
        /**
         * @property {boolean} isInclusive Indicates if the current event at the specified offset is
         * included or not. It is only applicable if offset is set. Default value: false.
         */
        this.isInclusive = false;
        if (options) {
            this.offset = options.offset;
            this.enqueuedTime = options.enqueuedTime;
            this.sequenceNumber = options.sequenceNumber;
            this.isInclusive = options.isInclusive || false;
            this.customFilter = options.customFilter;
        }
    }
    /**
     * Gets the expression (filter clause) that needs to be set on the source.
     * @return {string} filterExpression
     */
    getExpression() {
        let result;
        // order of preference
        if (this.offset != undefined) {
            result = this.isInclusive
                ? `${amqpCommon.Constants.offsetAnnotation} >= '${this.offset}'`
                : `${amqpCommon.Constants.offsetAnnotation} > '${this.offset}'`;
        }
        else if (this.sequenceNumber != undefined) {
            result = this.isInclusive
                ? `${amqpCommon.Constants.sequenceNumberAnnotation} >= '${this.sequenceNumber}'`
                : `${amqpCommon.Constants.sequenceNumberAnnotation} > '${this.sequenceNumber}'`;
        }
        else if (this.enqueuedTime != undefined) {
            const time = this.enqueuedTime instanceof Date ? this.enqueuedTime.getTime() : this.enqueuedTime;
            result = `${amqpCommon.Constants.enqueuedTimeAnnotation} > '${time}'`;
        }
        else if (this.customFilter != undefined) {
            result = this.customFilter;
        }
        if (!result) {
            throw amqpCommon.translate({
                condition: amqpCommon.ErrorNameConditionMapper.ArgumentError,
                description: "No starting position was set in the EventPosition."
            });
        }
        return result;
    }
    /**
     * Creates a position at the given offset.
     * @param {string} offset The offset of the data relative to the Event Hub partition stream.
     * The offset is a marker or identifier for an event within the Event Hubs stream.
     * The identifier is unique within a partition of the Event Hubs stream.
     * @param {boolean} isInclusive If true, the specified event is included;
     * otherwise the next event is returned. Default: false.
     * @return {EventPosition} EventPosition
     */
    static fromOffset(offset, isInclusive) {
        if (!offset || typeof offset !== "string") {
            throw new Error("'offset' is a required parameter and must be a non-empty string.");
        }
        return new EventPosition({ offset: offset, isInclusive: isInclusive });
    }
    /**
     * Creates a position at the given sequence number.
     * @param {number} sequenceNumber The logical sequence number of the event within the partition stream of the Event Hub.
     * @param {boolean} isInclusive If true, the specified event is included;
     * otherwise the next event is returned. Default false.
     * @return {EventPosition} EventPosition
     */
    static fromSequenceNumber(sequenceNumber, isInclusive) {
        if (sequenceNumber == undefined || typeof sequenceNumber !== "number") {
            throw new Error("'sequenceNumber' is a required parameter and must be of type 'number'.");
        }
        return new EventPosition({ sequenceNumber: sequenceNumber, isInclusive: isInclusive });
    }
    /**
     * Creates a position at the given enqueued time.
     * @param {Date | number} enqueuedTime The enqueue time. This value represents the actual time of enqueuing the message.
     * @param {boolean} isInclusive If true, the specified event is included; otherwise the next event is returned.
     * @return {EventPosition} EventPosition
     */
    static fromEnqueuedTime(enqueuedTime) {
        if (enqueuedTime == undefined || (typeof enqueuedTime !== "number" && !(enqueuedTime instanceof Date))) {
            throw new Error("'enqueuedTime' is a required parameter and must be an instance of 'Date' or of type 'number'.");
        }
        return new EventPosition({ enqueuedTime: enqueuedTime });
    }
    /**
     * Creates a position based on the given custom filter.
     * @param {string} customFilter The cutom filter expression that needs to be applied on the receiver. This should be used
     * only when one of the other methods `fromOffset()`, `fromSequenceNumber()`, `fromEnqueuedTime()` is not applicable for
     * your scenario.
     */
    static withCustomFilter(customFilter) {
        if (!customFilter || typeof customFilter !== "string") {
            throw new Error("'customFilter' is a required parameter and must be a non-empty string.");
        }
        return new EventPosition({ customFilter: customFilter });
    }
    /**
     * Returns the position for the start of a stream. Provide this position in receiver creation to
     * start receiving from the first available event in the partition.
     * @return {EventPosition} EventPosition
     */
    static fromStart() {
        return EventPosition.fromOffset(EventPosition.startOfStream);
    }
    /**
     * Returns the position for the end of a stream. Provide this position in receiver creation to
     * start receiving from the next available event in the partition after the receiver is created.
     * @return {EventPosition} EventPosition
     */
    static fromEnd() {
        return EventPosition.fromOffset(EventPosition.endOfStream);
    }
}
/**
 * @property {string} startOfStream The offset from which events would be received: `"-1"`.
 * @static
 * @readonly
 */
EventPosition.startOfStream = "-1";
/**
 * @property {string} endOfStream The offset from which events would be received: `"@latest"`.
 * @static
 * @readonly
 */
EventPosition.endOfStream = "@latest";

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the EventHubReceiver that will receive event data from EventHub.
 * @class EventHubReceiver
 * @ignore
 */
class EventHubReceiver extends LinkEntity {
    /**
     * Instantiate a new receiver from the AMQP `Receiver`. Used by `EventHubClient`.
     * @ignore
     * @constructor
     * @param {EventHubClient} client                            The EventHub client.
     * @param {string} partitionId                               Partition ID from which to receive.
     * @param {ReceiveOptions} [options]                         Receiver options.
     */
    constructor(context, partitionId, options) {
        super(context, { partitionId: partitionId, name: options ? options.name : undefined });
        /**
         * @property {number} [prefetchCount] The number of messages that the receiver can fetch/receive
         * initially. Defaults to 1000.
         */
        this.prefetchCount = amqpCommon.Constants.defaultPrefetchCount;
        /**
         * @property {boolean} receiverRuntimeMetricEnabled Indicates whether receiver runtime metric
         * is enabled. Default: false.
         */
        this.receiverRuntimeMetricEnabled = false;
        /**
         * Keeps track of the number of messages that have been received.
         */
        this._receivedMessageCount = 0;
        /**
         * Keeps track of the last time the number of messages received were logged.
         */
        this._lastTimestamp = new Date().toISOString();
        if (!options)
            options = {};
        this.consumerGroup = options.consumerGroup ? options.consumerGroup : amqpCommon.Constants.defaultConsumerGroup;
        this.address = context.config.getReceiverAddress(partitionId, this.consumerGroup);
        this.audience = context.config.getReceiverAudience(partitionId, this.consumerGroup);
        this.prefetchCount = options.prefetchCount != undefined ? options.prefetchCount : amqpCommon.Constants.defaultPrefetchCount;
        this.epoch = options.epoch;
        this.identifier = options.identifier;
        this.options = options;
        this.receiverRuntimeMetricEnabled = options.enableReceiverRuntimeMetric || false;
        this.runtimeInfo = {
            partitionId: `${partitionId}`
        };
        this._checkpoint = {
            enqueuedTimeUtc: new Date(),
            offset: "0",
            sequenceNumber: -1
        };
        const logMessageInterval = 1000;
        this._onAmqpMessage = (context) => {
            this._receivedMessageCount++;
            // log every 1000 messages
            if (this._receivedMessageCount === logMessageInterval) {
                receiver("[%s] Receiver '%s' has received %i messages since %s.", this._context.connectionId, this.name, this._receivedMessageCount, this._lastTimestamp);
                // reset tracking values
                this._receivedMessageCount = 0;
                this._lastTimestamp = new Date().toISOString();
            }
            const evData = exports.EventData.fromAmqpMessage(context.message);
            evData.body = this._context.dataTransformer.decode(context.message.body);
            this._checkpoint = {
                enqueuedTimeUtc: evData.enqueuedTimeUtc,
                offset: evData.offset,
                sequenceNumber: evData.sequenceNumber
            };
            if (this.receiverRuntimeMetricEnabled && evData) {
                this.runtimeInfo.lastSequenceNumber = evData.lastSequenceNumber;
                this.runtimeInfo.lastEnqueuedTimeUtc = evData.lastEnqueuedTime;
                this.runtimeInfo.lastEnqueuedOffset = evData.lastEnqueuedOffset;
                this.runtimeInfo.retrievalTime = evData.retrievalTime;
                receiver("[%s] RuntimeInfo of Receiver '%s' is %O", this._context.connectionId, this.name, this.runtimeInfo);
            }
            try {
                this._onMessage(evData);
            }
            catch (err) {
                error("[%s] User-code error: %O", this._context.connectionId, err);
            }
        };
        this._onAmqpError = (context) => {
            const receiver = this._receiver || context.receiver;
            const receiverError = context.receiver && context.receiver.error;
            if (receiverError) {
                const ehError = amqpCommon.translate(receiverError);
                error("[%s] An error occurred for Receiver '%s': %O.", this._context.connectionId, this.name, ehError);
                if (!ehError.retryable) {
                    if (receiver && !receiver.isItselfClosed()) {
                        error("[%s] Since the user did not close the receiver and the error is not " +
                            "retryable, we let the user know about it by calling the user's error handler.", this._context.connectionId);
                        try {
                            this._onError(ehError);
                        }
                        catch (err) {
                            error("[%s] User-code error in error handler: %O", this._context.connectionId, err);
                        }
                    }
                    else {
                        error("[%s] The received error is not retryable. However, the receiver was " +
                            "closed by the user. Hence not notifying the user's error handler.", this._context.connectionId);
                    }
                }
                else {
                    error("[%s] Since received error is retryable, we will NOT notify the user's " + "error handler.", this._context.connectionId);
                }
            }
        };
        this._onSessionError = (context) => {
            const receiver = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const ehError = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session for Receiver '%s': %O.", this._context.connectionId, this.name, ehError);
                if (receiver && !receiver.isSessionItselfClosed() && !ehError.retryable) {
                    error("[%s] Since the user did not close the receiver and the session error is not " +
                        "retryable, we let the user know about it by calling the user's error handler.", this._context.connectionId);
                    try {
                        this._onError(ehError);
                    }
                    catch (err) {
                        error("[%s] User-code error in error handler: %O", this._context.connectionId, err);
                    }
                }
            }
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const receiverError = context.receiver && context.receiver.error;
            const receiver = this._receiver || context.receiver;
            if (receiverError) {
                error("[%s] 'receiver_close' event occurred for receiver '%s' with address '%s'. " + "The associated error is: %O", this._context.connectionId, this.name, this.address, receiverError);
            }
            if (receiver && !receiver.isItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initiate this. The receiver is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                    yield this.detached(receiverError);
                }
                else {
                    error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the receiver is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'receiver_close' event occurred on the receiver '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const receiver = this._receiver || context.receiver;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for receiver '%s' with address '%s'. " + "The associated error is: %O", this._context.connectionId, this.name, this.address, sessionError);
            }
            if (receiver && !receiver.isSessionItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                    yield this.detached(sessionError);
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of receiver '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the receiver is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the session of receiver '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        });
    }
    /**
     * Will reconnect the receiver link if necessary.
     * @ignore
     * @param {AmqpError | Error} [receiverError] The receiver error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    detached(receiverError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const wasCloseInitiated = this._receiver && this._receiver.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(this._receiver);
                // We should attempt to reopen only when the receiver(sdk) did not initiate the close
                let shouldReopen = false;
                if (receiverError && !wasCloseInitiated) {
                    const translatedError = amqpCommon.translate(receiverError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is retryable. This is a candidate for re-establishing " +
                            "the receiver link.", this._context.connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Receiver '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the receiver link.", this._context.connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    shouldReopen = true;
                    error("[%s] close() method of Receiver '%s' with address '%s' was not called. " +
                        "There was no accompanying error as well. This is a candidate for re-establishing " +
                        "the receiver link.", this._context.connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        receiverError: receiverError,
                        _receiver: this._receiver
                    };
                    error("[%s] Something went wrong. State of Receiver '%s' with address '%s' is: %O", this._context.connectionId, this.name, this.address, state);
                }
                if (shouldReopen) {
                    const rcvrOptions = {
                        onMessage: this._onAmqpMessage,
                        onError: this._onAmqpError,
                        onClose: this._onAmqpClose,
                        onSessionError: this._onSessionError,
                        onSessionClose: this._onSessionClose,
                        newName: true // provide a new name to the link while re-connecting it. This ensures that
                        // the service does not send an error stating that the link is still open.
                    };
                    // reconnect the receiver link with sequenceNumber of the last received message as the offset
                    // if messages were received by the receiver before it got disconnected.
                    if (this._checkpoint.sequenceNumber > -1) {
                        rcvrOptions.eventPosition = EventPosition.fromSequenceNumber(this._checkpoint.sequenceNumber);
                    }
                    const options = this._createReceiverOptions(rcvrOptions);
                    // shall retry forever at an interval of 15 seconds if the error is a retryable error
                    // else bail out when the error is not retryable or the oepration succeeds.
                    const config = {
                        operation: () => this._init(options),
                        connectionId: this._context.connectionId,
                        operationType: amqpCommon.RetryOperationType.receiverLink,
                        times: amqpCommon.Constants.defaultConnectionRetryAttempts,
                        connectionHost: this._context.config.host,
                        delayInSeconds: 15
                    };
                    yield amqpCommon.retry(config);
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing detached() of Receiver '%s' with address " + "'%s': %O", this._context.connectionId, this.name, this.address, err);
                if (typeof this._onError === "function") {
                    error("[%s] Unable to automatically reconnect Receiver '%s' with address '%s'. " +
                        "Invoking user-defined error handler.", this._context.connectionId, this.name, this.address);
                    try {
                        this._onError(err);
                    }
                    catch (err) {
                        error("[%s] User-code error in error handler called after disconnect: %O", this._context.connectionId, err);
                    }
                }
            }
        });
    }
    /**
     * Closes the underlying AMQP receiver.
     * @ignore
     * @returns {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._receiver) {
                const receiverLink = this._receiver;
                this._deleteFromCache();
                yield this._closeLink(receiverLink);
            }
        });
    }
    /**
     * Determines whether the AMQP receiver link is open. If open then returns true else returns false.
     * @ignore
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._receiver && this._receiver.isOpen();
        error("[%s] Receiver '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    _deleteFromCache() {
        this._receiver = undefined;
        delete this._context.receivers[this.name];
        error("[%s] Deleted the receiver '%s' from the client cache.", this._context.connectionId, this.name);
    }
    /**
     * Creates a new AMQP receiver under a new AMQP session.
     * @ignore
     * @returns {Promise<void>}
     */
    _init(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The receiver '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", this._context.connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    if (!options) {
                        options = this._createReceiverOptions({
                            onMessage: this._onAmqpMessage,
                            onError: this._onAmqpError,
                            onClose: this._onAmqpClose,
                            onSessionError: this._onSessionError,
                            onSessionClose: this._onSessionClose
                        });
                    }
                    error("[%s] Trying to create receiver '%s' with options %O", this._context.connectionId, this.name, options);
                    this._receiver = yield this._context.connection.createReceiver(options);
                    this.isConnecting = false;
                    error("[%s] Receiver '%s' with address '%s' has established itself.", this._context.connectionId, this.name, this.address);
                    receiver("Promise to create the receiver resolved. Created receiver with name: ", this.name);
                    receiver("[%s] Receiver '%s' created with receiver options: %O", this._context.connectionId, this.name, options);
                    // It is possible for someone to close the receiver and then start it again.
                    // Thus make sure that the receiver is present in the client cache.
                    const receiverName = options.name || this.name;
                    if (!this._context.receivers[receiverName]) {
                        // Check if the receiver already exists and remove the existing reference from the cache.
                        const existingReceiverName = this.name;
                        if (this._context.receivers[existingReceiverName]) {
                            delete this._context.receivers[existingReceiverName];
                            this.name = receiverName;
                        }
                        this._context.receivers[receiverName] = this;
                    }
                    yield this._ensureTokenRenewal();
                }
                else {
                    error("[%s] The receiver '%s' with address '%s' is open -> %s and is connecting " +
                        "-> %s. Hence not reconnecting.", this._context.connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                err = amqpCommon.translate(err);
                error("[%s] An error occured while creating the receiver '%s': %O", this._context.connectionId, this.name, err);
                throw err;
            }
        });
    }
    /**
     * Creates the options that need to be specified while creating an AMQP receiver link.
     * @ignore
     */
    _createReceiverOptions(options) {
        //if (options.newName) this.name = `${uuid()}`;
        const rcvrOptions = {
            name: options.newName ? v4_1() : this.name,
            autoaccept: true,
            source: {
                address: this.address
            },
            credit_window: this.prefetchCount,
            onMessage: options.onMessage || this._onAmqpMessage,
            onError: options.onError || this._onAmqpError,
            onClose: options.onClose || this._onAmqpClose,
            onSessionError: options.onSessionError || this._onSessionError,
            onSessionClose: options.onSessionClose || this._onSessionClose
        };
        if (this.epoch !== undefined && this.epoch !== null) {
            if (!rcvrOptions.properties)
                rcvrOptions.properties = {};
            rcvrOptions.properties[amqpCommon.Constants.attachEpoch] = rheaPromise.types.wrap_long(this.epoch);
        }
        if (this.identifier) {
            if (!rcvrOptions.properties)
                rcvrOptions.properties = {};
            rcvrOptions.properties[amqpCommon.Constants.receiverIdentifierName] = this.identifier;
        }
        if (this.receiverRuntimeMetricEnabled) {
            rcvrOptions.desired_capabilities = amqpCommon.Constants.enableReceiverRuntimeMetricName;
        }
        const eventPosition = options.eventPosition || this.options.eventPosition;
        if (eventPosition) {
            // Set filter on the receiver if event position is specified.
            const filterClause = eventPosition.getExpression();
            if (filterClause) {
                rcvrOptions.source.filter = {
                    "apache.org:selector-filter:string": rheaPromise.types.wrap_described(filterClause, 0x468c00000004)
                };
            }
        }
        return rcvrOptions;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the receive handler object that is returned from the receive() method with handlers is
 * called. The ReceiveHandler is used to stop receiving more messages.
 * @class ReceiveHandler
 */
class ReceiveHandler {
    /**
     * Creates an instance of the ReceiveHandler.
     * @constructor
     * @param {EventHubReceiver} receiver The underlying EventHubReceiver.
     */
    constructor(receiver) {
        this._receiver = receiver;
        this.name = receiver ? receiver.name : "ReceiveHandler";
    }
    /**
     * @property {string | number} [partitionId] The partitionId from which the handler is receiving
     * events from.
     * @readonly
     */
    get partitionId() {
        return this._receiver ? this._receiver.partitionId : undefined;
    }
    /**
     * @property {string} [consumerGroup] The consumer group from which the handler is receiving
     * events from.
     * @readonly
     */
    get consumerGroup() {
        return this._receiver ? this._receiver.consumerGroup : undefined;
    }
    /**
     * @property {string} [address] The address of the underlying receiver.
     * @readonly
     */
    get address() {
        return this._receiver ? this._receiver.address : undefined;
    }
    /**
     * @property {number} [epoch] The epoch value of the underlying receiver, if present.
     * @readonly
     */
    get epoch() {
        return this._receiver ? this._receiver.epoch : undefined;
    }
    /**
     * @property {string} [identifier] The identifier of the underlying receiver, if present.
     * @readonly
     */
    get identifier() {
        return this._receiver ? this._receiver.identifier : undefined;
    }
    /**
     * @property {ReceiverRuntimeInfo} [runtimeInfo] The receiver runtime info. This property will only
     * be enabled when `enableReceiverRuntimeMetric` option is set to true in the
     * `client.receive()` method.
     * @readonly
     */
    get runtimeInfo() {
        return this._receiver ? this._receiver.runtimeInfo : undefined;
    }
    /**
     * @property {boolean} isReceiverOpen Indicates whether the receiver is connected/open.
     * `true` - is open; `false` otherwise.
     * @readonly
     */
    get isReceiverOpen() {
        return this._receiver ? this._receiver.isOpen() : false;
    }
    /**
     * Stops the underlying EventHubReceiver from receiving more messages.
     * @return {Promise<void>} Promise<void>
     */
    stop() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._receiver) {
                try {
                    yield this._receiver.close();
                }
                catch (err) {
                    error("An error occurred while stopping the receiver '%s' with address '%s': %O", this._receiver.name, this._receiver.address, err);
                }
            }
        });
    }
}
/**
 * Describes the streaming receiver where the user can receive the message
 * by providing handler functions.
 * @ignore
 * @class StreamingReceiver
 * @extends EventHubReceiver
 */
class StreamingReceiver extends EventHubReceiver {
    /**
     * Instantiate a new receiver from the AMQP `Receiver`. Used by `EventHubClient`.
     * @ignore
     * @constructor
     * @param {EventHubClient} client          The EventHub client.
     * @param {string} partitionId             Partition ID from which to receive.
     * @param {ReceiveOptions} [options]       Options for how you'd like to connect.
     */
    constructor(context, partitionId, options) {
        super(context, partitionId, options);
        this.receiveHandler = new ReceiveHandler(this);
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session.
     * @ignore
     * @param {OnMessage} onMessage The message handler to receive event data objects.
     * @param {OnError} onError The error handler to receive an error that occurs while receivin messages.
     */
    receive(onMessage, onError) {
        if (!onMessage || typeof onMessage !== "function") {
            throw new Error("'onMessage' is a required parameter and must be of type 'function'.");
        }
        if (!onError || typeof onError !== "function") {
            throw new Error("'onError' is a required parameter and must be of type 'function'.");
        }
        this._onMessage = onMessage;
        this._onError = onError;
        if (!this.isOpen()) {
            this._init().catch(err => {
                try {
                    this._onError(err);
                }
                catch (err) {
                    error("User-code error in error handler: %O", err);
                }
            });
        }
        else {
            // It is possible that the receiver link has been established due to a previous receive() call. If that
            // is the case then add message and error event handlers to the receiver. When the receiver will be closed
            // these handlers will be automatically removed.
            streaming("[%s] Receiver link is already present for '%s' due to previous receive() calls. " +
                "Hence reusing it and attaching message and error handlers.", this._context.connectionId, this.name);
            this._receiver.on(rheaPromise.ReceiverEvents.message, this._onAmqpMessage);
            this._receiver.on(rheaPromise.ReceiverEvents.receiverError, this._onAmqpError);
            this._receiver.setCreditWindow(amqpCommon.Constants.defaultPrefetchCount);
            this._receiver.addCredit(amqpCommon.Constants.defaultPrefetchCount);
            streaming("[%s] Receiver '%s', set the prefetch count to 1000 and " + "providing a credit of the same amount.", this._context.connectionId, this.name);
        }
        return this.receiveHandler;
    }
    /**
     * Creates a streaming receiver.
     * @static
     * @ignore
     * @param {ConnectionContext} context    The connection context.
     * @param {string | number} partitionId  The partitionId to receive events from.
     * @param {ReceiveOptions} [options]     Receive options.
     */
    static create(context, partitionId, options) {
        const sReceiver = new StreamingReceiver(context, partitionId, options);
        context.receivers[sReceiver.name] = sReceiver;
        return sReceiver;
    }
}

var name = "@azure/event-hubs";
var version = "2.1.4";

// Copyright (c) Microsoft Corporation. All rights reserved.
const packageJsonInfo = {
    name: name,
    version: version
};

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class ManagementClient
 * @ignore
 * Descibes the EventHubs Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
class ManagementClient extends LinkEntity {
    /**
     * Instantiates the management client.
     * @constructor
     * @ignore
     * @param {BaseConnectionContext} context The connection context.
     * @param {string} [address] The address for the management endpoint. For IotHub it will be
     * `/messages/events/$management`.
     */
    constructor(context, options) {
        super(context, {
            address: options && options.address ? options.address : amqpCommon.Constants.management,
            audience: options && options.audience ? options.audience : context.config.getManagementAudience()
        });
        this.managementLock = `${amqpCommon.Constants.managementRequestKey}-${v4_1()}`;
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = v4_1();
        this._context = context;
        this.entityPath = context.config.entityPath;
    }
    /**
     * Provides the eventhub runtime information.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<EventHubRuntimeInformation>}
     */
    getHubRuntimeInformation() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const info = yield this._makeManagementRequest(amqpCommon.Constants.eventHub);
            const runtimeInfo = {
                path: info.name,
                createdAt: new Date(info.created_at),
                partitionCount: info.partition_count,
                partitionIds: info.partition_ids,
                type: info.type
            };
            mgmt("[%s] The hub runtime info is: %O", this._context.connectionId, runtimeInfo);
            return runtimeInfo;
        });
    }
    /**
     * Provides an array of partitionIds.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<Array<string>>}
     */
    getPartitionIds() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const runtimeInfo = yield this.getHubRuntimeInformation();
            return runtimeInfo.partitionIds;
        });
    }
    /**
     * Provides information about the specified partition.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     */
    getPartitionInformation(partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (typeof partitionId !== "string" && typeof partitionId !== "number") {
                throw new Error("'partitionId' is a required parameter and must be of " + "type: 'string' | 'number'.");
            }
            const info = yield this._makeManagementRequest(amqpCommon.Constants.partition, partitionId);
            const partitionInfo = {
                beginningSequenceNumber: info.begin_sequence_number,
                hubPath: info.name,
                lastEnqueuedOffset: info.last_enqueued_offset,
                lastEnqueuedTimeUtc: new Date(info.last_enqueued_time_utc),
                lastSequenceNumber: info.last_enqueued_sequence_number,
                partitionId: info.partition,
                type: info.type
            };
            mgmt("[%s] The partition info is: %O.", this._context.connectionId, partitionInfo);
            return partitionInfo;
        });
    }
    /**
     * Closes the AMQP management session to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @ignore
     * @return {Promise<void>}
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._isMgmtRequestResponseLinkOpen()) {
                    const mgmtLink = this._mgmtReqResLink;
                    this._mgmtReqResLink = undefined;
                    clearTimeout(this._tokenRenewalTimer);
                    yield mgmtLink.close();
                    mgmt("Successfully closed the management session.");
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the management session: ${err}`;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    _init() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._isMgmtRequestResponseLinkOpen()) {
                    yield this._negotiateClaim();
                    const rxopt = {
                        source: { address: this.address },
                        name: this.replyTo,
                        target: { address: this.replyTo },
                        onSessionError: (context) => {
                            const id = context.connection.options.id;
                            const ehError = amqpCommon.translate(context.session.error);
                            error("[%s] An error occurred on the session for request/response links for " + "$management: %O", id, ehError);
                        }
                    };
                    const sropt = { target: { address: this.address } };
                    mgmt("[%s] Creating sender/receiver links on a session for $management endpoint with " +
                        "srOpts: %o, receiverOpts: %O.", this._context.connectionId, sropt, rxopt);
                    this._mgmtReqResLink = yield amqpCommon.RequestResponseLink.create(this._context.connection, sropt, rxopt);
                    this._mgmtReqResLink.sender.on(rheaPromise.SenderEvents.senderError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = amqpCommon.translate(context.sender.error);
                        error("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                    });
                    this._mgmtReqResLink.receiver.on(rheaPromise.ReceiverEvents.receiverError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = amqpCommon.translate(context.receiver.error);
                        error("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                    });
                    mgmt("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = amqpCommon.translate(err);
                error("[%s] An error occured while establishing the $management links: %O", this._context.connectionId, err);
                throw err;
            }
        });
    }
    /**
     * @private
     * Helper method to make the management request
     * @param {Connection} connection - The established amqp connection
     * @param {string} type - The type of entity requested for. Valid values are "eventhub", "partition"
     * @param {string | number} [partitionId] - The partitionId. Required only when type is "partition".
     */
    _makeManagementRequest(type, partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (partitionId != undefined && (typeof partitionId !== "string" && typeof partitionId !== "number")) {
                throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
            }
            try {
                const request = {
                    body: Buffer.from(JSON.stringify([])),
                    message_id: v4_1(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: amqpCommon.Constants.readOperation,
                        name: this.entityPath,
                        type: `${amqpCommon.Constants.vendorString}:${type}`
                    }
                };
                if (partitionId != undefined && type === amqpCommon.Constants.partition) {
                    request.application_properties.partition = `${partitionId}`;
                }
                mgmt("[%s] Acquiring lock to get the management req res link.", this._context.connectionId);
                yield amqpCommon.defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                return (yield this._mgmtReqResLink.sendRequest(request)).body;
            }
            catch (err) {
                err = amqpCommon.translate(err);
                error("An error occurred while making the request to $management endpoint: %O", err);
                throw err;
            }
        });
    }
    _isMgmtRequestResponseLinkOpen() {
        return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property {string} userAgent The user agent string for the EventHubs client.
     * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
     */
    const userAgent = `azsdk-js-azureeventhubs/${packageJsonInfo.version} (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;
    function getUserAgent(options) {
        const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;
        if (finalUserAgent.length > amqpCommon.Constants.maxUserAgentLength) {
            throw new Error(`The user-agent string cannot be more than ${amqpCommon.Constants.maxUserAgentLength} characters in length.` +
                `The given user-agent string is: ${finalUserAgent} with length: ${finalUserAgent.length}`);
        }
        return finalUserAgent;
    }
    ConnectionContext.getUserAgent = getUserAgent;
    function create(config, options) {
        if (!options)
            options = {};
        const parameters = {
            config: config,
            tokenProvider: options.tokenProvider,
            dataTransformer: options.dataTransformer,
            isEntityPathRequired: true,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: getUserAgent(options),
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add EventHub specific ConnectionContext properties.
        const connectionContext = amqpCommon.ConnectionContextBase.create(parameters);
        connectionContext.wasConnectionCloseCalled = false;
        connectionContext.senders = {};
        connectionContext.receivers = {};
        const mOptions = {
            address: options.managementSessionAddress,
            audience: options.managementSessionAudience
        };
        connectionContext.managementSession = new ManagementClient(connectionContext, mOptions);
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context$1) => {
            connectionContext.wasConnectionCloseCalled = false;
            context("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
            }
            const contextError = context.error;
            if (contextError) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, contextError);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numSenders: Object.keys(connectionContext.senders).length,
                numReceivers: Object.keys(connectionContext.receivers).length
            };
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            yield connectionContext.cbsSession.close();
            // Close the management session to ensure all the event handlers are released.
            yield connectionContext.managementSession.close();
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was atleast one sender/receiver link on the connection before it went down.
            error("[%s] state: %O", connectionContext.connection.id, state);
            if (!state.wasConnectionCloseCalled && (state.numSenders || state.numReceivers)) {
                error("[%s] connection.close() was not called from the sdk and there were some " +
                    "sender or receiver links or both. We should reconnect.", connectionContext.connection.id);
                yield amqpCommon.delay(amqpCommon.Constants.connectionReconnectDelay);
                // reconnect senders if any
                for (const senderName of Object.keys(connectionContext.senders)) {
                    const sender = connectionContext.senders[senderName];
                    if (!sender.isConnecting) {
                        error("[%s] calling detached on sender '%s' with address '%s'.", connectionContext.connection.id, sender.name, sender.address);
                        sender.detached(connectionError || contextError).catch(err => {
                            error("[%s] An error occurred while reconnecting the sender '%s' with adress '%s' %O.", connectionContext.connection.id, sender.name, sender.address, err);
                        });
                    }
                    else {
                        error("[%s] sender '%s' with address '%s' is already reconnecting. Hence not " +
                            "calling detached on the sender.", connectionContext.connection.id, sender.name, sender.address);
                    }
                }
                // reconnect receivers if any
                for (const receiverName of Object.keys(connectionContext.receivers)) {
                    const receiver = connectionContext.receivers[receiverName];
                    if (!receiver.isConnecting) {
                        error("[%s] calling detached on receiver '%s' with address '%s'.", connectionContext.connection.id, receiver.name, receiver.address);
                        receiver.detached(connectionError || contextError).catch(err => {
                            error("[%s] An error occurred while reconnecting the receiver '%s' with adress '%s' %O.", connectionContext.connection.id, receiver.name, receiver.address, err);
                        });
                    }
                    else {
                        error("[%s] receiver '%s' with address '%s' is already reconnecting. Hence not " +
                            "calling detached on the receiver.", connectionContext.connection.id, receiver.name, receiver.address);
                    }
                }
            }
        });
        const protocolError = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        const error$1 = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        // Add listeners on the connection object.
        connectionContext.connection.on(rheaPromise.ConnectionEvents.connectionOpen, onConnectionOpen);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.disconnected, disconnected);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.protocolError, protocolError);
        connectionContext.connection.on(rheaPromise.ConnectionEvents.error, error$1);
        context("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext || (ConnectionContext = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the EventHubSender that will send event data to EventHub.
 * @class EventHubSender
 * @ignore
 */
class EventHubSender extends LinkEntity {
    /**
     * Creates a new EventHubSender instance.
     * @ignore
     * @constructor
     * @param {ConnectionContext} context The connection context.
     * @param {string|number} [partitionId] The EventHub partition id to which the sender
     * wants to send the event data.
     */
    constructor(context, partitionId, name) {
        super(context, { name: name, partitionId: partitionId });
        /**
         * @property {string} senderLock The unqiue lock name per connection that is used to acquire the
         * lock for establishing a sender link by an entity on that connection.
         * @readonly
         */
        this.senderLock = `sender-${v4_1()}`;
        this.address = context.config.getSenderAddress(partitionId);
        this.audience = context.config.getSenderAudience(partitionId);
        this._onAmqpError = (context) => {
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                const err = amqpCommon.translate(senderError);
                error("[%s] An error occurred for sender '%s': %O.", this._context.connectionId, this.name, err);
            }
        };
        this._onSessionError = (context) => {
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                const err = amqpCommon.translate(sessionError);
                error("[%s] An error occurred on the session of sender '%s': %O.", this._context.connectionId, this.name, err);
            }
        };
        this._onAmqpClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            const senderError = context.sender && context.sender.error;
            if (senderError) {
                error("[%s] 'sender_close' event occurred for sender '%s' with address '%s'. " + "The associated error is: %O", this._context.connectionId, this.name, this.address, senderError);
            }
            if (sender && !sender.isItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initiate this. The sender is not reconnecting. Hence, calling " +
                        "detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                    yield this.detached(senderError);
                }
                else {
                    error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                        "and the sdk did not initate this. Moreover the sender is already re-connecting. " +
                        "Hence not calling detached from the _onAmqpClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'sender_close' event occurred on the sender '%s' with address '%s' " +
                    "because the sdk initiated it. Hence not calling detached from the _onAmqpClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        });
        this._onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = this._sender || context.sender;
            const sessionError = context.session && context.session.error;
            if (sessionError) {
                error("[%s] 'session_close' event occurred for sender '%s' with address '%s'. " + "The associated error is: %O", this._context.connectionId, this.name, this.address, sessionError);
            }
            if (sender && !sender.isSessionItselfClosed()) {
                if (!this.isConnecting) {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Hence calling detached from the " +
                        "_onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                    yield this.detached(sessionError);
                }
                else {
                    error("[%s] 'session_close' event occurred on the session of sender '%s' with " +
                        "address '%s' and the sdk did not initiate this. Moreover the sender is already " +
                        "re-connecting. Hence not calling detached from the _onSessionClose() handler.", this._context.connectionId, this.name, this.address);
                }
            }
            else {
                error("[%s] 'session_close' event occurred on the session of sender '%s' with address " +
                    "'%s' because the sdk initiated it. Hence not calling detached from the _onSessionClose" +
                    "() handler.", this._context.connectionId, this.name, this.address);
            }
        });
    }
    /**
     * Will reconnect the sender link if necessary.
     * @ignore
     * @param {AmqpError | Error} [senderError] The sender error if any.
     * @returns {Promise<void>} Promise<void>.
     */
    detached(senderError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const wasCloseInitiated = this._sender && this._sender.isItselfClosed();
                // Clears the token renewal timer. Closes the link and its session if they are open.
                // Removes the link and its session if they are present in rhea's cache.
                yield this._closeLink(this._sender);
                // We should attempt to reopen only when the sender(sdk) did not initiate the close
                let shouldReopen = false;
                if (senderError && !wasCloseInitiated) {
                    const translatedError = amqpCommon.translate(senderError);
                    if (translatedError.retryable) {
                        shouldReopen = true;
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error an it is retryable. This is a candidate for re-establishing " +
                            "the sender link.", this._context.connectionId, this.name, this.address);
                    }
                    else {
                        error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                            "was an accompanying error and it is NOT retryable. Hence NOT re-establishing " +
                            "the sender link.", this._context.connectionId, this.name, this.address);
                    }
                }
                else if (!wasCloseInitiated) {
                    shouldReopen = true;
                    error("[%s] close() method of Sender '%s' with address '%s' was not called. There " +
                        "was no accompanying error as well. This is a candidate for re-establishing " +
                        "the sender link.", this._context.connectionId, this.name, this.address);
                }
                else {
                    const state = {
                        wasCloseInitiated: wasCloseInitiated,
                        senderError: senderError,
                        _sender: this._sender
                    };
                    error("[%s] Something went wrong. State of sender '%s' with address '%s' is: %O", this._context.connectionId, this.name, this.address, state);
                }
                if (shouldReopen) {
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        const options = this._createSenderOptions({
                            newName: true
                        });
                        // shall retry forever at an interval of 15 seconds if the error is a retryable error
                        // else bail out when the error is not retryable or the oepration succeeds.
                        const config = {
                            operation: () => this._init(options),
                            connectionId: this._context.connectionId,
                            operationType: amqpCommon.RetryOperationType.senderLink,
                            times: amqpCommon.Constants.defaultConnectionRetryAttempts,
                            connectionHost: this._context.config.host,
                            delayInSeconds: 15
                        };
                        return amqpCommon.retry(config);
                    });
                }
            }
            catch (err) {
                error("[%s] An error occurred while processing detached() of Sender '%s' with address " + "'%s': %O", this._context.connectionId, this.name, this.address, err);
            }
        });
    }
    /**
     * Deletes the sender fromt the context. Clears the token renewal timer. Closes the sender link.
     * @ignore
     * @return {Promise<void>} Promise<void>
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this._sender) {
                const senderLink = this._sender;
                this._deleteFromCache();
                yield this._closeLink(senderLink);
            }
        });
    }
    /**
     * Determines whether the AMQP sender link is open. If open then returns true else returns false.
     * @ignore
     * @return {boolean} boolean
     */
    isOpen() {
        const result = this._sender && this._sender.isOpen();
        error("[%s] Sender '%s' with address '%s' is open? -> %s", this._context.connectionId, this.name, this.address, result);
        return result;
    }
    /**
     * Sends the given message, with the given options on this link
     * @ignore
     * @param {any} data Message to send.  Will be sent as UTF8-encoded JSON string.
     * @returns {Promise<Delivery>} Promise<Delivery>
     */
    send(data) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!data || (data && typeof data !== "object")) {
                    throw new Error("data is required and it must be of type object.");
                }
                if (data.partitionKey && typeof data.partitionKey !== "string") {
                    throw new Error("'partitionKey' must be of type 'string'.");
                }
                if (!this.isOpen()) {
                    sender("Acquiring lock %s for initializing the session, sender and " + "possibly the connection.", this.senderLock);
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        return this._init();
                    });
                }
                const message = exports.EventData.toAmqpMessage(data);
                message.body = this._context.dataTransformer.encode(data.body);
                return yield this._trySend(message, message.message_id);
            }
            catch (err) {
                error("An error occurred while sending the message %O", err);
                throw err;
            }
        });
    }
    /**
     * Send a batch of EventData to the EventHub. The "message_annotations",
     * "application_properties" and "properties" of the first message will be set as that
     * of the envelope (batch message).
     * @ignore
     * @param {Array<EventData>} datas  An array of EventData objects to be sent in a Batch message.
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    sendBatch(datas) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!datas || (datas && !Array.isArray(datas))) {
                    throw new Error("data is required and it must be an Array.");
                }
                if (!this.isOpen()) {
                    sender("Acquiring lock %s for initializing the session, sender and " + "possibly the connection.", this.senderLock);
                    yield amqpCommon.defaultLock.acquire(this.senderLock, () => {
                        return this._init();
                    });
                }
                sender("[%s] Sender '%s', trying to send EventData[].", this._context.connectionId, this.name);
                const messages = [];
                // Convert EventData to AmqpMessage.
                for (let i = 0; i < datas.length; i++) {
                    const message = exports.EventData.toAmqpMessage(datas[i]);
                    message.body = this._context.dataTransformer.encode(datas[i].body);
                    messages[i] = message;
                }
                // Encode every amqp message and then convert every encoded message to amqp data section
                const batchMessage = {
                    body: rheaPromise.message.data_sections(messages.map(rheaPromise.message.encode))
                };
                // Set message_annotations, application_properties and properties of the first message as
                // that of the envelope (batch message).
                if (messages[0].message_annotations) {
                    batchMessage.message_annotations = messages[0].message_annotations;
                }
                if (messages[0].application_properties) {
                    batchMessage.application_properties = messages[0].application_properties;
                }
                for (const prop of rheaPromise.messageProperties) {
                    if (messages[0][prop]) {
                        batchMessage[prop] = messages[0][prop];
                    }
                }
                // Finally encode the envelope (batch message).
                const encodedBatchMessage = rheaPromise.message.encode(batchMessage);
                sender("[%s] Sender '%s', sending encoded batch message.", this._context.connectionId, this.name, encodedBatchMessage);
                return yield this._trySend(encodedBatchMessage, batchMessage.message_id, 0x80013700);
            }
            catch (err) {
                error("An error occurred while sending the batch message %O", err);
                throw err;
            }
        });
    }
    _deleteFromCache() {
        this._sender = undefined;
        delete this._context.senders[this.address];
        error("[%s] Deleted the sender '%s' with address '%s' from the client cache.", this._context.connectionId, this.name, this.address);
    }
    _createSenderOptions(options) {
        if (options.newName)
            this.name = `${v4_1()}`;
        const srOptions = {
            name: this.name,
            target: {
                address: this.address
            },
            onError: this._onAmqpError,
            onClose: this._onAmqpClose,
            onSessionError: this._onSessionError,
            onSessionClose: this._onSessionClose
        };
        sender("Creating sender with options: %O", srOptions);
        return srOptions;
    }
    /**
     * Tries to send the message to EventHub if there is enough credit to send them
     * and the circular buffer has available space to settle the message after sending them.
     *
     * We have implemented a synchronous send over here in the sense that we shall be waiting
     * for the message to be accepted or rejected and accordingly resolve or reject the promise.
     * @ignore
     * @param message The message to be sent to EventHub.
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    _trySend(message, tag, format) {
        const sendEventPromise = () => new Promise((resolve, reject) => {
            let waitTimer;
            sender("[%s] Sender '%s', credit: %d available: %d", this._context.connectionId, this.name, this._sender.credit, this._sender.session.outgoing.available());
            if (this._sender.sendable()) {
                sender("[%s] Sender '%s', sending message with id '%s'.", this._context.connectionId, this.name, (Buffer.isBuffer(message) ? tag : message.message_id) || tag || "<not specified>");
                let onRejected;
                let onReleased;
                let onModified;
                let onAccepted;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    // When `removeListeners` is called on timeout, the sender might be closed and cleared
                    // So, check if it exists, before removing listeners from it.
                    if (this._sender) {
                        this._sender.removeListener(rheaPromise.SenderEvents.rejected, onRejected);
                        this._sender.removeListener(rheaPromise.SenderEvents.accepted, onAccepted);
                        this._sender.removeListener(rheaPromise.SenderEvents.released, onReleased);
                        this._sender.removeListener(rheaPromise.SenderEvents.modified, onModified);
                    }
                };
                onAccepted = (context) => {
                    // Since we will be adding listener for accepted and rejected event every time
                    // we send a message, we need to remove listener for both the events.
                    // This will ensure duplicate listeners are not added for the same event.
                    removeListeners();
                    sender("[%s] Sender '%s', got event accepted.", this._context.connectionId, this.name);
                    resolve(context.delivery);
                };
                onRejected = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event rejected.", this._context.connectionId, this.name);
                    const err = amqpCommon.translate(context.delivery.remote_state.error);
                    error(err);
                    reject(err);
                };
                onReleased = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event released.", this._context.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqpCommon.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.connectionId}] Sender '${this.name}', ` +
                            `received a release disposition.Hence we are rejecting the promise.`);
                    }
                    error(err);
                    reject(err);
                };
                onModified = (context) => {
                    removeListeners();
                    error("[%s] Sender '%s', got event modified.", this._context.connectionId, this.name);
                    let err;
                    if (context.delivery.remote_state.error) {
                        err = amqpCommon.translate(context.delivery.remote_state.error);
                    }
                    else {
                        err = new Error(`[${this._context.connectionId}] Sender "${this.name}", ` +
                            `received a modified disposition.Hence we are rejecting the promise.`);
                    }
                    error(err);
                    reject(err);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const desc = `[${this._context.connectionId}] Sender "${this.name}" with ` +
                        `address "${this.address}", was not able to send the message right now, due ` +
                        `to operation timeout.`;
                    error(desc);
                    const e = {
                        condition: amqpCommon.ErrorNameConditionMapper.ServiceUnavailableError,
                        description: desc
                    };
                    return reject(amqpCommon.translate(e));
                };
                this._sender.on(rheaPromise.SenderEvents.accepted, onAccepted);
                this._sender.on(rheaPromise.SenderEvents.rejected, onRejected);
                this._sender.on(rheaPromise.SenderEvents.modified, onModified);
                this._sender.on(rheaPromise.SenderEvents.released, onReleased);
                waitTimer = setTimeout(actionAfterTimeout, amqpCommon.Constants.defaultOperationTimeoutInSeconds * 1000);
                const delivery = this._sender.send(message, tag, format);
                sender("[%s] Sender '%s', sent message with delivery id: %d and tag: %s", this._context.connectionId, this.name, delivery.id, delivery.tag.toString());
            }
            else {
                // let us retry to send the message after some time.
                const msg = `[${this._context.connectionId}] Sender "${this.name}", ` +
                    `cannot send the message right now. Please try later.`;
                error(msg);
                const amqpError = {
                    condition: amqpCommon.ErrorNameConditionMapper.SenderBusyError,
                    description: msg
                };
                reject(amqpCommon.translate(amqpError));
            }
        });
        const jitterInSeconds = amqpCommon.randomNumberFromInterval(1, 4);
        const config = {
            operation: sendEventPromise,
            connectionId: this._context.connectionId,
            operationType: amqpCommon.RetryOperationType.sendMessage,
            times: amqpCommon.Constants.defaultRetryAttempts,
            delayInSeconds: amqpCommon.Constants.defaultDelayBetweenOperationRetriesInSeconds + jitterInSeconds
        };
        return amqpCommon.retry(config);
    }
    /**
     * Initializes the sender session on the connection.
     * @ignore
     * @returns {Promise<void>}
     */
    _init(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                // isOpen isConnecting  Should establish
                // true     false          No
                // true     true           No
                // false    true           No
                // false    false          Yes
                if (!this.isOpen() && !this.isConnecting) {
                    error("[%s] The sender '%s' with address '%s' is not open and is not currently " +
                        "establishing itself. Hence let's try to connect.", this._context.connectionId, this.name, this.address);
                    this.isConnecting = true;
                    yield this._negotiateClaim();
                    error("[%s] Trying to create sender '%s'...", this._context.connectionId, this.name);
                    if (!options) {
                        options = this._createSenderOptions({});
                    }
                    this._sender = yield this._context.connection.createSender(options);
                    this.isConnecting = false;
                    error("[%s] Sender '%s' with address '%s' has established itself.", this._context.connectionId, this.name, this.address);
                    this._sender.setMaxListeners(1000);
                    error("[%s] Promise to create the sender resolved. Created sender with name: %s", this._context.connectionId, this.name);
                    error("[%s] Sender '%s' created with sender options: %O", this._context.connectionId, this.name, options);
                    // It is possible for someone to close the sender and then start it again.
                    // Thus make sure that the sender is present in the client cache.
                    if (!this._context.senders[this.address])
                        this._context.senders[this.address] = this;
                    yield this._ensureTokenRenewal();
                }
                else {
                    error("[%s] The sender '%s' with address '%s' is open -> %s and is connecting " + "-> %s. Hence not reconnecting.", this._context.connectionId, this.name, this.address, this.isOpen(), this.isConnecting);
                }
            }
            catch (err) {
                this.isConnecting = false;
                err = amqpCommon.translate(err);
                error("[%s] An error occurred while creating the sender %s", this._context.connectionId, this.name, err);
                throw err;
            }
        });
    }
    /**
     * Creates a new sender to the given event hub, and optionally to a given partition if it is
     * not present in the context or returns the one present in the context.
     * @ignore
     * @static
     * @param {(string|number)} [partitionId] Partition ID to which it will send event data.
     * @returns {Promise<EventHubSender>}
     */
    static create(context, partitionId) {
        if (partitionId && typeof partitionId !== "string" && typeof partitionId !== "number") {
            throw new Error("'partitionId' must be of type: 'string' | 'number'.");
        }
        const ehSender = new EventHubSender(context, partitionId);
        if (!context.senders[ehSender.address]) {
            context.senders[ehSender.address] = ehSender;
        }
        return context.senders[ehSender.address];
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the batching receiver where the user can receive a specified number of messages for a predefined time.
 * @class BatchingReceiver
 * @extends EventHubReceiver
 * @ignore
 */
class BatchingReceiver extends EventHubReceiver {
    /**
     * Instantiate a new receiver from the AMQP `Receiver`. Used by `EventHubClient`.
     * @ignore
     * @constructor
     * @param {ConnectionContext} context                        The connection context.
     * @param {string} partitionId                               Partition ID from which to receive.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to connect.
     */
    constructor(context, partitionId, options) {
        super(context, partitionId, options);
    }
    /**
     * Receive a batch of EventData objects from an EventHub partition for a given count and
     * a given max wait time in seconds, whichever happens first. This method can be used directly
     * after creating the receiver object.
     * @ignore
     * @param {number} maxMessageCount The maximum message count. Must be a value greater than 0.
     * @param {number} [maxWaitTimeInSeconds] The maximum wait time in seconds for which the Receiver
     * should wait to receiver the said amount of messages. If not provided, it defaults to 60 seconds.
     * @returns {Promise<EventData[]>} A promise that resolves with an array of EventData objects.
     */
    receive(maxMessageCount, maxWaitTimeInSeconds) {
        if (!maxMessageCount || (maxMessageCount && typeof maxMessageCount !== "number")) {
            throw new Error("'maxMessageCount' is a required parameter of type number with a value greater than 0.");
        }
        if (maxWaitTimeInSeconds == undefined) {
            maxWaitTimeInSeconds = amqpCommon.Constants.defaultOperationTimeoutInSeconds;
        }
        const eventDatas = [];
        let timeOver = false;
        return new Promise((resolve, reject) => {
            let onReceiveMessage;
            let onReceiveError;
            let onReceiveClose;
            let onSessionError;
            let onSessionClose;
            let waitTimer;
            let actionAfterWaitTimeout;
            // Final action to be performed after maxMessageCount is reached or the maxWaitTime is over.
            const finalAction = (timeOver, data) => {
                // Resetting the mode. Now anyone can call start() or receive() again.
                if (this._receiver) {
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                    this._receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                }
                if (!data) {
                    data = eventDatas.length ? eventDatas[eventDatas.length - 1] : undefined;
                }
                if (!timeOver) {
                    clearTimeout(waitTimer);
                }
                if (this.receiverRuntimeMetricEnabled && data) {
                    this.runtimeInfo.lastSequenceNumber = data.lastSequenceNumber;
                    this.runtimeInfo.lastEnqueuedTimeUtc = data.lastEnqueuedTime;
                    this.runtimeInfo.lastEnqueuedOffset = data.lastEnqueuedOffset;
                    this.runtimeInfo.retrievalTime = data.retrievalTime;
                }
                resolve(eventDatas);
            };
            // Action to be performed after the max wait time is over.
            actionAfterWaitTimeout = () => {
                timeOver = true;
                batching("[%s] Batching Receiver '%s', %d messages received when max wait time in seconds %d is over.", this._context.connectionId, this.name, eventDatas.length, maxWaitTimeInSeconds);
                return finalAction(timeOver);
            };
            // Action to be performed on the "message" event.
            onReceiveMessage = (context) => {
                const data = exports.EventData.fromAmqpMessage(context.message);
                data.body = this._context.dataTransformer.decode(context.message.body);
                if (eventDatas.length <= maxMessageCount) {
                    eventDatas.push(data);
                }
                if (eventDatas.length === maxMessageCount) {
                    batching("[%s] Batching Receiver '%s', %d messages received within %d seconds.", this._context.connectionId, this.name, eventDatas.length, maxWaitTimeInSeconds);
                    finalAction(timeOver, data);
                }
            };
            // Action to be taken when an error is received.
            onReceiveError = (context) => {
                const receiver = this._receiver || context.receiver;
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onSessionError);
                const receiverError = context.receiver && context.receiver.error;
                let error$1 = new amqpCommon.MessagingError("An error occuured while receiving messages.");
                if (receiverError) {
                    error$1 = amqpCommon.translate(receiverError);
                    error("[%s] Receiver '%s' received an error:\n%O", this._context.connectionId, this.name, error$1);
                }
                if (waitTimer) {
                    clearTimeout(waitTimer);
                }
                reject(error$1);
            };
            onReceiveClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                const receiverError = context.receiver && context.receiver.error;
                if (receiverError) {
                    error("[%s] 'receiver_close' event occurred. The associated error is: %O", this._context.connectionId, receiverError);
                }
            });
            onSessionClose = (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                const sessionError = context.session && context.session.error;
                if (sessionError) {
                    error("[%s] 'session_close' event occurred for receiver '%s'. The associated error is: %O", this._context.connectionId, this.name, sessionError);
                }
            });
            onSessionError = (context) => {
                const receiver = this._receiver || context.receiver;
                receiver.removeListener(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                receiver.removeListener(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                receiver.session.removeListener(rheaPromise.SessionEvents.sessionError, onReceiveError);
                const sessionError = context.session && context.session.error;
                let error$1 = new amqpCommon.MessagingError("An error occuured while receiving messages.");
                if (sessionError) {
                    error$1 = amqpCommon.translate(sessionError);
                    error("[%s] 'session_close' event occurred for Receiver '%s' received an error:\n%O", this._context.connectionId, this.name, error$1);
                }
                if (waitTimer) {
                    clearTimeout(waitTimer);
                }
                reject(error$1);
            };
            const addCreditAndSetTimer = (reuse) => {
                batching("[%s] Receiver '%s', adding credit for receiving %d messages.", this._context.connectionId, this.name, maxMessageCount);
                this._receiver.addCredit(maxMessageCount);
                let msg = "[%s] Setting the wait timer for %d seconds for receiver '%s'.";
                if (reuse)
                    msg += " Receiver link already present, hence reusing it.";
                batching(msg, this._context.connectionId, maxWaitTimeInSeconds, this.name);
                waitTimer = setTimeout(actionAfterWaitTimeout, maxWaitTimeInSeconds * 1000);
            };
            if (!this.isOpen()) {
                batching("[%s] Receiver '%s', setting the prefetch count to 0.", this._context.connectionId, this.name);
                this.prefetchCount = 0;
                const rcvrOptions = this._createReceiverOptions({
                    onMessage: onReceiveMessage,
                    onError: onReceiveError,
                    onClose: onReceiveClose,
                    onSessionError: onSessionError,
                    onSessionClose: onSessionClose
                });
                this._init(rcvrOptions)
                    .then(() => addCreditAndSetTimer())
                    .catch(reject);
            }
            else {
                addCreditAndSetTimer(true);
                this._receiver.on(rheaPromise.ReceiverEvents.message, onReceiveMessage);
                this._receiver.on(rheaPromise.ReceiverEvents.receiverError, onReceiveError);
                this._receiver.session.on(rheaPromise.SessionEvents.sessionError, onReceiveError);
            }
        });
    }
    /**
     * Creates a batching receiver.
     * @static
     * @ignore
     * @param {ConnectionContext} context    The connection context.
     * @param {string | number} partitionId  The partitionId to receive events from.
     * @param {ReceiveOptions} [options]     Receive options.
     */
    static create(context, partitionId, options) {
        const bReceiver = new BatchingReceiver(context, partitionId, options);
        context.receivers[bReceiver.name] = bReceiver;
        return bReceiver;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class IotHubClient
 * @ignore
 */
class IotHubClient {
    constructor(connectionString) {
        this.connectionString = connectionString;
    }
    /**
     * Constructs the EventHub connection string by catching the redirect error and parsing the error
     * information.
     * @ignore
     * @param {ConnectionContextOptions} [options] optional parameters to be provided while creating
     * the connection context.
     * @return {Promise<string>} Promise<string>
     */
    getEventHubConnectionString(options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const iothubconfig = amqpCommon.IotHubConnectionConfig.create(this.connectionString);
            const config = amqpCommon.IotHubConnectionConfig.convertToEventHubConnectionConfig(iothubconfig);
            let result = "";
            if (!options)
                options = {};
            options.tokenProvider = new amqpCommon.IotSasTokenProvider(config.endpoint, config.sharedAccessKeyName, config.sharedAccessKey);
            options.managementSessionAddress = `/messages/events/$management`;
            const context = ConnectionContext.create(config, options);
            try {
                iotClient("Getting the hub runtime info from the iothub connection string to get the redirect error.");
                yield context.managementSession.getHubRuntimeInformation();
            }
            catch (err) {
                const error$1 = amqpCommon.translate(err);
                error("IotHubClient received the error: %O", error$1);
                const parsedInfo = this._parseRedirectError(err);
                error("Parsed info from redirect error is: %O", parsedInfo);
                result = this._buildConnectionString({
                    sharedAccessKey: config.sharedAccessKey,
                    sharedAccessKeyName: config.sharedAccessKeyName,
                    endpoint: parsedInfo.endpoint,
                    entityPath: parsedInfo.entityPath
                });
            }
            iotClient("The EventHub ConnectionString is: '%s'.", result);
            yield this.close(context);
            return result;
        });
    }
    /**
     * Closes the AMQP connection to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @ignore
     * @returns {Promise<any>}
     */
    close(context) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (context.connection.isOpen()) {
                    iotClient("Closing the IotHubClient connection...");
                    // Close the cbs session;
                    yield context.cbsSession.close();
                    iotClient("IotHub cbs session closed.");
                    // Close the management session
                    yield context.managementSession.close();
                    iotClient("IotHub management client closed.");
                    yield context.connection.close();
                    iotClient("Closed the amqp connection '%s' on the iothub client.", context.connectionId);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the connection "${context.connectionId}": ${err.stack}`;
                error(msg);
            }
        });
    }
    _parseRedirectError(error) {
        if (!error) {
            throw new Error("'error' is a required parameter and must be of type 'object'.");
        }
        if (error.name !== "LinkRedirectError" || !error.info) {
            throw error;
        }
        if (!error.info.hostname || !error.info.address) {
            const msg = `The received redirect error from IotHub is malformed. ${error.stack}\n${error.info}`;
            throw new Error(msg);
        }
        const address = error.info.address;
        const parsedResult = address.match(/5671\/(.*)\/\$management/i);
        if (parsedResult == undefined || (parsedResult && parsedResult[1] == undefined)) {
            const msg = `Cannot parse the EventHub name from the given address: ${address} in the error: ` +
                `${error.stack}\n${JSON.stringify(error.info)}.\nThe parsed result is: ${JSON.stringify(parsedResult)}.`;
            throw new Error(msg);
        }
        return {
            endpoint: error.info.hostname,
            entityPath: parsedResult[1]
        };
    }
    _buildConnectionString(config) {
        const parts = new Map();
        parts.set("Endpoint", `sb://${config.endpoint}/`);
        parts.set("SharedAccessKeyName", config.sharedAccessKeyName);
        parts.set("SharedAccessKey", config.sharedAccessKey);
        parts.set("EntityPath", config.entityPath);
        return Array.from(parts)
            .map(part => `${part[0]}=${part[1]}`)
            .join(";");
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @class EventHubClient
 * Describes the EventHub client.
 */
class EventHubClient {
    /**
     * Instantiates a client pointing to the Event Hub given by this configuration.
     *
     * @constructor
     * @param {EventHubConnectionConfig} config - The connection configuration to create the EventHub Client.
     * @param {ClientOptions} options - The optional parameters that can be provided to the EventHub
     * Client constructor.
     */
    constructor(config, options) {
        if (!options)
            options = {};
        this._context = ConnectionContext.create(config, options);
    }
    /**
     * @property {string} eventhubName The name of the Eventhub.
     * @readonly
     */
    get eventhubName() {
        return this._context.config.entityPath;
    }
    /**
     * Closes the AMQP connection to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @returns {Promise<void>} Promise<void>
     */
    close() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this._context.connection.isOpen()) {
                    // Close all the senders.
                    for (const senderName of Object.keys(this._context.senders)) {
                        yield this._context.senders[senderName].close();
                    }
                    // Close all the receivers.
                    for (const receiverName of Object.keys(this._context.receivers)) {
                        yield this._context.receivers[receiverName].close();
                    }
                    // Close the cbs session;
                    yield this._context.cbsSession.close();
                    // Close the management session
                    yield this._context.managementSession.close();
                    yield this._context.connection.close();
                    this._context.wasConnectionCloseCalled = true;
                    client("Closed the amqp connection '%s' on the client.", this._context.connectionId);
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the connection "${this._context.connectionId}": ${JSON.stringify(err)}`;
                error(msg);
                throw new Error(msg);
            }
        });
    }
    /**
     * Sends the given message to the EventHub.
     *
     * @param {any} data                    Message to send.  Will be sent as UTF8-encoded JSON string.
     * @param {string|number} [partitionId] Partition ID to which the event data needs to be sent. This should only be specified
     * if you intend to send the event to a specific partition. When not specified EventHub will store the messages in a round-robin
     * fashion amongst the different partitions in the EventHub.
     *
     * @returns {Promise<Delivery>} Promise<Delivery>
     */
    send(data, partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = EventHubSender.create(this._context, partitionId);
            return sender.send(data);
        });
    }
    /**
     * Send a batch of EventData to the EventHub. The "message_annotations", "application_properties" and "properties"
     * of the first message will be set as that of the envelope (batch message).
     *
     * @param {Array<EventData>} datas  An array of EventData objects to be sent in a Batch message.
     * @param {string|number} [partitionId] Partition ID to which the event data needs to be sent. This should only be specified
     * if you intend to send the event to a specific partition. When not specified EventHub will store the messages in a round-robin
     * fashion amongst the different partitions in the EventHub.
     *
     * @return {Promise<Delivery>} Promise<Delivery>
     */
    sendBatch(datas, partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const sender = EventHubSender.create(this._context, partitionId);
            return sender.sendBatch(datas);
        });
    }
    /**
     * Starts the receiver by establishing an AMQP session and an AMQP receiver link on the session. Messages will be passed to
     * the provided onMessage handler and error will be passed to the provided onError handler.
     *
     * @param {string|number} partitionId                        Partition ID from which to receive.
     * @param {OnMessage} onMessage                              The message handler to receive event data objects.
     * @param {OnError} onError                                  The error handler to receive an error that occurs
     * while receiving messages.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to receive messages.
     *
     * @returns {ReceiveHandler} ReceiveHandler - An object that provides a mechanism to stop receiving more messages.
     */
    receive(partitionId, onMessage, onError, options) {
        if (typeof partitionId !== "string" && typeof partitionId !== "number") {
            throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
        }
        const sReceiver = StreamingReceiver.create(this._context, partitionId, options);
        this._context.receivers[sReceiver.name] = sReceiver;
        return sReceiver.receive(onMessage, onError);
    }
    /**
     * Receives a batch of EventData objects from an EventHub partition for a given count and a given max wait time in seconds, whichever
     * happens first. This method can be used directly after creating the receiver object and **MUST NOT** be used along with the `start()` method.
     *
     * @param {string|number} partitionId                        Partition ID from which to receive.
     * @param {number} maxMessageCount                           The maximum message count. Must be a value greater than 0.
     * @param {number} [maxWaitTimeInSeconds]                    The maximum wait time in seconds for which the Receiver should wait
     * to receiver the said amount of messages. If not provided, it defaults to 60 seconds.
     * @param {ReceiveOptions} [options]                         Options for how you'd like to receive messages.
     *
     * @returns {Promise<Array<EventData>>} Promise<Array<EventData>>.
     */
    receiveBatch(partitionId, maxMessageCount, maxWaitTimeInSeconds, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (typeof partitionId !== "string" && typeof partitionId !== "number") {
                throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
            }
            const bReceiver = BatchingReceiver.create(this._context, partitionId, options);
            this._context.receivers[bReceiver.name] = bReceiver;
            let error$1;
            let result = [];
            try {
                result = yield bReceiver.receive(maxMessageCount, maxWaitTimeInSeconds);
            }
            catch (err) {
                error$1 = err;
                error("[%s] Receiver '%s', an error occurred while receiving %d messages for %d max time:\n %O", this._context.connectionId, bReceiver.name, maxMessageCount, maxWaitTimeInSeconds, err);
            }
            try {
                yield bReceiver.close();
            }
            catch (err) {
                // do nothing about it.
            }
            if (error$1) {
                throw error$1;
            }
            return result;
        });
    }
    /**
     * Provides the eventhub runtime information.
     * @returns {Promise<EventHubRuntimeInformation>} A promise that resolves with EventHubRuntimeInformation.
     */
    getHubRuntimeInformation() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._context.managementSession.getHubRuntimeInformation();
            }
            catch (err) {
                error("An error occurred while getting the hub runtime information: %O", err);
                throw err;
            }
        });
    }
    /**
     * Provides an array of partitionIds.
     * @returns {Promise<Array<string>>} A promise that resolves with an Array of strings.
     */
    getPartitionIds() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const runtimeInfo = yield this.getHubRuntimeInformation();
                return runtimeInfo.partitionIds;
            }
            catch (err) {
                error("An error occurred while getting the partition ids: %O", err);
                throw err;
            }
        });
    }
    /**
     * Provides information about the specified partition.
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     * @returns {Promise<EventHubPartitionRuntimeInformation>} A promise that resoloves with EventHubPartitionRuntimeInformation.
     */
    getPartitionInformation(partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (typeof partitionId !== "string" && typeof partitionId !== "number") {
                throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
            }
            try {
                return yield this._context.managementSession.getPartitionInformation(partitionId);
            }
            catch (err) {
                error("An error occurred while getting the partition information: %O", err);
                throw err;
            }
        });
    }
    /**
     * Creates an EventHub Client from connection string.
     * @param {string} connectionString - Connection string of the form 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {string} [path] - EventHub path of the form 'my-event-hub-name'
     * @param {ClientOptions} [options] Options that can be provided during client creation.
     * @returns {EventHubClient} - An instance of the eventhub client.
     */
    static createFromConnectionString(connectionString, path, options) {
        if (!connectionString || (connectionString && typeof connectionString !== "string")) {
            throw new Error("'connectionString' is a required parameter and must be of type: 'string'.");
        }
        const config = amqpCommon.EventHubConnectionConfig.create(connectionString, path);
        config.webSocket = options && options.webSocket;
        config.webSocketEndpointPath = "$servicebus/websocket";
        config.webSocketConstructorOptions = options && options.webSocketConstructorOptions;
        if (!config.entityPath) {
            throw new Error(`Either the connectionString must have "EntityPath=<path-to-entity>" or ` +
                `you must provide "path", while creating the client`);
        }
        return new EventHubClient(config, options);
    }
    /**
     * Creates an EventHub Client from connection string.
     * @param {string} iothubConnectionString - Connection string of the form 'HostName=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {ClientOptions} [options] Options that can be provided during client creation.
     * @returns {Promise<EventHubClient>} - Promise<EventHubClient>.
     */
    static createFromIotHubConnectionString(iothubConnectionString, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!iothubConnectionString || (iothubConnectionString && typeof iothubConnectionString !== "string")) {
                throw new Error("'connectionString' is a required parameter and must be of type: 'string'.");
            }
            const connectionString = yield new IotHubClient(iothubConnectionString).getEventHubConnectionString();
            return EventHubClient.createFromConnectionString(connectionString, undefined, options);
        });
    }
    /**
     * Creates an EventHub Client from a generic token provider.
     * @param {string} host - Fully qualified domain name for Event Hubs. Most likely,
     * <yournamespace>.servicebus.windows.net
     * @param {string} entityPath - EventHub path of the form 'my-event-hub-name'
     * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.
     * @param {ClientOptionsBase} options - The options that can be provided during client creation.
     * @returns {EventHubClient} An instance of the Eventhub client.
     */
    static createFromTokenProvider(host, entityPath, tokenProvider, options) {
        if (!host || (host && typeof host !== "string")) {
            throw new Error("'host' is a required parameter and must be of type: 'string'.");
        }
        if (!entityPath || (entityPath && typeof entityPath !== "string")) {
            throw new Error("'entityPath' is a required parameter and must be of type: 'string'.");
        }
        if (!tokenProvider || (tokenProvider && typeof tokenProvider !== "object")) {
            throw new Error("'tokenProvider' is a required parameter and must be of type: 'object'.");
        }
        if (!host.endsWith("/"))
            host += "/";
        const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;` + `SharedAccessKey=defaultKeyValue`;
        if (!options)
            options = {};
        const clientOptions = options;
        clientOptions.tokenProvider = tokenProvider;
        return EventHubClient.createFromConnectionString(connectionString, entityPath, clientOptions);
    }
    /**
     * Creates an EventHub Client from AADTokenCredentials.
     * @param {string} host - Fully qualified domain name for Event Hubs. Most likely,
     * <yournamespace>.servicebus.windows.net
     * @param {string} entityPath - EventHub path of the form 'my-event-hub-name'
     * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the following:
     * ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials.
     * @param {ClientOptionsBase} options - The options that can be provided during client creation.
     * @returns {EventHubClient} An instance of the Eventhub client.
     */
    static createFromAadTokenCredentials(host, entityPath, credentials, options) {
        if (!credentials || (credentials && typeof credentials !== "object")) {
            throw new Error("'credentials' is a required parameter and must be an instance of " +
                "ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | " +
                "MSITokenCredentials.");
        }
        if (credentials instanceof msRestNodeauth.MSITokenCredentials) {
            credentials.resource = amqpCommon.Constants.aadEventHubsAudience;
        }
        const tokenProvider = new amqpCommon.AadTokenProvider(credentials);
        return EventHubClient.createFromTokenProvider(host, entityPath, tokenProvider, options);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
const aadEventHubsAudience = amqpCommon.Constants.aadEventHubsAudience;

Object.defineProperty(exports, 'AadTokenProvider', {
    enumerable: true,
    get: function () {
        return amqpCommon.AadTokenProvider;
    }
});
Object.defineProperty(exports, 'ConditionErrorNameMapper', {
    enumerable: true,
    get: function () {
        return amqpCommon.ConditionErrorNameMapper;
    }
});
Object.defineProperty(exports, 'ConditionStatusMapper', {
    enumerable: true,
    get: function () {
        return amqpCommon.ConditionStatusMapper;
    }
});
Object.defineProperty(exports, 'ConnectionConfig', {
    enumerable: true,
    get: function () {
        return amqpCommon.ConnectionConfig;
    }
});
Object.defineProperty(exports, 'DefaultDataTransformer', {
    enumerable: true,
    get: function () {
        return amqpCommon.DefaultDataTransformer;
    }
});
Object.defineProperty(exports, 'ErrorNameConditionMapper', {
    enumerable: true,
    get: function () {
        return amqpCommon.ErrorNameConditionMapper;
    }
});
Object.defineProperty(exports, 'EventHubConnectionConfig', {
    enumerable: true,
    get: function () {
        return amqpCommon.EventHubConnectionConfig;
    }
});
Object.defineProperty(exports, 'MessagingError', {
    enumerable: true,
    get: function () {
        return amqpCommon.MessagingError;
    }
});
Object.defineProperty(exports, 'SasTokenProvider', {
    enumerable: true,
    get: function () {
        return amqpCommon.SasTokenProvider;
    }
});
Object.defineProperty(exports, 'Timeout', {
    enumerable: true,
    get: function () {
        return amqpCommon.Timeout;
    }
});
Object.defineProperty(exports, 'TokenType', {
    enumerable: true,
    get: function () {
        return amqpCommon.TokenType;
    }
});
Object.defineProperty(exports, 'delay', {
    enumerable: true,
    get: function () {
        return amqpCommon.delay;
    }
});
Object.defineProperty(exports, 'isIotHubConnectionString', {
    enumerable: true,
    get: function () {
        return amqpCommon.isIotHubConnectionString;
    }
});
Object.defineProperty(exports, 'parseConnectionString', {
    enumerable: true,
    get: function () {
        return amqpCommon.parseConnectionString;
    }
});
exports.EventHubClient = EventHubClient;
exports.EventPosition = EventPosition;
exports.ReceiveHandler = ReceiveHandler;
exports.aadEventHubsAudience = aadEventHubsAudience;
//# sourceMappingURL=index.js.map
