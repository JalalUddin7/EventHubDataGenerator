// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import uuid from "uuid/v4";
import { RequestResponseLink, defaultLock, translate, Constants } from "@azure/amqp-common";
import { SenderEvents, ReceiverEvents } from "rhea-promise";
import { LinkEntity } from "./linkEntity";
import * as log from "./log";
/**
 * @class ManagementClient
 * @ignore
 * Descibes the EventHubs Management Client that talks
 * to the $management endpoint over AMQP connection.
 */
export class ManagementClient extends LinkEntity {
    /**
     * Instantiates the management client.
     * @constructor
     * @ignore
     * @param {BaseConnectionContext} context The connection context.
     * @param {string} [address] The address for the management endpoint. For IotHub it will be
     * `/messages/events/$management`.
     */
    constructor(context, options) {
        super(context, {
            address: options && options.address ? options.address : Constants.management,
            audience: options && options.audience ? options.audience : context.config.getManagementAudience()
        });
        this.managementLock = `${Constants.managementRequestKey}-${uuid()}`;
        /**
         * @property {string} replyTo The reply to Guid for the management client.
         */
        this.replyTo = uuid();
        this._context = context;
        this.entityPath = context.config.entityPath;
    }
    /**
     * Provides the eventhub runtime information.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<EventHubRuntimeInformation>}
     */
    getHubRuntimeInformation() {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this._makeManagementRequest(Constants.eventHub);
            const runtimeInfo = {
                path: info.name,
                createdAt: new Date(info.created_at),
                partitionCount: info.partition_count,
                partitionIds: info.partition_ids,
                type: info.type
            };
            log.mgmt("[%s] The hub runtime info is: %O", this._context.connectionId, runtimeInfo);
            return runtimeInfo;
        });
    }
    /**
     * Provides an array of partitionIds.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @returns {Promise<Array<string>>}
     */
    getPartitionIds() {
        return __awaiter(this, void 0, void 0, function* () {
            const runtimeInfo = yield this.getHubRuntimeInformation();
            return runtimeInfo.partitionIds;
        });
    }
    /**
     * Provides information about the specified partition.
     * @ignore
     * @param {Connection} connection - The established amqp connection
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     */
    getPartitionInformation(partitionId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof partitionId !== "string" && typeof partitionId !== "number") {
                throw new Error("'partitionId' is a required parameter and must be of " + "type: 'string' | 'number'.");
            }
            const info = yield this._makeManagementRequest(Constants.partition, partitionId);
            const partitionInfo = {
                beginningSequenceNumber: info.begin_sequence_number,
                hubPath: info.name,
                lastEnqueuedOffset: info.last_enqueued_offset,
                lastEnqueuedTimeUtc: new Date(info.last_enqueued_time_utc),
                lastSequenceNumber: info.last_enqueued_sequence_number,
                partitionId: info.partition,
                type: info.type
            };
            log.mgmt("[%s] The partition info is: %O.", this._context.connectionId, partitionInfo);
            return partitionInfo;
        });
    }
    /**
     * Closes the AMQP management session to the Event Hub for this client,
     * returning a promise that will be resolved when disconnection is completed.
     * @ignore
     * @return {Promise<void>}
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this._isMgmtRequestResponseLinkOpen()) {
                    const mgmtLink = this._mgmtReqResLink;
                    this._mgmtReqResLink = undefined;
                    clearTimeout(this._tokenRenewalTimer);
                    yield mgmtLink.close();
                    log.mgmt("Successfully closed the management session.");
                }
            }
            catch (err) {
                const msg = `An error occurred while closing the management session: ${err}`;
                log.error(msg);
                throw new Error(msg);
            }
        });
    }
    _init() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._isMgmtRequestResponseLinkOpen()) {
                    yield this._negotiateClaim();
                    const rxopt = {
                        source: { address: this.address },
                        name: this.replyTo,
                        target: { address: this.replyTo },
                        onSessionError: (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.session.error);
                            log.error("[%s] An error occurred on the session for request/response links for " + "$management: %O", id, ehError);
                        }
                    };
                    const sropt = { target: { address: this.address } };
                    log.mgmt("[%s] Creating sender/receiver links on a session for $management endpoint with " +
                        "srOpts: %o, receiverOpts: %O.", this._context.connectionId, sropt, rxopt);
                    this._mgmtReqResLink = yield RequestResponseLink.create(this._context.connection, sropt, rxopt);
                    this._mgmtReqResLink.sender.on(SenderEvents.senderError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = translate(context.sender.error);
                        log.error("[%s] An error occurred on the $management sender link.. %O", id, ehError);
                    });
                    this._mgmtReqResLink.receiver.on(ReceiverEvents.receiverError, (context) => {
                        const id = context.connection.options.id;
                        const ehError = translate(context.receiver.error);
                        log.error("[%s] An error occurred on the $management receiver link.. %O", id, ehError);
                    });
                    log.mgmt("[%s] Created sender '%s' and receiver '%s' links for $management endpoint.", this._context.connectionId, this._mgmtReqResLink.sender.name, this._mgmtReqResLink.receiver.name);
                    yield this._ensureTokenRenewal();
                }
            }
            catch (err) {
                err = translate(err);
                log.error("[%s] An error occured while establishing the $management links: %O", this._context.connectionId, err);
                throw err;
            }
        });
    }
    /**
     * @private
     * Helper method to make the management request
     * @param {Connection} connection - The established amqp connection
     * @param {string} type - The type of entity requested for. Valid values are "eventhub", "partition"
     * @param {string | number} [partitionId] - The partitionId. Required only when type is "partition".
     */
    _makeManagementRequest(type, partitionId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (partitionId != undefined && (typeof partitionId !== "string" && typeof partitionId !== "number")) {
                throw new Error("'partitionId' is a required parameter and must be of type: 'string' | 'number'.");
            }
            try {
                const request = {
                    body: Buffer.from(JSON.stringify([])),
                    message_id: uuid(),
                    reply_to: this.replyTo,
                    application_properties: {
                        operation: Constants.readOperation,
                        name: this.entityPath,
                        type: `${Constants.vendorString}:${type}`
                    }
                };
                if (partitionId != undefined && type === Constants.partition) {
                    request.application_properties.partition = `${partitionId}`;
                }
                log.mgmt("[%s] Acquiring lock to get the management req res link.", this._context.connectionId);
                yield defaultLock.acquire(this.managementLock, () => {
                    return this._init();
                });
                return (yield this._mgmtReqResLink.sendRequest(request)).body;
            }
            catch (err) {
                err = translate(err);
                log.error("An error occurred while making the request to $management endpoint: %O", err);
                throw err;
            }
        });
    }
    _isMgmtRequestResponseLinkOpen() {
        return this._mgmtReqResLink && this._mgmtReqResLink.isOpen();
    }
}
//# sourceMappingURL=managementClient.js.map