(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory((global.Azure = global.Azure || {}, global.Azure.AMQPCommon = {})));
}(this, function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    var tslib_es6 = /*#__PURE__*/Object.freeze({
        __extends: __extends,
        get __assign () { return __assign; },
        __rest: __rest,
        __decorate: __decorate,
        __param: __param,
        __metadata: __metadata,
        __awaiter: __awaiter,
        __generator: __generator,
        __exportStar: __exportStar,
        __values: __values,
        __read: __read,
        __spread: __spread,
        __spreadArrays: __spreadArrays,
        __await: __await,
        __asyncGenerator: __asyncGenerator,
        __asyncDelegator: __asyncDelegator,
        __asyncValues: __asyncValues,
        __makeTemplateObject: __makeTemplateObject,
        __importStar: __importStar,
        __importDefault: __importDefault
    });

    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the MIT License. See License.txt in the project root for license information.
    const associatedLinkName = "associated-link-name";
    const partitionKey = "x-opt-partition-key";
    const sequenceNumber = "x-opt-sequence-number";
    const enqueueSequenceNumber = "x-opt-enqueue-sequence-number";
    const enqueuedTime = "x-opt-enqueued-time";
    const scheduledEnqueueTime = "x-opt-scheduled-enqueue-time";
    const offset = "x-opt-offset";
    const lockedUntil = "x-opt-locked-until";
    const partitionIdName = "x-opt-partition-id";
    const publisher = "x-opt-publisher-name";
    const viaPartitionKey = "x-opt-via-partition-key";
    const deadLetterSource = "x-opt-deadletter-source";
    const enqueuedTimeAnnotation = `amqp.annotation.${enqueuedTime}`;
    const offsetAnnotation = `amqp.annotation.${offset}`;
    const sequenceNumberAnnotation = `amqp.annotation.${sequenceNumber}`;
    const guidSize = 16;
    const message = "message";
    const error = "error";
    const statusCode = "status-code";
    const statusDescription = "status-description";
    const errorCondition = "error-condition";
    const management = "$management";
    const partition = "partition";
    const partitionId = "partitionId";
    const readOperation = "READ";
    const TLS = "tls";
    const establishConnection = "establishConnection";
    const defaultConsumerGroup = "$default";
    const eventHub = "eventhub";
    const cbsEndpoint = "$cbs";
    const cbsReplyTo = "cbs";
    const operationPutToken = "put-token";
    const aadEventHubsAudience = "https://eventhubs.azure.net/";
    const aadServiceBusAudience = "https://servicebus.azure.net/";
    const maxUserAgentLength = 512;
    const vendorString = "com.microsoft";
    const attachEpoch = `${vendorString}:epoch`;
    const receiverIdentifierName = `${vendorString}:receiver-name`;
    const enableReceiverRuntimeMetricName = `${vendorString}:enable-receiver-runtime-metric`;
    const timespan = `${vendorString}:timespan`;
    const uri = `${vendorString}:uri`;
    const dateTimeOffset = `${vendorString}:datetime-offset`;
    const sessionFilterName = `${vendorString}:session-filter`;
    const receiverError = "receiver_error";
    const senderError = "sender_error";
    const sessionError = "session_error";
    const connectionError = "connection_error";
    const defaultOperationTimeoutInSeconds = 60;
    const defaultConnectionIdleTimeoutInMs = 60000;
    const managementRequestKey = "managementRequest";
    const negotiateCbsKey = "negotiateCbs";
    const negotiateClaim = "negotiateClaim";
    const ensureContainerAndBlob = "ensureContainerAndBlob";
    const defaultPrefetchCount = 1000;
    const reconnectLimit = 100;
    const maxMessageIdLength = 128;
    const maxPartitionKeyLength = 128;
    const maxSessionIdLength = 128;
    const pathDelimiter = "/";
    const ruleNameMaximumLength = 50;
    const maximumSqlFilterStatementLength = 1024;
    const maximumSqlRuleActionStatementLength = 1024;
    const maxDeadLetterReasonLength = 4096;
    // https://stackoverflow.com/questions/11526504/minimum-and-maximum-date for js
    // However we are setting this to the TimeSpan.MaxValue of C#.
    const maxDurationValue = 922337203685477;
    const minDurationValue = -922337203685477;
    // https://github.com/Azure/azure-amqp/blob/master/Microsoft.Azure.Amqp/Amqp/AmqpConstants.cs#L47
    const maxAbsoluteExpiryTime = new Date("9999-12-31T07:59:59.000Z").getTime();
    const aadTokenValidityMarginSeconds = 5;
    const connectionReconnectDelay = 300;
    const defaultRetryAttempts = 3;
    const defaultConnectionRetryAttempts = 150;
    const defaultDelayBetweenOperationRetriesInSeconds = 5;
    const defaultDelayBetweenRetriesInSeconds = 15;
    const receiverSettleMode = "receiver-settle-mode";
    const dispositionStatus = "disposition-status";
    const fromSequenceNumber = "from-sequence-number";
    const messageCount = "message-count";
    const lockTokens = "lock-tokens";
    const messageIdMapKey = "message-id";
    const sequenceNumberMapKey = "sequence-number";
    const lockTokenMapKey = "lock-token";
    const sessionIdMapKey = "session-id";
    const sequenceNumbers = "sequence-numbers";
    const deadLetterReason = "deadletter-reason";
    const deadLetterDescription = "deadletter-description";
    const propertiesToModify = "properties-to-modify";
    const deadLetterName = "com.microsoft:dead-letter";
    const trackingId = "com.microsoft:tracking-id";
    const serverTimeout = "com.microsoft:server-timeout";
    const operations = {
        putToken: "put-token",
        read: "READ",
        cancelScheduledMessage: "com.microsoft:cancel-scheduled-message",
        scheduleMessage: "com.microsoft:schedule-message",
        renewLock: "com.microsoft:renew-lock",
        peekMessage: "com.microsoft:peek-message",
        receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number",
        updateDisposition: "com.microsoft:update-disposition",
        renewSessionLock: "com.microsoft:renew-session-lock",
        setSessionState: "com.microsoft:set-session-state",
        getSessionState: "com.microsoft:get-session-state",
        enumerateSessions: "com.microsoft:get-message-sessions",
        addRule: "com.microsoft:add-rule",
        removeRule: "com.microsoft:remove-rule",
        enumerateRules: "com.microsoft:enumerate-rules"
    };
    const descriptorCodes = {
        ruleDescriptionList: 1335734829060,
        sqlFilterList: 83483426822,
        correlationFilterList: 83483426825,
        sqlRuleActionList: 1335734829062,
        trueFilterList: 83483426823,
        falseFilterList: 83483426824
    };

    var constants = /*#__PURE__*/Object.freeze({
        associatedLinkName: associatedLinkName,
        partitionKey: partitionKey,
        sequenceNumber: sequenceNumber,
        enqueueSequenceNumber: enqueueSequenceNumber,
        enqueuedTime: enqueuedTime,
        scheduledEnqueueTime: scheduledEnqueueTime,
        offset: offset,
        lockedUntil: lockedUntil,
        partitionIdName: partitionIdName,
        publisher: publisher,
        viaPartitionKey: viaPartitionKey,
        deadLetterSource: deadLetterSource,
        enqueuedTimeAnnotation: enqueuedTimeAnnotation,
        offsetAnnotation: offsetAnnotation,
        sequenceNumberAnnotation: sequenceNumberAnnotation,
        guidSize: guidSize,
        message: message,
        error: error,
        statusCode: statusCode,
        statusDescription: statusDescription,
        errorCondition: errorCondition,
        management: management,
        partition: partition,
        partitionId: partitionId,
        readOperation: readOperation,
        TLS: TLS,
        establishConnection: establishConnection,
        defaultConsumerGroup: defaultConsumerGroup,
        eventHub: eventHub,
        cbsEndpoint: cbsEndpoint,
        cbsReplyTo: cbsReplyTo,
        operationPutToken: operationPutToken,
        aadEventHubsAudience: aadEventHubsAudience,
        aadServiceBusAudience: aadServiceBusAudience,
        maxUserAgentLength: maxUserAgentLength,
        vendorString: vendorString,
        attachEpoch: attachEpoch,
        receiverIdentifierName: receiverIdentifierName,
        enableReceiverRuntimeMetricName: enableReceiverRuntimeMetricName,
        timespan: timespan,
        uri: uri,
        dateTimeOffset: dateTimeOffset,
        sessionFilterName: sessionFilterName,
        receiverError: receiverError,
        senderError: senderError,
        sessionError: sessionError,
        connectionError: connectionError,
        defaultOperationTimeoutInSeconds: defaultOperationTimeoutInSeconds,
        defaultConnectionIdleTimeoutInMs: defaultConnectionIdleTimeoutInMs,
        managementRequestKey: managementRequestKey,
        negotiateCbsKey: negotiateCbsKey,
        negotiateClaim: negotiateClaim,
        ensureContainerAndBlob: ensureContainerAndBlob,
        defaultPrefetchCount: defaultPrefetchCount,
        reconnectLimit: reconnectLimit,
        maxMessageIdLength: maxMessageIdLength,
        maxPartitionKeyLength: maxPartitionKeyLength,
        maxSessionIdLength: maxSessionIdLength,
        pathDelimiter: pathDelimiter,
        ruleNameMaximumLength: ruleNameMaximumLength,
        maximumSqlFilterStatementLength: maximumSqlFilterStatementLength,
        maximumSqlRuleActionStatementLength: maximumSqlRuleActionStatementLength,
        maxDeadLetterReasonLength: maxDeadLetterReasonLength,
        maxDurationValue: maxDurationValue,
        minDurationValue: minDurationValue,
        maxAbsoluteExpiryTime: maxAbsoluteExpiryTime,
        aadTokenValidityMarginSeconds: aadTokenValidityMarginSeconds,
        connectionReconnectDelay: connectionReconnectDelay,
        defaultRetryAttempts: defaultRetryAttempts,
        defaultConnectionRetryAttempts: defaultConnectionRetryAttempts,
        defaultDelayBetweenOperationRetriesInSeconds: defaultDelayBetweenOperationRetriesInSeconds,
        defaultDelayBetweenRetriesInSeconds: defaultDelayBetweenRetriesInSeconds,
        receiverSettleMode: receiverSettleMode,
        dispositionStatus: dispositionStatus,
        fromSequenceNumber: fromSequenceNumber,
        messageCount: messageCount,
        lockTokens: lockTokens,
        messageIdMapKey: messageIdMapKey,
        sequenceNumberMapKey: sequenceNumberMapKey,
        lockTokenMapKey: lockTokenMapKey,
        sessionIdMapKey: sessionIdMapKey,
        sequenceNumbers: sequenceNumbers,
        deadLetterReason: deadLetterReason,
        deadLetterDescription: deadLetterDescription,
        propertiesToModify: propertiesToModify,
        deadLetterName: deadLetterName,
        trackingId: trackingId,
        serverTimeout: serverTimeout,
        operations: operations,
        descriptorCodes: descriptorCodes
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var commonjsHelpers = /*#__PURE__*/Object.freeze({
        commonjsGlobal: commonjsGlobal,
        commonjsRequire: commonjsRequire,
        unwrapExports: unwrapExports,
        createCommonjsModule: createCommonjsModule,
        getCjsExportFromNamespace: getCjsExportFromNamespace
    });

    var browser = createCommonjsModule(function (module) {
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ());
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) { return [] };

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    });

    var byteLength_1 = byteLength;
    var toByteArray_1 = toByteArray;
    var fromByteArray_1 = fromByteArray;

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;

    function getLens (b64) {
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=');
      if (validLen === -1) validLen = len;

      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4);

      return [validLen, placeHoldersLen]
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function toByteArray (b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

      var curByte = 0;

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen;

      var i;
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = (tmp >> 16) & 0xFF;
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[curByte++] = tmp & 0xFF;
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(
          uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
        ));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        );
      }

      return parts.join('')
    }

    var base64Js = {
    	byteLength: byteLength_1,
    	toByteArray: toByteArray_1,
    	fromByteArray: fromByteArray_1
    };

    var read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    };

    var write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = (nBytes * 8) - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    };

    var ieee754 = {
    	read: read,
    	write: write
    };

    var buffer = createCommonjsModule(function (module, exports) {



    var customInspectSymbol =
      (typeof Symbol === 'function' && typeof Symbol.for === 'function')
        ? Symbol.for('nodejs.util.inspect.custom')
        : null;

    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;

    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
        typeof console.error === 'function') {
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by ' +
        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      );
    }

    function typedArraySupport () {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function () { return 42 } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42
      } catch (e) {
        return false
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.buffer
      }
    });

    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.byteOffset
      }
    });

    function createBuffer (length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"')
      }
      // Return an augmented `Uint8Array` instance
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          )
        }
        return allocUnsafe(arg)
      }
      return from(arg, encodingOrOffset, length)
    }

    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    if (typeof Symbol !== 'undefined' && Symbol.species != null &&
        Buffer[Symbol.species] === Buffer) {
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      });
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from (value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset)
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayLike(value)
      }

      if (value == null) {
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
          'or Array-like Object. Received type ' + (typeof value)
        )
      }

      if (isInstance(value, ArrayBuffer) ||
          (value && isInstance(value.buffer, ArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }

      if (typeof value === 'number') {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        )
      }

      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length)
      }

      var b = fromObject(value);
      if (b) return b

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
          typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(
          value[Symbol.toPrimitive]('string'), encodingOrOffset, length
        )
      }

      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length)
    };

    // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number')
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"')
      }
    }

    function alloc (size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(size).fill(fill, encoding)
          : createBuffer(size).fill(fill)
      }
      return createBuffer(size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding)
    };

    function allocUnsafe (size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0)
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size)
    };

    function fromString (string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);

      var actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf
    }

    function fromArrayLike (array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf
    }

    function fromArrayBuffer (array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds')
      }

      var buf;
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }

      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(buf, Buffer.prototype);

      return buf
    }

    function fromObject (obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf
        }

        obj.copy(buf, 0, 0, len);
        return buf
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0)
        }
        return fromArrayLike(obj)
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data)
      }
    }

    function checked (length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
      }
      return length | 0
    }

    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0;
      }
      return Buffer.alloc(+length)
    }

    Buffer.isBuffer = function isBuffer (b) {
      return b != null && b._isBuffer === true &&
        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare (a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          buf = Buffer.from(buf);
        }
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
          'Received type ' + typeof string
        )
      }

      var len = string.length;
      var mustMatch = (arguments.length > 2 && arguments[2] === true);
      if (!mustMatch && len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            }
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>'
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. ' +
          'Received type ' + (typeof target)
        )
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset; // Coerce to Number.
      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64Js.fromByteArray(buf)
      } else {
        return base64Js.fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
            : (firstByte > 0xBF) ? 2
              : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf = this.subarray(start, end);
      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(newBuf, Buffer.prototype);

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2
    };

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (var i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if ((encoding === 'utf8' && code < 128) ||
              encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val +
            '" is invalid for argument "value"')
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0];
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = str.trim().replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }

    function base64ToBytes (str) {
      return base64Js.toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166
    function isInstance (obj, type) {
      return obj instanceof type ||
        (obj != null && obj.constructor != null && obj.constructor.name != null &&
          obj.constructor.name === type.name)
    }
    function numberIsNaN (obj) {
      // For IE11 support
      return obj !== obj // eslint-disable-line no-self-compare
    }

    // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219
    var hexSliceLookupTable = (function () {
      var alphabet = '0123456789abcdef';
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table
    })();
    });
    var buffer_1 = buffer.Buffer;
    var buffer_2 = buffer.SlowBuffer;
    var buffer_3 = buffer.INSPECT_MAX_BYTES;
    var buffer_4 = buffer.kMaxLength;

    var isBufferBrowser = function isBuffer(arg) {
      return arg && typeof arg === 'object'
        && typeof arg.copy === 'function'
        && typeof arg.fill === 'function'
        && typeof arg.readUInt8 === 'function';
    };

    var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    });

    var util = createCommonjsModule(function (module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
      function getOwnPropertyDescriptors(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };

    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };


    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    exports.deprecate = function(fn, msg) {
      if (typeof browser !== 'undefined' && browser.noDeprecation === true) {
        return fn;
      }

      // Allow for deprecating things in the process of starting up.
      if (typeof browser === 'undefined') {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          if (browser.throwDeprecation) {
            throw new Error(msg);
          } else if (browser.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    };


    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = browser.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = browser.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };


    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;


    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;

    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;

    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;

    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;

    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;

    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;

    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;

    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;

    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;

    exports.isBuffer = isBufferBrowser;

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }


    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }


    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];

    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }


    // log is just a thin wrapper to console.log that prepends a timestamp
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };


    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * The Function.prototype.inherits from lang.js rewritten as a standalone
     * function (not on Function.prototype). NOTE: If this file is to be loaded
     * during bootstrapping this function needs to be rewritten using some native
     * functions as prototype setup using normal JavaScript does not work as
     * expected during bootstrapping (see mirror.js in r114903).
     *
     * @param {function} ctor Constructor function which needs to inherit the
     *     prototype.
     * @param {function} superCtor Constructor function to inherit prototype from.
     */
    exports.inherits = inherits_browser;

    exports._extend = function(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

    exports.promisify = function promisify(original) {
      if (typeof original !== 'function')
        throw new TypeError('The "original" argument must be of type Function');

      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== 'function') {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn, enumerable: false, writable: false, configurable: true
        });
        return fn;
      }

      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });

        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function (err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });

        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }

        return promise;
      }

      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn, enumerable: false, writable: false, configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };

    exports.promisify.custom = kCustomPromisifiedSymbol;

    function callbackifyOnRejected(reason, cb) {
      // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
      // Because `null` is a special error value in callbacks which means "no error
      // occurred", we error-wrap so the callback consumer can distinguish between
      // "the promise rejected with null" or "the promise fulfilled with undefined".
      if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }

    function callbackify(original) {
      if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
      }

      // We DO NOT return the promise as it gives the user a false sense that
      // the promise is actually somehow related to the callback's execution
      // and that the callback throwing will reject the promise.
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        var maybeCb = args.pop();
        if (typeof maybeCb !== 'function') {
          throw new TypeError('The last argument must be of type Function');
        }
        var self = this;
        var cb = function() {
          return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args)
          .then(function(ret) { browser.nextTick(cb, null, ret); },
                function(rej) { browser.nextTick(callbackifyOnRejected, rej, cb); });
      }

      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified,
                              getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports.callbackify = callbackify;
    });
    var util_1 = util.format;
    var util_2 = util.deprecate;
    var util_3 = util.debuglog;
    var util_4 = util.inspect;
    var util_5 = util.isArray;
    var util_6 = util.isBoolean;
    var util_7 = util.isNull;
    var util_8 = util.isNullOrUndefined;
    var util_9 = util.isNumber;
    var util_10 = util.isString;
    var util_11 = util.isSymbol;
    var util_12 = util.isUndefined;
    var util_13 = util.isRegExp;
    var util_14 = util.isObject;
    var util_15 = util.isDate;
    var util_16 = util.isError;
    var util_17 = util.isFunction;
    var util_18 = util.isPrimitive;
    var util_19 = util.isBuffer;
    var util_20 = util.log;
    var util_21 = util.inherits;
    var util_22 = util._extend;
    var util_23 = util.promisify;
    var util_24 = util.callbackify;

    function ProtocolError(message) {
        Error.call(this);
        this.message = message;
        this.name = 'ProtocolError';
    }
    util.inherits(ProtocolError, Error);

    function TypeError$1(message) {
        ProtocolError.call(this, message);
        this.message = message;
        this.name = 'TypeError';
    }

    util.inherits(TypeError$1, ProtocolError);

    function ConnectionError(message, condition, connection) {
        Error.call(this, message);
        this.message = message;
        this.name = 'ConnectionError';
        this.condition = condition;
        this.description = message;
        this.connection = connection;
    }

    util.inherits(ConnectionError, Error);

    ConnectionError.prototype.toJSON = function () {
        return {
            type: this.name,
            code: this.condition,
            message: this.description
        };
    };

    var errors = {
        ProtocolError: ProtocolError,
        TypeError: TypeError$1,
        ConnectionError: ConnectionError
    };

    var util$1 = {};

    util$1.allocate_buffer = function (size) {
        return buffer_1.alloc ? buffer_1.alloc(size) : new buffer_1(size);
    };

    util$1.generate_uuid = function () {
        return util$1.uuid_to_string(util$1.uuid4());
    };

    util$1.uuid4 = function () {
        var bytes = util$1.allocate_buffer(16);
        for (var i = 0; i < bytes.length; i++) {
            bytes[i] = Math.random()*255|0;
        }

        // From RFC4122, the version bits are set to 0100
        bytes[7] &= 0x0F;
        bytes[7] |= 0x40;

        // From RFC4122, the top two bits of byte 8 get set to 01
        bytes[8] &= 0x3F;
        bytes[8] |= 0x80;

        return bytes;
    };


    util$1.uuid_to_string = function (buffer) {
        if (buffer.length === 16) {
            var chunks = [buffer.slice(0, 4), buffer.slice(4, 6), buffer.slice(6, 8), buffer.slice(8, 10), buffer.slice(10, 16)];
            return chunks.map(function (b) { return b.toString('hex'); }).join('-');
        } else {
            throw new errors.TypeError('Not a UUID, expecting 16 byte buffer');
        }
    };

    var parse_uuid = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;

    util$1.string_to_uuid = function (uuid_string) {
        var parts = parse_uuid.exec(uuid_string.toLowerCase());
        if (parts) {
            return buffer_1.from(parts.slice(1).join(''), 'hex');
        } else {
            throw new errors.TypeError('Not a valid UUID string: ' + uuid_string);
        }
    };

    util$1.clone = function (o) {
        var copy = Object.create(o.prototype || {});
        var names = Object.getOwnPropertyNames(o);
        for (var i = 0; i < names.length; i++) {
            var key = names[i];
            copy[key] = o[key];
        }
        return copy;
    };

    util$1.and = function (f, g) {
        if (g === undefined) return f;
        return function (o) {
            return f(o) && g(o);
        };
    };

    util$1.is_sender = function (o) { return o.is_sender(); };
    util$1.is_receiver = function (o) { return o.is_receiver(); };
    util$1.sender_filter = function (filter) { return util$1.and(util$1.is_sender, filter); };
    util$1.receiver_filter = function (filter) { return util$1.and(util$1.is_receiver, filter); };

    util$1.is_defined = function (field) {
        return field !== undefined && field !== null;
    };

    var util_1$1 = util$1;

    var CAT_FIXED = 1;
    var CAT_VARIABLE = 2;
    var CAT_COMPOUND = 3;
    var CAT_ARRAY = 4;

    function Typed(type, value, code, descriptor) {
        this.type = type;
        this.value = value;
        if (code) {
            this.array_constructor = {'typecode':code};
            if (descriptor) {
                this.array_constructor.descriptor = descriptor;
            }
        }
    }

    Typed.prototype.toString = function() {
        return this.value ? this.value.toString() : null;
    };

    Typed.prototype.toLocaleString = function() {
        return this.value ? this.value.toLocaleString() : null;
    };

    Typed.prototype.valueOf = function() {
        return this.value;
    };

    Typed.prototype.toJSON = function() {
        return this.value && this.value.toJSON ? this.value.toJSON() : this.value;
    };

    function TypeDesc(name, typecode, props, empty_value) {
        this.name = name;
        this.typecode = typecode;
        var subcategory = typecode >>> 4;
        switch (subcategory) {
        case 0x4:
            this.width = 0;
            this.category = CAT_FIXED;
            break;
        case 0x5:
            this.width = 1;
            this.category = CAT_FIXED;
            break;
        case 0x6:
            this.width = 2;
            this.category = CAT_FIXED;
            break;
        case 0x7:
            this.width = 4;
            this.category = CAT_FIXED;
            break;
        case 0x8:
            this.width = 8;
            this.category = CAT_FIXED;
            break;
        case 0x9:
            this.width = 16;
            this.category = CAT_FIXED;
            break;
        case 0xA:
            this.width = 1;
            this.category = CAT_VARIABLE;
            break;
        case 0xB:
            this.width = 4;
            this.category = CAT_VARIABLE;
            break;
        case 0xC:
            this.width = 1;
            this.category = CAT_COMPOUND;
            break;
        case 0xD:
            this.width = 4;
            this.category = CAT_COMPOUND;
            break;
        case 0xE:
            this.width = 1;
            this.category = CAT_ARRAY;
            break;
        case 0xF:
            this.width = 4;
            this.category = CAT_ARRAY;
            break;
        default:
            //can't happen
            break;
        }

        if (props) {
            if (props.read) {
                this.read = props.read;
            }
            if (props.write) {
                this.write = props.write;
            }
            if (props.encoding) {
                this.encoding = props.encoding;
            }
        }

        var t = this;
        if (subcategory === 0x4) {
            // 'empty' types don't take a value
            this.create = function () {
                return new Typed(t, empty_value);
            };
        } else if (subcategory === 0xE || subcategory === 0xF) {
            this.create = function (v, code, descriptor) {
                return new Typed(t, v, code, descriptor);
            };
        } else {
            this.create = function (v) {
                return new Typed(t, v);
            };
        }
    }

    TypeDesc.prototype.toString = function () {
        return this.name + '#' + hex(this.typecode);
    };

    function hex(i) {
        return Number(i).toString(16);
    }

    var types = {'by_code':{}};
    Object.defineProperty(types, 'MAX_UINT', {value: 4294967295, writable: false, configurable: false});
    Object.defineProperty(types, 'MAX_USHORT', {value: 65535, writable: false, configurable: false});

    function define_type(name, typecode, annotations, empty_value) {
        var t = new TypeDesc(name, typecode, annotations, empty_value);
        t.create.typecode = t.typecode;//hack
        types.by_code[t.typecode] = t;
        types[name] = t.create;
    }

    function buffer_uint8_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readUInt8(offset); },
            'write': function (buffer, value, offset) { buffer.writeUInt8(value, offset); }
        };
    }

    function buffer_uint16be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readUInt16BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeUInt16BE(value, offset); }
        };
    }

    function buffer_uint32be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readUInt32BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeUInt32BE(value, offset); }
        };
    }

    function buffer_int8_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readInt8(offset); },
            'write': function (buffer, value, offset) { buffer.writeInt8(value, offset); }
        };
    }

    function buffer_int16be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readInt16BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeInt16BE(value, offset); }
        };
    }

    function buffer_int32be_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readInt32BE(offset); },
            'write': function (buffer, value, offset) { buffer.writeInt32BE(value, offset); }
        };
    }

    function buffer_floatbe_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readFloatBE(offset); },
            'write': function (buffer, value, offset) { buffer.writeFloatBE(value, offset); }
        };
    }

    function buffer_doublebe_ops() {
        return {
            'read': function (buffer, offset) { return buffer.readDoubleBE(offset); },
            'write': function (buffer, value, offset) { buffer.writeDoubleBE(value, offset); }
        };
    }

    var MAX_UINT = 4294967296; // 2^32
    var MIN_INT = -2147483647;
    function write_ulong(buffer, value, offset) {
        if ((typeof value) === 'number' || value instanceof Number) {
            var hi = Math.floor(value / MAX_UINT);
            var lo = value % MAX_UINT;
            buffer.writeUInt32BE(hi, offset);
            buffer.writeUInt32BE(lo, offset + 4);
        } else {
            value.copy(buffer, offset);
        }
    }

    function read_ulong(buffer, offset) {
        var hi = buffer.readUInt32BE(offset);
        var lo = buffer.readUInt32BE(offset + 4);
        if (hi < 2097153) {
            return hi * MAX_UINT + lo;
        } else {
            return buffer.slice(offset, offset + 8);
        }
    }

    function write_long(buffer, value, offset) {
        if ((typeof value) === 'number' || value instanceof Number) {
            var abs = Math.abs(value);
            var hi = Math.floor(abs / MAX_UINT);
            var lo = abs % MAX_UINT;
            buffer.writeInt32BE(hi, offset);
            buffer.writeUInt32BE(lo, offset + 4);
            if (value < 0) {
                var carry = 1;
                for (var i = 0; i < 8; i++) {
                    var index = offset + (7 - i);
                    var v = (buffer[index] ^ 0xFF) + carry;
                    buffer[index] = v & 0xFF;
                    carry = v >> 8;
                }
            }
        } else {
            value.copy(buffer, offset);
        }
    }

    function read_long(buffer, offset) {
        var hi = buffer.readInt32BE(offset);
        var lo = buffer.readUInt32BE(offset + 4);
        if (hi < 2097153 && hi > -2097153) {
            return hi * MAX_UINT + lo;
        } else {
            return buffer.slice(offset, offset + 8);
        }
    }

    define_type('Null', 0x40, undefined, null);
    define_type('Boolean', 0x56, buffer_uint8_ops());
    define_type('True', 0x41, undefined, true);
    define_type('False', 0x42, undefined, false);
    define_type('Ubyte', 0x50, buffer_uint8_ops());
    define_type('Ushort', 0x60, buffer_uint16be_ops());
    define_type('Uint', 0x70, buffer_uint32be_ops());
    define_type('SmallUint', 0x52, buffer_uint8_ops());
    define_type('Uint0', 0x43, undefined, 0);
    define_type('Ulong', 0x80, {'write':write_ulong, 'read':read_ulong});
    define_type('SmallUlong', 0x53, buffer_uint8_ops());
    define_type('Ulong0', 0x44, undefined, 0);
    define_type('Byte', 0x51, buffer_int8_ops());
    define_type('Short', 0x61, buffer_int16be_ops());
    define_type('Int', 0x71, buffer_int32be_ops());
    define_type('SmallInt', 0x54, buffer_int8_ops());
    define_type('Long', 0x81, {'write':write_long, 'read':read_long});
    define_type('SmallLong', 0x55, buffer_int8_ops());
    define_type('Float', 0x72, buffer_floatbe_ops());
    define_type('Double', 0x82, buffer_doublebe_ops());
    define_type('Decimal32', 0x74);
    define_type('Decimal64', 0x84);
    define_type('Decimal128', 0x94);
    define_type('CharUTF32', 0x73, buffer_uint32be_ops());
    define_type('Timestamp', 0x83, {'write':write_long, 'read':read_long});//TODO: convert to/from Date
    define_type('Uuid', 0x98);//TODO: convert to/from stringified form?
    define_type('Vbin8', 0xa0);
    define_type('Vbin32', 0xb0);
    define_type('Str8', 0xa1, {'encoding':'utf8'});
    define_type('Str32', 0xb1, {'encoding':'utf8'});
    define_type('Sym8', 0xa3, {'encoding':'ascii'});
    define_type('Sym32', 0xb3, {'encoding':'ascii'});
    define_type('List0', 0x45, undefined, []);
    define_type('List8', 0xc0);
    define_type('List32', 0xd0);
    define_type('Map8', 0xc1);
    define_type('Map32', 0xd1);
    define_type('Array8', 0xe0);
    define_type('Array32', 0xf0);

    function is_one_of(o, typelist) {
        for (var i = 0; i < typelist.length; i++) {
            if (o.type.typecode === typelist[i].typecode) return true;
        }
        return false;
    }
    function buffer_zero(b, len, neg) {
        for (var i = 0; i < len && i < b.length; i++) {
            if (b[i] !== (neg ? 0xff : 0)) return false;
        }
        return true;
    }
    types.is_ulong = function(o) {
        return is_one_of(o, [types.Ulong, types.Ulong0, types.SmallUlong]);
    };
    types.is_string = function(o) {
        return is_one_of(o, [types.Str8, types.Str32]);
    };
    types.is_symbol = function(o) {
        return is_one_of(o, [types.Sym8, types.Sym32]);
    };
    types.is_list = function(o) {
        return is_one_of(o, [types.List0, types.List8, types.List32]);
    };
    types.is_map = function(o) {
        return is_one_of(o, [types.Map8, types.Map32]);
    };

    types.wrap_boolean = function(v) {
        return v ? types.True() : types.False();
    };
    types.wrap_ulong = function(l) {
        if (buffer_1.isBuffer(l)) {
            if (buffer_zero(l, 8, false)) return types.Ulong0();
            return buffer_zero(l, 7, false) ? types.SmallUlong(l[7]) : types.Ulong(l);
        } else {
            if (l === 0) return types.Ulong0();
            else return l > 255 ? types.Ulong(l) : types.SmallUlong(l);
        }
    };
    types.wrap_uint = function(l) {
        if (l === 0) return types.Uint0();
        else return l > 255 ? types.Uint(l) : types.SmallUint(l);
    };
    types.wrap_ushort = function(l) {
        return types.Ushort(l);
    };
    types.wrap_ubyte = function(l) {
        return types.Ubyte(l);
    };
    types.wrap_long = function(l) {
        if (buffer_1.isBuffer(l)) {
            var negFlag = (l[0] & 0x80) !== 0;
            if (buffer_zero(l, 7, negFlag) && (l[7] & 0x80) === (negFlag ? 0x80 : 0)) {
                return types.SmallLong(negFlag ? -((l[7] ^ 0xff) + 1) : l[7]);
            }
            return types.Long(l);
        } else {
            return l > 127 || l < -128 ? types.Long(l) : types.SmallLong(l);
        }
    };
    types.wrap_int = function(l) {
        return l > 127 || l < -128 ? types.Int(l) : types.SmallInt(l);
    };
    types.wrap_short = function(l) {
        return types.Short(l);
    };
    types.wrap_byte = function(l) {
        return types.Byte(l);
    };
    types.wrap_float = function(l) {
        return types.Float(l);
    };
    types.wrap_double = function(l) {
        return types.Double(l);
    };
    types.wrap_timestamp = function(l) {
        return types.Timestamp(l);
    };
    types.wrap_char = function(v) {
        return types.CharUTF32(v);
    };
    types.wrap_uuid = function(v) {
        return types.Uuid(v);
    };
    types.wrap_binary = function (s) {
        return s.length > 255 ? types.Vbin32(s) : types.Vbin8(s);
    };
    types.wrap_string = function (s) {
        return buffer_1.from(s).length > 255 ? types.Str32(s) : types.Str8(s);
    };
    types.wrap_symbol = function (s) {
        return buffer_1.from(s).length > 255 ? types.Sym32(s) : types.Sym8(s);
    };
    types.wrap_list = function(l) {
        if (l.length === 0) return types.List0();
        var items = l.map(types.wrap);
        return types.List32(items);
    };
    types.wrap_map = function(m, key_wrapper) {
        var items = [];
        for (var k in m) {
            items.push(key_wrapper ? key_wrapper(k) : types.wrap(k));
            items.push(types.wrap(m[k]));
        }
        return types.Map32(items);
    };
    types.wrap_symbolic_map = function(m) {
        return types.wrap_map(m, types.wrap_symbol);
    };
    types.wrap_array = function(l, code, descriptors) {
        if (code) {
            return types.Array32(l, code, descriptors);
        } else {
            console.trace('An array must specify a type for its elements');
            throw new errors.TypeError('An array must specify a type for its elements');
        }
    };
    types.wrap = function(o) {
        var t = typeof o;
        if (t === 'string') {
            return types.wrap_string(o);
        } else if (t === 'boolean') {
            return o ? types.True() : types.False();
        } else if (t === 'number' || o instanceof Number) {
            if (isNaN(o)) {
                return types.Null();
            } else if (Math.floor(o) - o !== 0) {
                return types.Double(o);
            } else if (o > 0) {
                if (o < MAX_UINT) {
                    return types.wrap_uint(o);
                } else {
                    return types.wrap_ulong(o);
                }
            } else {
                if (o > MIN_INT) {
                    return types.wrap_int(o);
                } else {
                    return types.wrap_long(o);
                }
            }
        } else if (o instanceof Date) {
            return types.wrap_timestamp(o.getTime());
        } else if (o instanceof Typed) {
            return o;
        } else if (o instanceof buffer_1) {
            return types.wrap_binary(o);
        } else if (t === 'undefined' || o === null) {
            return types.Null();
        } else if (Array.isArray(o)) {
            return types.wrap_list(o);
        } else {
            return types.wrap_map(o);
        }
    };

    types.wrap_described = function(value, descriptor) {
        var result = types.wrap(value);
        if (descriptor) {
            if (typeof descriptor === 'string') {
                result = types.described(types.wrap_symbol(descriptor), result);
            } else if (typeof descriptor === 'number' || descriptor instanceof Number) {
                result = types.described(types.wrap_ulong(descriptor), result);
            }
        }
        return result;
    };

    types.wrap_message_id = function(o) {
        var t = typeof o;
        if (t === 'string') {
            return types.wrap_string(o);
        } else if (t === 'number' || o instanceof Number) {
            return types.wrap_ulong(o);
        } else if (buffer_1.isBuffer(o)) {
            return types.wrap_uuid(o);
        } else {
            //TODO handle uuids
            throw new errors.TypeError('invalid message id:' + o);
        }
    };

    /**
     * Converts the list of keys and values that comprise an AMQP encoded
     * map into a proper javascript map/object.
     */
    function mapify(elements) {
        var result = {};
        for (var i = 0; i+1 < elements.length;) {
            result[elements[i++]] = elements[i++];
        }
        return result;
    }

    var by_descriptor = {};

    types.unwrap_map_simple = function(o) {
        return mapify(o.value.map(function (i) { return types.unwrap(i, true); }));
    };

    types.unwrap = function(o, leave_described) {
        if (o instanceof Typed) {
            if (o.descriptor) {
                var c = by_descriptor[o.descriptor.value];
                if (c) {
                    return new c(o.value);
                } else if (leave_described) {
                    return o;
                }
            }
            var u = types.unwrap(o.value, true);
            return types.is_map(o) ? mapify(u) : u;
        } else if (Array.isArray(o)) {
            return o.map(function (i) { return types.unwrap(i, true); });
        } else {
            return o;
        }
    };

    /*
    types.described = function (descriptor, typedvalue) {
        var o = Object.create(typedvalue);
        if (descriptor.length) {
            o.descriptor = descriptor.shift();
            return types.described(descriptor, o);
        } else {
            o.descriptor = descriptor;
            return o;
        }
    };
    */
    types.described_nc = function (descriptor, o) {
        if (descriptor.length) {
            o.descriptor = descriptor.shift();
            return types.described(descriptor, o);
        } else {
            o.descriptor = descriptor;
            return o;
        }
    };
    types.described = types.described_nc;

    function get_type(code) {
        var type = types.by_code[code];
        if (!type) {
            throw new errors.TypeError('Unrecognised typecode: ' + hex(code));
        }
        return type;
    }

    types.Reader = function (buffer) {
        this.buffer = buffer;
        this.position = 0;
    };

    types.Reader.prototype.read_typecode = function () {
        return this.read_uint(1);
    };

    types.Reader.prototype.read_uint = function (width) {
        var current = this.position;
        this.position += width;
        if (width === 1) {
            return this.buffer.readUInt8(current);
        } else if (width === 2) {
            return this.buffer.readUInt16BE(current);
        } else if (width === 4) {
            return this.buffer.readUInt32BE(current);
        } else {
            throw new errors.TypeError('Unexpected width for uint ' + width);
        }
    };

    types.Reader.prototype.read_fixed_width = function (type) {
        var current = this.position;
        this.position += type.width;
        if (type.read) {
            return type.read(this.buffer, current);
        } else {
            return this.buffer.slice(current, this.position);
        }
    };

    types.Reader.prototype.read_variable_width = function (type) {
        var size = this.read_uint(type.width);
        var slice = this.read_bytes(size);
        return type.encoding ? slice.toString(type.encoding) : slice;
    };

    types.Reader.prototype.read = function () {
        var constructor = this.read_constructor();
        var value = this.read_value(get_type(constructor.typecode));
        return constructor.descriptor ? types.described_nc(constructor.descriptor, value) : value;
    };

    types.Reader.prototype.read_constructor = function () {
        var code = this.read_typecode();
        if (code === 0x00) {
            var d = [];
            d.push(this.read());
            var c = this.read_constructor();
            while (c.descriptor) {
                d.push(c.descriptor);
                c = this.read_constructor();
            }
            return {'typecode': c.typecode, 'descriptor':  d.length === 1 ? d[0] : d};
        } else {
            return {'typecode': code};
        }
    };

    types.Reader.prototype.read_value = function (type) {
        if (type.width === 0) {
            return type.create();
        } else if (type.category === CAT_FIXED) {
            return type.create(this.read_fixed_width(type));
        } else if (type.category === CAT_VARIABLE) {
            return type.create(this.read_variable_width(type));
        } else if (type.category === CAT_COMPOUND) {
            return this.read_compound(type);
        } else if (type.category === CAT_ARRAY) {
            return this.read_array(type);
        } else {
            throw new errors.TypeError('Invalid category for type: ' + type);
        }
    };

    types.Reader.prototype.read_array_items = function (n, type) {
        var items = [];
        while (items.length < n) {
            items.push(this.read_value(type));
        }
        return items;
    };

    types.Reader.prototype.read_n = function (n) {
        var items = new Array(n);
        for (var i = 0; i < n; i++) {
            items[i] = this.read();
        }
        return items;
    };

    types.Reader.prototype.read_size_count = function (width) {
        return {'size': this.read_uint(width), 'count': this.read_uint(width)};
    };

    types.Reader.prototype.read_compound = function (type) {
        var limits = this.read_size_count(type.width);
        return type.create(this.read_n(limits.count));
    };

    types.Reader.prototype.read_array = function (type) {
        var limits = this.read_size_count(type.width);
        var constructor = this.read_constructor();
        return type.create(this.read_array_items(limits.count, get_type(constructor.typecode)), constructor.typecode, constructor.descriptor);
    };

    types.Reader.prototype.toString = function () {
        var s = 'buffer@' + this.position;
        if (this.position) s += ': ';
        for (var i = this.position; i < this.buffer.length; i++) {
            if (i > 0) s+= ',';
            s += '0x' + Number(this.buffer[i]).toString(16);
        }
        return s;
    };

    types.Reader.prototype.reset = function () {
        this.position = 0;
    };

    types.Reader.prototype.skip = function (bytes) {
        this.position += bytes;
    };

    types.Reader.prototype.read_bytes = function (bytes) {
        var current = this.position;
        this.position += bytes;
        return this.buffer.slice(current, this.position);
    };

    types.Reader.prototype.remaining = function () {
        return this.buffer.length - this.position;
    };

    types.Writer = function (buffer) {
        this.buffer = buffer ? buffer : util_1$1.allocate_buffer(1024);
        this.position = 0;
    };

    types.Writer.prototype.toBuffer = function () {
        return this.buffer.slice(0, this.position);
    };

    function max(a, b) {
        return a > b ? a : b;
    }

    types.Writer.prototype.ensure = function (length) {
        if (this.buffer.length < length) {
            var bigger = util_1$1.allocate_buffer(max(this.buffer.length*2, length));
            this.buffer.copy(bigger);
            this.buffer = bigger;
        }
    };

    types.Writer.prototype.write_typecode = function (code) {
        this.write_uint(code, 1);
    };

    types.Writer.prototype.write_uint = function (value, width) {
        var current = this.position;
        this.ensure(this.position + width);
        this.position += width;
        if (width === 1) {
            return this.buffer.writeUInt8(value, current);
        } else if (width === 2) {
            return this.buffer.writeUInt16BE(value, current);
        } else if (width === 4) {
            return this.buffer.writeUInt32BE(value, current);
        } else {
            throw new errors.TypeError('Unexpected width for uint ' + width);
        }
    };


    types.Writer.prototype.write_fixed_width = function (type, value) {
        var current = this.position;
        this.ensure(this.position + type.width);
        this.position += type.width;
        if (type.write) {
            type.write(this.buffer, value, current);
        } else if (value.copy) {
            value.copy(this.buffer, current);
        } else {
            throw new errors.TypeError('Cannot handle write for ' + type);
        }
    };

    types.Writer.prototype.write_variable_width = function (type, value) {
        var source = type.encoding ? buffer_1.from(value, type.encoding) : buffer_1.from(value);//TODO: avoid creating new buffers
        this.write_uint(source.length, type.width);
        this.write_bytes(source);
    };

    types.Writer.prototype.write_bytes = function (source) {
        var current = this.position;
        this.ensure(this.position + source.length);
        this.position += source.length;
        source.copy(this.buffer, current);
    };

    types.Writer.prototype.write_constructor = function (typecode, descriptor) {
        if (descriptor) {
            this.write_typecode(0x00);
            this.write(descriptor);
        }
        this.write_typecode(typecode);
    };

    types.Writer.prototype.write = function (o) {
        if (o.type === undefined) {
            if (o.described) {
                this.write(o.described());
            } else {
                throw new errors.TypeError('Cannot write ' + JSON.stringify(o));
            }
        } else {
            this.write_constructor(o.type.typecode, o.descriptor);
            this.write_value(o.type, o.value, o.array_constructor);
        }
    };

    types.Writer.prototype.write_value = function (type, value, constructor/*for arrays only*/) {
        if (type.width === 0) {
            return;//nothing further to do
        } else if (type.category === CAT_FIXED) {
            this.write_fixed_width(type, value);
        } else if (type.category === CAT_VARIABLE) {
            this.write_variable_width(type, value);
        } else if (type.category === CAT_COMPOUND) {
            this.write_compound(type, value);
        } else if (type.category === CAT_ARRAY) {
            this.write_array(type, value, constructor);
        } else {
            throw new errors.TypeError('Invalid category ' + type.category + ' for type: ' + type);
        }
    };

    types.Writer.prototype.backfill_size = function (width, saved) {
        var gap = this.position - saved;
        this.position = saved;
        this.write_uint(gap - width, width);
        this.position += (gap - width);
    };

    types.Writer.prototype.write_compound = function (type, value) {
        var saved = this.position;
        this.position += type.width;//skip size field
        this.write_uint(value.length, type.width);//count field
        for (var i = 0; i < value.length; i++) {
            if (value[i] === undefined || value[i] === null) {
                this.write(types.Null());
            } else {
                this.write(value[i]);
            }
        }
        this.backfill_size(type.width, saved);
    };

    types.Writer.prototype.write_array = function (type, value, constructor) {
        var saved = this.position;
        this.position += type.width;//skip size field
        this.write_uint(value.length, type.width);//count field
        this.write_constructor(constructor.typecode, constructor.descriptor);
        var ctype = get_type(constructor.typecode);
        for (var i = 0; i < value.length; i++) {
            this.write_value(ctype, value[i]);
        }
        this.backfill_size(type.width, saved);
    };

    types.Writer.prototype.toString = function () {
        var s = 'buffer@' + this.position;
        if (this.position) s += ': ';
        for (var i = 0; i < this.position; i++) {
            if (i > 0) s+= ',';
            s += ('00' + Number(this.buffer[i]).toString(16)).slice(-2);
        }
        return s;
    };

    types.Writer.prototype.skip = function (bytes) {
        this.ensure(this.position + bytes);
        this.position += bytes;
    };

    types.Writer.prototype.clear = function () {
        this.buffer.fill(0x00);
        this.position = 0;
    };

    types.Writer.prototype.remaining = function () {
        return this.buffer.length - this.position;
    };


    function get_constructor(typename) {
        if (typename === 'symbol') {
            return {typecode:types.Sym8.typecode};
        }
        throw new errors.TypeError('TODO: Array of type ' + typename + ' not yet supported');
    }

    function wrap_field(definition, instance) {
        if (instance !== undefined && instance !== null) {
            if (Array.isArray(instance)) {
                if (!definition.multiple) {
                    throw new errors.TypeError('Field ' + definition.name + ' does not support multiple values, got ' + JSON.stringify(instance));
                }
                var constructor = get_constructor(definition.type);
                return types.wrap_array(instance, constructor.typecode, constructor.descriptor);
            } else if (definition.type === '*') {
                return instance;
            } else {
                var wrapper = types['wrap_' + definition.type];
                if (wrapper) {
                    return wrapper(instance);
                } else {
                    throw new errors.TypeError('No wrapper for field ' + definition.name + ' of type ' + definition.type);
                }
            }
        } else if (definition.mandatory) {
            throw new errors.TypeError('Field ' + definition.name + ' is mandatory');
        } else {
            return types.Null();
        }
    }

    function get_accessors(index, field_definition) {
        var getter;
        if (field_definition.type === '*') {
            getter = function() { return this.value[index]; };
        } else {
            getter = function() { return types.unwrap(this.value[index]); };
        }
        var setter = function(o) { this.value[index] = wrap_field(field_definition, o); };
        return {'get': getter, 'set': setter, 'enumerable':true, 'configurable':false};
    }

    types.define_composite = function(def) {
        var c = function(fields) {
            this.value = fields ? fields : [];
        };
        c.descriptor = {
            numeric: def.code,
            symbolic: 'amqp:' + def.name + ':list'
        };
        c.prototype.dispatch = function (target, frame) {
            target['on_' + def.name](frame);
        };
        //c.prototype.descriptor = c.descriptor.numeric;
        //c.prototype = Object.create(types.List8.prototype);
        for (var i = 0; i < def.fields.length; i++) {
            var f = def.fields[i];
            Object.defineProperty(c.prototype, f.name, get_accessors(i, f));
        }
        c.toString = function() {
            return def.name + '#' + Number(def.code).toString(16);
        };
        c.prototype.toJSON = function() {
            var o = {};
            for (var f in this) {
                if (f !== 'value' && this[f]) {
                    o[f] = this[f];
                }
            }
            return o;
        };
        c.create = function(fields) {
            var o = new c;
            for (var f in fields) {
                o[f] = fields[f];
            }
            return o;
        };
        c.prototype.described = function() {
            return types.described_nc(types.wrap_ulong(c.descriptor.numeric), types.wrap_list(this.value));
        };
        return c;
    };

    function add_type(def) {
        var c = types.define_composite(def);
        types['wrap_' + def.name] = function (fields) {
            return c.create(fields).described();
        };
        by_descriptor[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor[c.descriptor.symbolic] = c;
    }

    add_type({
        name: 'error',
        code: 0x1d,
        fields: [
            {name:'condition', type:'symbol', mandatory:true},
            {name:'description', type:'string'},
            {name:'info', type:'map'}
        ]
    });

    var types_1 = types;

    var frames = {};
    var by_descriptor$1 = {};

    frames.read_header = function(buffer) {
        var offset = 4;
        var header = {};
        var name = buffer.toString('ascii', 0, offset);
        if (name !== 'AMQP') {
            throw new errors.ProtocolError('Invalid protocol header for AMQP ' + name);
        }
        header.protocol_id = buffer.readUInt8(offset++);
        header.major = buffer.readUInt8(offset++);
        header.minor = buffer.readUInt8(offset++);
        header.revision = buffer.readUInt8(offset++);
        //the protocol header is interpreted in different ways for
        //different versions(!); check some special cases to give clearer
        //error messages:
        if (header.protocol_id === 0 && header.major === 0 && header.minor === 9 && header.revision === 1) {
            throw new errors.ProtocolError('Unsupported AMQP version: 0-9-1');
        }
        if (header.protocol_id === 1 && header.major === 1 && header.minor === 0 && header.revision === 10) {
            throw new errors.ProtocolError('Unsupported AMQP version: 0-10');
        }
        if (header.major !== 1 || header.minor !== 0) {
            throw new errors.ProtocolError('Unsupported AMQP version: ' + JSON.stringify(header));
        }
        return header;
    };
    frames.write_header = function(buffer, header) {
        var offset = 4;
        buffer.write('AMQP', 0, offset, 'ascii');
        buffer.writeUInt8(header.protocol_id, offset++);
        buffer.writeUInt8(header.major, offset++);
        buffer.writeUInt8(header.minor, offset++);
        buffer.writeUInt8(header.revision, offset++);
        return 8;
    };
    //todo: define enumeration for frame types
    frames.TYPE_AMQP = 0x00;
    frames.TYPE_SASL = 0x01;

    frames.read_frame = function(buffer) {
        var reader = new types_1.Reader(buffer);
        var frame = {};
        frame.size = reader.read_uint(4);
        if (reader.remaining < frame.size) {
            return null;
        }
        var doff = reader.read_uint(1);
        if (doff < 2) {
            throw new errors.ProtocolError('Invalid data offset, must be at least 2 was ' + doff);
        }
        frame.type = reader.read_uint(1);
        if (frame.type === frames.TYPE_AMQP) {
            frame.channel = reader.read_uint(2);
        } else if (frame.type === frames.TYPE_SASL) {
            reader.skip(2);
            frame.channel = 0;
        } else {
            throw new errors.ProtocolError('Unknown frame type ' + frame.type);
        }
        if (doff > 1) {
            //ignore any extended header
            reader.skip(doff * 4 - 8);
        }
        if (reader.remaining()) {
            frame.performative = reader.read();
            var c = by_descriptor$1[frame.performative.descriptor.value];
            if (c) {
                frame.performative = new c(frame.performative.value);
            }
            if (reader.remaining()) {
                frame.payload = reader.read_bytes(reader.remaining());
            }
        }
        return frame;
    };

    frames.write_frame = function(frame) {
        var writer = new types_1.Writer();
        writer.skip(4);//skip size until we know how much we have written
        writer.write_uint(2, 1);//doff
        writer.write_uint(frame.type, 1);
        if (frame.type === frames.TYPE_AMQP) {
            writer.write_uint(frame.channel, 2);
        } else if (frame.type === frames.TYPE_SASL) {
            writer.write_uint(0, 2);
        } else {
            throw new errors.ProtocolError('Unknown frame type ' + frame.type);
        }
        if (frame.performative) {
            writer.write(frame.performative);
            if (frame.payload) {
                writer.write_bytes(frame.payload);
            }
        }
        var buffer = writer.toBuffer();
        buffer.writeUInt32BE(buffer.length, 0);//fill in the size
        return buffer;
    };

    frames.amqp_frame = function(channel, performative, payload) {
        return {'channel': channel || 0, 'type': frames.TYPE_AMQP, 'performative': performative, 'payload': payload};
    };
    frames.sasl_frame = function(performative) {
        return {'channel': 0, 'type': frames.TYPE_SASL, 'performative': performative};
    };

    function define_frame(type, def) {
        var c = types_1.define_composite(def);
        frames[def.name] = c.create;
        by_descriptor$1[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor$1[c.descriptor.symbolic] = c;
    }

    var open = {
        name: 'open',
        code: 0x10,
        fields: [
            {name: 'container_id', type: 'string', mandatory: true},
            {name: 'hostname', type: 'string'},
            {name: 'max_frame_size', type: 'uint', default_value: 4294967295},
            {name: 'channel_max', type: 'ushort', default_value: 65535},
            {name: 'idle_time_out', type: 'uint'},
            {name: 'outgoing_locales', type: 'symbol', multiple: true},
            {name: 'incoming_locales', type: 'symbol', multiple: true},
            {name: 'offered_capabilities', type: 'symbol', multiple: true},
            {name: 'desired_capabilities', type: 'symbol', multiple: true},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var begin = {
        name: 'begin',
        code: 0x11,
        fields:[
            {name: 'remote_channel', type: 'ushort'},
            {name: 'next_outgoing_id', type: 'uint', mandatory: true},
            {name: 'incoming_window', type: 'uint', mandatory: true},
            {name: 'outgoing_window', type: 'uint', mandatory: true},
            {name: 'handle_max', type: 'uint', default_value: '4294967295'},
            {name: 'offered_capabilities', type: 'symbol', multiple: true},
            {name: 'desired_capabilities', type: 'symbol', multiple: true},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var attach = {
        name: 'attach',
        code: 0x12,
        fields:[
            {name: 'name', type: 'string', mandatory: true},
            {name: 'handle', type: 'uint', mandatory: true},
            {name: 'role', type: 'boolean', mandatory: true},
            {name: 'snd_settle_mode', type: 'ubyte', default_value: 2},
            {name: 'rcv_settle_mode', type: 'ubyte', default_value: 0},
            {name: 'source', type: '*'},
            {name: 'target', type: '*'},
            {name: 'unsettled', type: 'map'},
            {name: 'incomplete_unsettled', type: 'boolean', default_value: false},
            {name: 'initial_delivery_count', type: 'uint'},
            {name: 'max_message_size', type: 'ulong'},
            {name: 'offered_capabilities', type: 'symbol', multiple: true},
            {name: 'desired_capabilities', type: 'symbol', multiple: true},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var flow = {
        name: 'flow',
        code: 0x13,
        fields:[
            {name: 'next_incoming_id', type: 'uint'},
            {name: 'incoming_window', type: 'uint', mandatory: true},
            {name: 'next_outgoing_id', type: 'uint', mandatory: true},
            {name: 'outgoing_window', type: 'uint', mandatory: true},
            {name: 'handle', type: 'uint'},
            {name: 'delivery_count', type: 'uint'},
            {name: 'link_credit', type: 'uint'},
            {name: 'available', type: 'uint'},
            {name: 'drain', type: 'boolean', default_value: false},
            {name: 'echo', type: 'boolean', default_value: false},
            {name: 'properties', type: 'symbolic_map'}
        ]
    };

    var transfer = {
        name: 'transfer',
        code: 0x14,
        fields:[
            {name: 'handle', type: 'uint', mandatory: true},
            {name: 'delivery_id', type: 'uint'},
            {name: 'delivery_tag', type: 'binary'},
            {name: 'message_format', type: 'uint'},
            {name: 'settled', type: 'boolean'},
            {name: 'more', type: 'boolean', default_value: false},
            {name: 'rcv_settle_mode', type: 'ubyte'},
            {name: 'state', type: 'delivery_state'},
            {name: 'resume', type: 'boolean', default_value: false},
            {name: 'aborted', type: 'boolean', default_value: false},
            {name: 'batchable', type: 'boolean', default_value: false}
        ]
    };

    var disposition = {
        name: 'disposition',
        code: 0x15,
        fields:[
            {name: 'role', type: 'boolean', mandatory: true},
            {name: 'first', type: 'uint', mandatory: true},
            {name: 'last', type: 'uint'},
            {name: 'settled', type: 'boolean', default_value: false},
            {name: 'state', type: '*'},
            {name: 'batchable', type: 'boolean', default_value: false}
        ]
    };

    var detach = {
        name: 'detach',
        code: 0x16,
        fields: [
            {name: 'handle', type: 'uint', mandatory: true},
            {name: 'closed', type: 'boolean', default_value: false},
            {name: 'error', type: 'error'}
        ]
    };

    var end = {
        name: 'end',
        code: 0x17,
        fields: [
            {name: 'error', type: 'error'}
        ]
    };

    var close = {
        name: 'close',
        code: 0x18,
        fields: [
            {name: 'error', type: 'error'}
        ]
    };

    define_frame(frames.TYPE_AMQP, open);
    define_frame(frames.TYPE_AMQP, begin);
    define_frame(frames.TYPE_AMQP, attach);
    define_frame(frames.TYPE_AMQP, flow);
    define_frame(frames.TYPE_AMQP, transfer);
    define_frame(frames.TYPE_AMQP, disposition);
    define_frame(frames.TYPE_AMQP, detach);
    define_frame(frames.TYPE_AMQP, end);
    define_frame(frames.TYPE_AMQP, close);

    var sasl_mechanisms = {
        name: 'sasl_mechanisms',
        code: 0x40,
        fields: [
            {name: 'sasl_server_mechanisms', type: 'symbol', multiple: true, mandatory: true}
        ]
    };

    var sasl_init = {
        name: 'sasl_init',
        code: 0x41,
        fields: [
            {name: 'mechanism', type: 'symbol', mandatory: true},
            {name: 'initial_response', type: 'binary'},
            {name: 'hostname', type: 'string'}
        ]
    };

    var sasl_challenge = {
        name: 'sasl_challenge',
        code: 0x42,
        fields: [
            {name: 'challenge', type: 'binary', mandatory: true}
        ]
    };

    var sasl_response = {
        name: 'sasl_response',
        code: 0x43,
        fields: [
            {name: 'response', type: 'binary', mandatory: true}
        ]
    };

    var sasl_outcome = {
        name: 'sasl_outcome',
        code: 0x44,
        fields: [
            {name: 'code', type: 'ubyte', mandatory: true},
            {name: 'additional_data', type: 'binary'}
        ]
    };

    define_frame(frames.TYPE_SASL, sasl_mechanisms);
    define_frame(frames.TYPE_SASL, sasl_init);
    define_frame(frames.TYPE_SASL, sasl_challenge);
    define_frame(frames.TYPE_SASL, sasl_response);
    define_frame(frames.TYPE_SASL, sasl_outcome);

    var frames_1 = frames;

    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = ms;
      Object.keys(env).forEach(function (key) {
        createDebug[key] = env[key];
      });
      /**
      * Active `debug` instances.
      */

      createDebug.instances = [];
      /**
      * The currently active debug mode names, and names to skip.
      */

      createDebug.names = [];
      createDebug.skips = [];
      /**
      * Map of special "%n" handling functions, for the debug "format" argument.
      *
      * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
      */

      createDebug.formatters = {};
      /**
      * Selects a color for a debug namespace
      * @param {String} namespace The namespace string for the for the debug instance to be colored
      * @return {Number|String} An ANSI color code for the given namespace
      * @api private
      */

      function selectColor(namespace) {
        var hash = 0;

        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0; // Convert to 32bit integer
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }

      createDebug.selectColor = selectColor;
      /**
      * Create a debugger with the given `namespace`.
      *
      * @param {String} namespace
      * @return {Function}
      * @api public
      */

      function createDebug(namespace) {
        var prevTime;

        function debug() {
          // Disabled?
          if (!debug.enabled) {
            return;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var self = debug; // Set `diff` timestamp

          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);

          if (typeof args[0] !== 'string') {
            // Anything else let's inspect with %O
            args.unshift('%O');
          } // Apply any `formatters` transformations


          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
            // If we encounter an escaped % then don't increase the array index
            if (match === '%%') {
              return match;
            }

            index++;
            var formatter = createDebug.formatters[format];

            if (typeof formatter === 'function') {
              var val = args[index];
              match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

              args.splice(index, 1);
              index--;
            }

            return match;
          }); // Apply env-specific formatting (colors, etc.)

          createDebug.formatArgs.call(self, args);
          var logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend; // Debug.formatArgs = formatArgs;
        // debug.rawLog = rawLog;
        // env-specific initialization logic for debug instances

        if (typeof createDebug.init === 'function') {
          createDebug.init(debug);
        }

        createDebug.instances.push(debug);
        return debug;
      }

      function destroy() {
        var index = createDebug.instances.indexOf(this);

        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }

        return false;
      }

      function extend(namespace, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      }
      /**
      * Enables a debug mode by namespaces. This can include modes
      * separated by a colon and wildcards.
      *
      * @param {String} namespaces
      * @api public
      */


      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) {
            // ignore empty strings
            continue;
          }

          namespaces = split[i].replace(/\*/g, '.*?');

          if (namespaces[0] === '-') {
            createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            createDebug.names.push(new RegExp('^' + namespaces + '$'));
          }
        }

        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      /**
      * Disable debug output.
      *
      * @api public
      */


      function disable() {
        createDebug.enable('');
      }
      /**
      * Returns true if the given mode name is enabled, false otherwise.
      *
      * @param {String} name
      * @return {Boolean}
      * @api public
      */


      function enabled(name) {
        if (name[name.length - 1] === '*') {
          return true;
        }

        var i;
        var len;

        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }

        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }

        return false;
      }
      /**
      * Coerce `val`.
      *
      * @param {Mixed} val
      * @return {Mixed}
      * @api private
      */


      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }

        return val;
      }

      createDebug.enable(createDebug.load());
      return createDebug;
    }

    var common = setup;

    var browser$1 = createCommonjsModule(function (module, exports) {

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    // eslint-disable-next-line complexity

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      } // Internet Explorer and Edge do not support colors.


      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      } // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */


    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */


    function log() {
      var _console;

      // This hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */


    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */


    function load() {
      var r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {} // Swallow
      // XXX (@Qix-) should we be logging these?
      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


      if (!r && typeof browser !== 'undefined' && 'env' in browser) {
        r = browser.env.DEBUG;
      }

      return r;
    }
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */


    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    module.exports = common(exports);
    var formatters = module.exports.formatters;
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
    });
    var browser_1 = browser$1.log;
    var browser_2 = browser$1.formatArgs;
    var browser_3 = browser$1.save;
    var browser_4 = browser$1.load;
    var browser_5 = browser$1.useColors;
    var browser_6 = browser$1.storage;
    var browser_7 = browser$1.colors;

    if (browser$1.formatters) {
        browser$1.formatters.h = function (v) {
            return v.toString('hex');
        };
    }

    var log = {
        'config' : browser$1('rhea:config'),
        'frames' : browser$1('rhea:frames'),
        'raw' : browser$1('rhea:raw'),
        'reconnect' : browser$1('rhea:reconnect'),
        'events' : browser$1('rhea:events'),
        'message' : browser$1('rhea:message'),
        'flow' : browser$1('rhea:flow'),
        'io' : browser$1('rhea:io')
    };

    var Transport = function (identifier, protocol_id, frame_type, handler) {
        this.identifier = identifier;
        this.protocol_id = protocol_id;
        this.frame_type = frame_type;
        this.handler = handler;
        this.pending = [];
        this.header_sent = undefined;
        this.header_received = undefined;
        this.write_complete = false;
        this.read_complete = false;
    };

    Transport.prototype.has_writes_pending = function () {
        return this.pending.length > 0 || !this.header_sent;
    };

    Transport.prototype.encode = function (frame) {
        this.pending.push(frame);
    };

    Transport.prototype.write = function (socket) {
        if (!this.header_sent) {
            var buffer = util_1$1.allocate_buffer(8);
            var header = {protocol_id:this.protocol_id, major:1, minor:0, revision:0};
            log.frames('[%s] -> %o', this.identifier, header);
            frames_1.write_header(buffer, header);
            socket.write(buffer);
            this.header_sent = header;
        }
        for (var i = 0; i < this.pending.length; i++) {
            var frame = this.pending[i];
            var buffer = frames_1.write_frame(frame);
            socket.write(buffer);
            if (frame.performative) {
                log.frames('[%s]:%s -> %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');
            } else {
                log.frames('[%s]:%s -> empty', this.identifier, frame.channel);
            }
            log.raw('[%s] SENT: %d %h', this.identifier, buffer.length, buffer);
        }
        this.pending = [];
    };

    Transport.prototype.read = function (buffer) {
        var offset = 0;
        if (!this.header_received) {
            if (buffer.length < 8) {
                return offset;
            } else {
                this.header_received = frames_1.read_header(buffer);
                log.frames('[%s] <- %o', this.identifier, this.header_received);
                if (this.header_received.protocol_id !== this.protocol_id) {
                    if (this.protocol_id === 3 && this.header_received.protocol_id === 0) {
                        throw new errors.ProtocolError('Expecting SASL layer');
                    } else if (this.protocol_id === 0 && this.header_received.protocol_id === 3) {
                        throw new errors.ProtocolError('SASL layer not enabled');
                    } else {
                        throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id + ' expecting: ' + this.protocol_id);
                    }
                }
                offset = 8;
            }
        }
        while (offset < (buffer.length - 4) && !this.read_complete) {
            var frame_size = buffer.readUInt32BE(offset);
            log.io('[%s] got frame of size %d', this.identifier, frame_size);
            if (buffer.length < offset + frame_size) {
                log.io('[%s] incomplete frame; have only %d of %d', this.identifier, (buffer.length - offset), frame_size);
                //don't have enough data for a full frame yet
                break;
            } else {
                var slice = buffer.slice(offset, offset + frame_size);
                log.raw('[%s] RECV: %d %h', this.identifier, slice.length, slice);
                var frame = frames_1.read_frame(slice);
                if (frame.performative) {
                    log.frames('[%s]:%s <- %s %j', this.identifier, frame.channel, frame.performative.constructor, frame.performative, frame.payload || '');
                } else {
                    log.frames('[%s]:%s <- empty', this.identifier, frame.channel);

                }
                if (frame.type !== this.frame_type) {
                    throw new errors.ProtocolError('Invalid frame type: ' + frame.type);
                }
                offset += frame_size;
                if (frame.performative) {
                    frame.performative.dispatch(this.handler, frame);
                }
            }
        }
        return offset;
    };

    var transport = Transport;

    var sasl_codes = {
        'OK':0,
        'AUTH':1,
        'SYS':2,
        'SYS_PERM':3,
        'SYS_TEMP':4,
    };

    var SASL_PROTOCOL_ID = 0x03;

    function extract(buffer) {
        var results = [];
        var start = 0;
        var i = 0;
        while (i < buffer.length) {
            if (buffer[i] === 0x00) {
                if (i > start) results.push(buffer.toString('utf8', start, i));
                else results.push(null);
                start = ++i;
            } else {
                ++i;
            }
        }
        if (i > start) results.push(buffer.toString('utf8', start, i));
        else results.push(null);
        return results;
    }

    var PlainServer = function(callback) {
        this.callback = callback;
        this.outcome = undefined;
        this.username = undefined;
    };

    PlainServer.prototype.start = function(response, hostname) {
        var fields = extract(response);
        if (fields.length !== 3) {
            this.connection.sasl_failed('Unexpected response in PLAIN, got ' + fields.length + ' fields, expected 3');
        }
        var self = this;
        return Promise.resolve(this.callback(fields[1], fields[2], hostname))
            .then(function (result) {
                if (result) {
                    self.outcome = true;
                    self.username = fields[1];
                } else {
                    self.outcome = false;
                }
            });
    };

    var PlainClient = function(username, password) {
        this.username = username;
        this.password = password;
    };

    PlainClient.prototype.start = function(callback) {
        var response = util_1$1.allocate_buffer(1 + this.username.length + 1 + this.password.length);
        response.writeUInt8(0, 0);
        response.write(this.username, 1);
        response.writeUInt8(0, 1 + this.username.length);
        response.write(this.password, 1 + this.username.length + 1);
        callback(undefined, response);
    };

    var AnonymousServer = function() {
        this.outcome = undefined;
        this.username = undefined;
    };

    AnonymousServer.prototype.start = function(response) {
        this.outcome = true;
        this.username = response ? response.toString('utf8') : 'anonymous';
    };

    var AnonymousClient = function(name) {
        this.username = name ? name : 'anonymous';
    };

    AnonymousClient.prototype.start = function(callback) {
        var response = util_1$1.allocate_buffer(1 + this.username.length);
        response.writeUInt8(0, 0);
        response.write(this.username, 1);
        callback(undefined, response);
    };

    var ExternalServer = function() {
        this.outcome = undefined;
        this.username = undefined;
    };

    ExternalServer.prototype.start = function() {
        this.outcome = true;
    };

    var ExternalClient = function() {
        this.username = undefined;
    };

    ExternalClient.prototype.start = function(callback) {
        callback(undefined, '');
    };

    ExternalClient.prototype.step = function(callback) {
        callback(undefined, '');
    };

    var XOAuth2Client = function(username, token) {
        this.username = username;
        this.token = token;
    };

    XOAuth2Client.prototype.start = function(callback) {
        var response = util_1$1.allocate_buffer(this.username.length + this.token.length + 5 + 12 + 3);
        var count = 0;
        response.write('user=', count);
        count += 5;
        response.write(this.username, count);
        count += this.username.length;
        response.writeUInt8(1, count);
        count += 1;
        response.write('auth=Bearer ', count);
        count += 12;
        response.write(this.token, count);
        count += this.token.length;
        response.writeUInt8(1, count);
        count += 1;
        response.writeUInt8(1, count);
        count += 1;
        callback(undefined, response);
    };

    /**
     * The mechanisms argument is a map of mechanism names to factory
     * functions for objects that implement that mechanism.
     */
    var SaslServer = function (connection, mechanisms) {
        this.connection = connection;
        this.transport = new transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames_1.TYPE_SASL, this);
        this.next = connection.amqp_transport;
        this.mechanisms = mechanisms;
        this.mechanism = undefined;
        this.outcome = undefined;
        this.username = undefined;
        var mechlist = Object.getOwnPropertyNames(mechanisms);
        this.transport.encode(frames_1.sasl_frame(frames_1.sasl_mechanisms({sasl_server_mechanisms:mechlist})));
    };

    SaslServer.prototype.do_step = function (challenge) {
        if (this.mechanism.outcome === undefined) {
            this.transport.encode(frames_1.sasl_frame(frames_1.sasl_challenge({'challenge':challenge})));
            this.connection.output();
        } else {
            this.outcome = this.mechanism.outcome ? sasl_codes.OK : sasl_codes.AUTH;
            var frame = frames_1.sasl_frame(frames_1.sasl_outcome({code: this.outcome}));
            this.transport.encode(frame);
            this.connection.output();
            if (this.outcome === sasl_codes.OK) {
                this.username = this.mechanism.username;
                this.transport.write_complete = true;
                this.transport.read_complete = true;
            }
        }
    };

    SaslServer.prototype.on_sasl_init = function (frame) {
        var saslctor = this.mechanisms[frame.performative.mechanism];
        if (saslctor) {
            this.mechanism = saslctor();
            Promise.resolve(this.mechanism.start(frame.performative.initial_response, frame.performative.hostname))
                .then(this.do_step.bind(this))
                .catch(this.do_fail.bind(this));
        } else {
            this.outcome = sasl_codes.AUTH;
            this.transport.encode(frames_1.sasl_frame(frames_1.sasl_outcome({code: this.outcome})));
        }
    };

    SaslServer.prototype.on_sasl_response = function (frame) {
        Promise.resolve(this.mechanism.step(frame.performative.response))
            .then(this.do_step.bind(this))
            .catch(this.do_fail.bind(this));
    };

    SaslServer.prototype.do_fail = function (e) {
        var frame = frames_1.sasl_frame(frames_1.sasl_outcome({code: sasl_codes.SYS}));
        this.transport.encode(frame);
        this.connection.output();
        this.connection.sasl_failed('Sasl callback promise failed' + e, 'amqp:internal-error');
    };

    SaslServer.prototype.has_writes_pending = function () {
        return this.transport.has_writes_pending() || this.next.has_writes_pending();
    };

    SaslServer.prototype.write = function (socket) {
        if (this.transport.write_complete && this.transport.pending.length === 0) {
            return this.next.write(socket);
        } else {
            return this.transport.write(socket);
        }
    };

    SaslServer.prototype.read = function (buffer) {
        if (this.transport.read_complete) {
            return this.next.read(buffer);
        } else {
            return this.transport.read(buffer);
        }
    };

    var SaslClient = function (connection, mechanisms, hostname) {
        this.connection = connection;
        this.transport = new transport(connection.amqp_transport.identifier, SASL_PROTOCOL_ID, frames_1.TYPE_SASL, this);
        this.next = connection.amqp_transport;
        this.mechanisms = mechanisms;
        this.mechanism = undefined;
        this.mechanism_name = undefined;
        this.hostname = hostname;
        this.failed = false;
    };

    SaslClient.prototype.on_sasl_mechanisms = function (frame) {
        var offered_mechanisms = [];
        if (Array.isArray(frame.performative.sasl_server_mechanisms)) {
            offered_mechanisms = frame.performative.sasl_server_mechanisms;
        } else if (frame.performative.sasl_server_mechanisms) {
            offered_mechanisms = [frame.performative.sasl_server_mechanisms];
        }
        for (var i = 0; this.mechanism === undefined && i < offered_mechanisms.length; i++) {
            var mech = offered_mechanisms[i];
            var f = this.mechanisms[mech];
            if (f) {
                this.mechanism = typeof f === 'function' ? f() : f;
                this.mechanism_name = mech;
            }
        }
        if (this.mechanism) {
            var self = this;
            this.mechanism.start(function (err, response) {
                if (err) {
                    self.failed = true;
                    self.connection.sasl_failed('SASL mechanism init failed: ' + err);
                } else {
                    var init = {'mechanism':self.mechanism_name,'initial_response':response};
                    if (self.hostname) {
                        init.hostname = self.hostname;
                    }
                    self.transport.encode(frames_1.sasl_frame(frames_1.sasl_init(init)));
                    self.connection.output();
                }
            });
        } else {
            this.failed = true;
            this.connection.sasl_failed('No suitable mechanism; server supports ' + frame.performative.sasl_server_mechanisms);
        }
    };
    SaslClient.prototype.on_sasl_challenge = function (frame) {
        var self = this;
        this.mechanism.step(frame.performative.challenge, function (err, response) {
            if (err) {
                self.failed = true;
                self.connection.sasl_failed('SASL mechanism challenge failed: ' + err);
            } else {
                self.transport.encode(frames_1.sasl_frame(frames_1.sasl_response({'response':response})));
                self.connection.output();
            }
        });
    };
    SaslClient.prototype.on_sasl_outcome = function (frame) {
        switch (frame.performative.code) {
        case sasl_codes.OK:
            this.transport.read_complete = true;
            this.transport.write_complete = true;
            break;
        case sasl_codes.SYS:
        case sasl_codes.SYS_PERM:
        case sasl_codes.SYS_TEMP:
            this.transport.write_complete = true;
            this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code, 'amqp:internal-error');
            break;
        default:
            this.transport.write_complete = true;
            this.connection.sasl_failed('Failed to authenticate: ' + frame.performative.code);
        }
    };

    SaslClient.prototype.has_writes_pending = function () {
        return this.transport.has_writes_pending() || this.next.has_writes_pending();
    };

    SaslClient.prototype.write = function (socket) {
        if (this.transport.write_complete) {
            return this.next.write(socket);
        } else {
            return this.transport.write(socket);
        }
    };

    SaslClient.prototype.read = function (buffer) {
        if (this.transport.read_complete) {
            return this.next.read(buffer);
        } else {
            return this.transport.read(buffer);
        }
    };

    var SelectiveServer = function (connection, mechanisms) {
        this.header_received = false;
        this.transports = {
            0: connection.amqp_transport,
            3: new SaslServer(connection, mechanisms)
        };
        this.selected = undefined;
    };

    SelectiveServer.prototype.has_writes_pending = function () {
        return this.header_received && this.selected.has_writes_pending();
    };

    SelectiveServer.prototype.write = function (socket) {
        if (this.selected) {
            return this.selected.write(socket);
        } else {
            return 0;
        }
    };

    SelectiveServer.prototype.read = function (buffer) {
        if (!this.header_received) {
            if (buffer.length < 8) {
                return 0;
            } else {
                this.header_received = frames_1.read_header(buffer);
                this.selected = this.transports[this.header_received.protocol_id];
                if (this.selected === undefined) {
                    throw new errors.ProtocolError('Invalid AMQP protocol id ' + this.header_received.protocol_id);
                }
            }
        }
        return this.selected.read(buffer);
    };

    var default_server_mechanisms = {
        enable_anonymous: function () {
            this['ANONYMOUS'] = function() { return new AnonymousServer(); };
        },
        enable_plain: function (callback) {
            this['PLAIN'] = function() { return new PlainServer(callback); };
        }
    };

    var default_client_mechanisms = {
        enable_anonymous: function (name) {
            this['ANONYMOUS'] = function() { return new AnonymousClient(name); };
        },
        enable_plain: function (username, password) {
            this['PLAIN'] = function() { return new PlainClient(username, password); };
        },
        enable_external: function () {
            this['EXTERNAL'] = function() { return new ExternalClient(); };
        },
        enable_xoauth2: function (username, token) {
            if (username && token) {
                this['XOAUTH2'] = function() { return new XOAuth2Client(username, token); };
            } else if (token === undefined) {
                throw Error('token must be specified');
            } else if (username === undefined) {
                throw Error('username must be specified');
            }
        }
    };

    var sasl = {
        Client : SaslClient,
        Server : SaslServer,
        Selective: SelectiveServer,
        server_mechanisms : function () {
            return Object.create(default_server_mechanisms);
        },
        client_mechanisms : function () {
            return Object.create(default_client_mechanisms);
        },
        server_add_external: function (mechs) {
            mechs['EXTERNAL'] = function() { return new ExternalServer(); };
            return mechs;
        }
    };

    /*
     * Copyright 2015 Red Hat Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var EndpointState = function () {
        this.init();
    };

    EndpointState.prototype.init = function () {
        this.local_open = false;
        this.remote_open = false;
        this.open_requests = 0;
        this.close_requests = 0;
        this.initialised = false;
        this.marker = undefined;
    };

    EndpointState.prototype.mark = function (o) {
        this.marker = o || Date.now();
        return this.marker;
    };

    EndpointState.prototype.open = function () {
        this.marker = undefined;
        this.initialised = true;
        if (!this.local_open) {
            this.local_open = true;
            this.open_requests++;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.close = function () {
        this.marker = undefined;
        if (this.local_open) {
            this.local_open = false;
            this.close_requests++;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.disconnected = function () {
        var was_initialised = this.initialised;
        this.was_open = this.local_open;
        this.init();
        this.initialised = was_initialised;
    };

    EndpointState.prototype.reconnect = function () {
        if (this.was_open) {
            this.open();
            this.was_open = undefined;
        }
    };

    EndpointState.prototype.remote_opened = function () {
        if (!this.remote_open) {
            this.remote_open = true;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.remote_closed = function () {
        if (this.remote_open) {
            this.remote_open = false;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.is_open = function () {
        return this.local_open && this.remote_open;
    };

    EndpointState.prototype.is_closed = function () {
        return this.initialised && !(this.local_open || this.was_open) && !this.remote_open;
    };

    EndpointState.prototype.has_settled = function () {
        return this.open_requests === 0 && this.close_requests === 0;
    };

    EndpointState.prototype.need_open = function () {
        if (this.open_requests > 0) {
            this.open_requests--;
            return true;
        } else {
            return false;
        }
    };

    EndpointState.prototype.need_close = function () {
        if (this.close_requests > 0) {
            this.close_requests--;
            return true;
        } else {
            return false;
        }
    };

    var endpoint = EndpointState;

    var by_descriptor$2 = {};
    var unwrappers = {};
    var wrappers = [];
    var message$1 = {};

    function define_section(descriptor, unwrap, wrap) {
        unwrap.descriptor = descriptor;
        unwrappers[descriptor.symbolic] = unwrap;
        unwrappers[Number(descriptor.numeric).toString(10)] = unwrap;
        if (wrap) {
            wrappers.push(wrap);
        }
    }

    function define_composite_section(def) {
        var c = types_1.define_composite(def);
        message$1[def.name] = c.create;
        by_descriptor$2[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor$2[c.descriptor.symbolic] = c;

        var unwrap = function (msg, section) {
            var composite = new c(section.value);
            for (var i = 0; i < def.fields.length; i++) {
                var f = def.fields[i];
                var v = composite[f.name];
                if (v !== undefined && v !== null) {
                    msg[f.name] = v;
                }
            }
        };

        var wrap = function (sections, msg) {
            sections.push(c.create(msg).described());
        };
        define_section(c.descriptor, unwrap, wrap);
    }


    function define_map_section(def, symbolic) {
        var wrapper = symbolic ? types_1.wrap_symbolic_map : types_1.wrap_map;
        var descriptor = {numeric:def.code};
        descriptor.symbolic = 'amqp:' + def.name.replace(/_/g, '-') + ':map';
        var unwrap = function (msg, section) {
            msg[def.name] = types_1.unwrap_map_simple(section);
        };
        var wrap = function (sections, msg) {
            if (msg[def.name]) {
                sections.push(types_1.described_nc(types_1.wrap_ulong(descriptor.numeric), wrapper(msg[def.name])));
            }
        };
        define_section(descriptor, unwrap, wrap);
    }

    function Section(typecode, content, multiple) {
        this.typecode = typecode;
        this.content = content;
        this.multiple = multiple;
    }

    Section.prototype.described = function (item) {
        return types_1.described(types_1.wrap_ulong(this.typecode), types_1.wrap(item || this.content));
    };

    Section.prototype.collect_sections = function (sections) {
        if (this.multiple) {
            for (var i = 0; i < this.content.length; i++) {
                sections.push(this.described(this.content[i]));
            }
        } else {
            sections.push(this.described());
        }
    };

    define_composite_section({
        name:'header',
        code:0x70,
        fields:[
            {name:'durable', type:'boolean', default_value:false},
            {name:'priority', type:'ubyte', default_value:4},
            {name:'ttl', type:'uint'},
            {name:'first_acquirer', type:'boolean', default_value:false},
            {name:'delivery_count', type:'uint', default_value:0}
        ]
    });
    define_map_section({name:'delivery_annotations', code:0x71}, true);
    define_map_section({name:'message_annotations', code:0x72}, true);
    define_composite_section({
        name:'properties',
        code:0x73,
        fields:[
            {name:'message_id', type:'message_id'},
            {name:'user_id', type:'binary'},
            {name:'to', type:'string'},
            {name:'subject', type:'string'},
            {name:'reply_to', type:'string'},
            {name:'correlation_id', type:'message_id'},
            {name:'content_type', type:'symbol'},
            {name:'content_encoding', type:'symbol'},
            {name:'absolute_expiry_time', type:'timestamp'},
            {name:'creation_time', type:'timestamp'},
            {name:'group_id', type:'string'},
            {name:'group_sequence', type:'uint'},
            {name:'reply_to_group_id', type:'string'}
        ]
    });
    define_map_section({name:'application_properties', code:0x74});

    function unwrap_body_section (msg, section, typecode) {
        if (msg.body === undefined) {
            msg.body = new Section(typecode, types_1.unwrap(section));
        } else if (msg.body.constructor === Section && msg.body.typecode === typecode) {
            if (msg.body.multiple) {
                msg.body.content.push(types_1.unwrap(section));
            } else {
                msg.body.multiple = true;
                msg.body.content = [msg.body.content, types_1.unwrap(section)];
            }
        }
    }

    define_section({numeric:0x75, symbolic:'amqp:data:binary'}, function (msg, section) { unwrap_body_section(msg, section, 0x75); });
    define_section({numeric:0x76, symbolic:'amqp:amqp-sequence:list'}, function (msg, section) { unwrap_body_section(msg, section, 0x76); });
    define_section({numeric:0x77, symbolic:'amqp:value:*'}, function (msg, section) { msg.body = types_1.unwrap(section); });

    define_map_section({name:'footer', code:0x78});


    function wrap_body (sections, msg) {
        if (msg.body && msg.body.collect_sections) {
            msg.body.collect_sections(sections);
        } else {
            sections.push(types_1.described(types_1.wrap_ulong(0x77), types_1.wrap(msg.body)));
        }
    }

    wrappers.push(wrap_body);

    message$1.data_section = function (data) {
        return new Section(0x75, data);
    };

    message$1.sequence_section = function (list) {
        return new Section(0x76, list);
    };

    message$1.data_sections = function (data_elements) {
        return new Section(0x75, data_elements, true);
    };

    message$1.sequence_sections = function (lists) {
        return new Section(0x76, lists, true);
    };

    function copy(src, tgt) {
        for (var k in src) {
            var v = src[k];
            if (typeof v === 'object') {
                copy(v, tgt[k]);
            } else {
                tgt[k] = v;
            }
        }
    }

    function Message(o) {
        if (o) {
            copy(o, this);
        }
    }

    Message.prototype.toJSON = function () {
        var o = {};
        for (var key in this) {
            if (typeof this[key] === 'function') continue;
            o[key] = this[key];
        }
        return o;
    };

    Message.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };


    message$1.encode = function(msg) {
        var sections = [];
        wrappers.forEach(function (wrapper_fn) { wrapper_fn(sections, msg); });
        var writer = new types_1.Writer();
        for (var i = 0; i < sections.length; i++) {
            log.message('Encoding section %d of %d: %o', (i+1), sections.length, sections[i]);
            writer.write(sections[i]);
        }
        var data = writer.toBuffer();
        log.message('encoded %d bytes', data.length);
        return data;
    };

    message$1.decode = function(buffer) {
        var msg = new Message();
        var reader = new types_1.Reader(buffer);
        while (reader.remaining()) {
            var s = reader.read();
            log.message('decoding section: %o of type: %o', s, s.descriptor);
            if (s.descriptor) {
                var unwrap = unwrappers[s.descriptor.value];
                if (unwrap) {
                    unwrap(msg, s);
                } else {
                    console.warn('WARNING: did not recognise message section with descriptor ' + s.descriptor);
                }
            } else {
                console.warn('WARNING: expected described message section got ' + JSON.stringify(s));
            }
        }
        return msg;
    };

    var outcomes = {};

    function define_outcome(def) {
        var c = types_1.define_composite(def);
        c.composite_type = def.name;
        message$1[def.name] = c.create;
        outcomes[Number(c.descriptor.numeric).toString(10)] = c;
        outcomes[c.descriptor.symbolic] = c;
        message$1['is_' + def.name] = function (o) {
            if (o && o.descriptor) {
                var c = outcomes[o.descriptor.value];
                if (c) {
                    return c.descriptor.numeric === def.code;
                }
            }
            return false;
        };
    }

    message$1.unwrap_outcome = function (outcome) {
        if (outcome && outcome.descriptor) {
            var c = outcomes[outcome.descriptor.value];
            if (c) {
                return new c(outcome.value);
            }
        }
        console.error('unrecognised outcome: ' + JSON.stringify(outcome));
        return outcome;
    };

    message$1.are_outcomes_equivalent = function(a, b) {
        if (a === undefined && b === undefined) return true;
        else if (a === undefined || b === undefined) return false;
        else return a.descriptor.value === b.descriptor.value && a.descriptor.value === 0x24;//only batch accepted
    };

    define_outcome({
        name:'received',
        code:0x23,
        fields:[
            {name:'section_number', type:'uint', mandatory:true},
            {name:'section_offset', type:'ulong', mandatory:true}
        ]});
    define_outcome({name:'accepted', code:0x24, fields:[]});
    define_outcome({name:'rejected', code:0x25, fields:[{name:'error', type:'error'}]});
    define_outcome({name:'released', code:0x26, fields:[]});
    define_outcome({
        name:'modified',
        code:0x27,
        fields:[
            {name:'delivery_failed', type:'boolean'},
            {name:'undeliverable_here', type:'boolean'},
            {name:'message_annotations', type:'map'}
        ]});

    var message_1 = message$1;

    var terminus = {};
    var by_descriptor$3 = {};

    function define_terminus(def) {
        var c = types_1.define_composite(def);
        terminus[def.name] = c.create;
        by_descriptor$3[Number(c.descriptor.numeric).toString(10)] = c;
        by_descriptor$3[c.descriptor.symbolic] = c;
    }

    terminus.unwrap = function(field) {
        if (field && field.descriptor) {
            var c = by_descriptor$3[field.descriptor.value];
            if (c) {
                return new c(field.value);
            } else {
                console.warn('Unknown terminus: ' + field.descriptor);
            }
        }
        return null;
    };

    define_terminus({
        name: 'source',
        code: 0x28,
        fields: [
            {name: 'address', type: 'string'},
            {name: 'durable', type: 'uint', default_value: 0},
            {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},
            {name: 'timeout', type: 'uint', default_value: 0},
            {name: 'dynamic', type: 'boolean', default_value: false},
            {name: 'dynamic_node_properties', type: 'symbolic_map'},
            {name: 'distribution_mode', type: 'symbol'},
            {name: 'filter', type: 'symbolic_map'},
            {name: 'default_outcome', type: '*'},
            {name: 'outcomes', type: 'symbol', multiple: true},
            {name: 'capabilities', type: 'symbol', multiple: true}
        ]
    });

    define_terminus({
        name: 'target',
        code: 0x29,
        fields: [
            {name: 'address', type: 'string'},
            {name: 'durable', type: 'uint', default_value: 0},
            {name: 'expiry_policy', type: 'symbol', default_value: 'session-end'},
            {name: 'timeout', type: 'uint', default_value: 0},
            {name: 'dynamic', type: 'boolean', default_value: false},
            {name: 'dynamic_node_properties', type: 'symbolic_map'},
            {name: 'capabilities', type: 'symbol', multiple: true}
        ]
    });

    var terminus_1 = terminus;

    // Copyright Joyent, Inc. and other Node contributors.

    var R = typeof Reflect === 'object' ? Reflect : null;
    var ReflectApply = R && typeof R.apply === 'function'
      ? R.apply
      : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };

    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === 'function') {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target)
          .concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
      };
    }

    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }

    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
      return value !== value;
    };

    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    var events = EventEmitter;

    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    var defaultMaxListeners = 10;

    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
      }
    });

    EventEmitter.init = function() {

      if (this._events === undefined ||
          this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
      }
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };

    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = (type === 'error');

      var events = this._events;
      if (events !== undefined)
        doError = (doError && events.error === undefined);
      else if (!doError)
        return false;

      // If there is no 'error' event listener then throw.
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
      }

      var handler = events[type];

      if (handler === undefined)
        return false;

      if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = target._events;
      if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] =
            prepend ? [listener, existing] : [existing, listener];
          // If we've already got an array, just append.
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }

        // Check for listener leak
        m = $getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          // No error code for this since it is a Warning
          // eslint-disable-next-line no-restricted-syntax
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + String(type) + ' listeners ' +
                              'added. Use emitter.setMaxListeners() to ' +
                              'increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }

      return target;
    }

    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function onceWrapper() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        ReflectApply(this.listener, this.target, args);
      }
    }

    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function') {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // Emits a 'removeListener' event if and only if the listener was removed.
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== 'function') {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }

          events = this._events;
          if (events === undefined)
            return this;

          list = events[type];
          if (list === undefined)
            return this;

          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (position === 0)
              list.shift();
            else {
              spliceOne(list, position);
            }

            if (list.length === 1)
              events[type] = list[0];

            if (events.removeListener !== undefined)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };

    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events, i;

          events = this._events;
          if (events === undefined)
            return this;

          // not listening for removeListener, no need to emit
          if (events.removeListener === undefined) {
            if (arguments.length === 0) {
              this._events = Object.create(null);
              this._eventsCount = 0;
            } else if (events[type] !== undefined) {
              if (--this._eventsCount === 0)
                this._events = Object.create(null);
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners !== undefined) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }

          return this;
        };

    function _listeners(target, type, unwrap) {
      var events = target._events;

      if (events === undefined)
        return [];

      var evlistener = events[type];
      if (evlistener === undefined)
        return [];

      if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];

      return unwrap ?
        unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }

    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };

    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;

      if (events !== undefined) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener !== undefined) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };

    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }

    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    var FlowController = function (window) {
        this.window = window;
    };
    FlowController.prototype.update = function (context) {
        var delta = this.window - context.receiver.credit;
        if (delta >= (this.window/4)) {
            context.receiver.flow(delta);
        }
    };

    function auto_settle(context) {
        context.delivery.settled = true;
    }

    function auto_accept(context) {
        context.delivery.update(undefined, message_1.accepted().described());
    }

    function LinkError(message, condition, link) {
        Error.call(this);
        Error.captureStackTrace(this, this.constructor);
        this.message = message;
        this.condition = condition;
        this.description = message;
        this.link = link;
    }
    util.inherits(LinkError, Error);

    var EventEmitter$1 = events.EventEmitter;

    var link = Object.create(EventEmitter$1.prototype);
    link.dispatch = function(name) {
        log.events('[%s] Link got event: %s', this.connection.options.id, name);
        EventEmitter$1.prototype.emit.apply(this.observers, arguments);
        if (this.listeners(name).length) {
            EventEmitter$1.prototype.emit.apply(this, arguments);
            return true;
        } else {
            return this.session.dispatch.apply(this.session, arguments);
        }
    };
    link.set_source = function (fields) {
        this.local.attach.source = terminus_1.source(fields).described();
    };
    link.set_target = function (fields) {
        this.local.attach.target = terminus_1.target(fields).described();
    };

    link.attach = function () {
        if (this.state.open()) {
            this.connection._register();
        }
    };
    link.open = link.attach;

    link.detach = function () {
        this.local.detach.closed = false;
        if (this.state.close()) {
            this.connection._register();
        }
    };
    link.close = function(error) {
        if (error) this.local.detach.error = error;
        this.local.detach.closed = true;
        if (this.state.close()) {
            this.connection._register();
        }
    };

    /**
     * This forcibly removes the link from the parent session. It should
     * not be called for a link on an active session/connection, where
     * close() should be used instead.
     */
    link.remove = function() {
        this.session.remove_link(this);
    };

    link.is_open = function () {
        return this.session.is_open() && this.state.is_open();
    };

    link.is_remote_open = function () {
        return this.session.is_remote_open() && this.state.remote_open;
    };

    link.is_itself_closed = function() {
        return this.state.is_closed();
    };

    link.is_closed = function () {
        return this.session.is_closed() || this.is_itself_closed();
    };

    link._process = function () {
        do {
            if (this.state.need_open()) {
                this.session.output(this.local.attach);
            }

            if (this.issue_flow && this.state.local_open) {
                this.session._write_flow(this);
                this.issue_flow = false;
            }

            if (this.state.need_close()) {
                this.session.output(this.local.detach);
            }
        } while (!this.state.has_settled());
    };

    link.on_attach = function (frame) {
        if (this.state.remote_opened()) {
            if (!this.remote.handle) {
                this.remote.handle = frame.handle;
            }
            frame.performative.source = terminus_1.unwrap(frame.performative.source);
            frame.performative.target = terminus_1.unwrap(frame.performative.target);
            this.remote.attach = frame.performative;
            this.open();
            this.dispatch(this.is_receiver() ? 'receiver_open' : 'sender_open', this._context());
        } else {
            throw Error('Attach already received');
        }
    };

    link.prefix_event = function (event) {
        return (this.local.attach.role ? 'receiver_' : 'sender_') + event;
    };

    link.on_detach = function (frame) {
        if (this.state.remote_closed()) {
            if (this._incomplete) {
                this._incomplete.settled = true;
            }
            this.remote.detach = frame.performative;
            var error = this.remote.detach.error;
            if (error) {
                var handled = this.dispatch(this.prefix_event('error'), this._context());
                handled = this.dispatch(this.prefix_event('close'), this._context()) || handled;
                if (!handled) {
                    EventEmitter$1.prototype.emit.call(this.connection.container, 'error', new LinkError(error.description, error.condition, this));
                }
            } else {
                this.dispatch(this.prefix_event('close'), this._context());
            }
            var self = this;
            var token = this.state.mark();
            browser.nextTick(function () {
                if (self.state.marker === token) {
                    self.close();
                    browser.nextTick(function () { self.remove(); });
                }
            });
        } else {
            throw Error('Detach already received');
        }
    };

    function is_internal(name) {
        switch (name) {
        case 'name':
        case 'handle':
        case 'role':
        case 'initial_delivery_count':
            return true;
        default:
            return false;
        }
    }


    var aliases = [
        'snd_settle_mode',
        'rcv_settle_mode',
        'source',
        'target',
        'max_message_size',
        'offered_capabilities',
        'desired_capabilities',
        'properties'
    ];

    function remote_property_shortcut(name) {
        return function() { return this.remote.attach ? this.remote.attach[name] : undefined; };
    }

    link.init = function (session, name, local_handle, opts, is_receiver) {
        this.session = session;
        this.connection = session.connection;
        this.name = name;
        this.options = opts === undefined ? {} : opts;
        this.state = new endpoint();
        this.issue_flow = false;
        this.local = {'handle': local_handle};
        this.local.attach = frames_1.attach({'handle':local_handle,'name':name, role:is_receiver});
        for (var field in this.local.attach) {
            if (!is_internal(field) && this.options[field] !== undefined) {
                this.local.attach[field] = this.options[field];
            }
        }
        this.local.detach = frames_1.detach({'handle':local_handle, 'closed':true});
        this.remote = {'handle':undefined};
        this.delivery_count = 0;
        this.credit = 0;
        this.observers = new EventEmitter$1();
        for (var i in aliases) {
            var alias = aliases[i];
            Object.defineProperty(this, alias, { get: remote_property_shortcut(alias) });
        }
        Object.defineProperty(this, 'error', { get:  function() { return this.remote.detach ? this.remote.detach.error : undefined; }});
    };

    link._disconnect = function() {
        this.state.disconnected();
        if (!this.state.was_open) {
            this.remove();
        }
    };

    link._reconnect = function() {
        this.state.reconnect();
        this.remote = {'handle':undefined};
        this.delivery_count = 0;
        this.credit = 0;
    };

    link.has_credit = function () {
        return this.credit > 0;
    };
    link.is_receiver = function () {
        return this.local.attach.role;
    };
    link.is_sender = function () {
        return !this.is_receiver();
    };
    link._context = function (c) {
        var context = c ? c : {};
        if (this.is_receiver()) {
            context.receiver = this;
        } else {
            context.sender = this;
        }
        return this.session._context(context);
    };
    link.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else return this.session.get_option(name, default_value);
    };

    var Sender = function (session, name, local_handle, opts) {
        this.init(session, name, local_handle, opts, false);
        this._draining = false;
        this._drained = false;
        this.local.attach.initial_delivery_count = 0;
        this.tag = 0;
        if (this.get_option('autosettle', true)) {
            this.observers.on('settled', auto_settle);
        }
        var sender = this;
        if (this.get_option('treat_modified_as_released', true)) {
            this.observers.on('modified', function (context) {
                sender.dispatch('released', context);
            });
        }
    };
    Sender.prototype = Object.create(link);
    Sender.prototype.constructor = Sender;
    Sender.prototype._get_drain = function () {
        if (this._draining && this._drained && this.credit) {
            while (this.credit) {
                ++this.delivery_count;
                --this.credit;
            }
            return true;
        } else {
            return false;
        }
    };
    Sender.prototype.set_drained = function (drained) {
        this._drained = drained;
        if (this._draining && this._drained) {
            this.issue_flow = true;
        }
    };
    Sender.prototype.next_tag = function () {
        return buffer_1.from(new String(this.tag++));
    };
    Sender.prototype.sendable = function () {
        return Boolean(this.credit && this.session.outgoing.available());
    };
    Sender.prototype.on_flow = function (frame) {
        var flow = frame.performative;
        this.credit = flow.delivery_count + flow.link_credit - this.delivery_count;
        this._draining = flow.drain;
        this._drained = this.credit > 0;
        if (this.is_open()) {
            this.dispatch('sender_flow', this._context());
            if (this._draining) {
                this.dispatch('sender_draining', this._context());
            }
            if (this.sendable()) {
                this.dispatch('sendable', this._context());
            }
        }
    };
    Sender.prototype.on_transfer = function () {
        throw Error('got transfer on sending link');
    };

    Sender.prototype.send = function (msg, tag, format) {
        var payload = format === undefined ? message_1.encode(msg) : msg;
        var delivery = this.session.send(this, tag ? tag : this.next_tag(), payload, format);
        if (this.local.attach.snd_settle_mode === 1) {
            delivery.settled = true;
        }
        return delivery;
    };

    var Receiver = function (session, name, local_handle, opts) {
        this.init(session, name, local_handle, opts, true);
        this.drain = false;
        this.set_credit_window(this.get_option('credit_window', 1000));
        if (this.get_option('autoaccept', true)) {
            this.observers.on('message', auto_accept);
        }
        if (this.local.attach.rcv_settle_mode === 1 && this.get_option('autosettle', true)) {
            this.observers.on('settled', auto_settle);
        }
    };
    Receiver.prototype = Object.create(link);
    Receiver.prototype.constructor = Receiver;
    Receiver.prototype.on_flow = function (frame) {
        this.dispatch('receiver_flow', this._context());
        if (frame.performative.drain) {
            this.credit = frame.performative.link_credit;
            this.delivery_count = frame.performative.delivery_count;
            if (frame.performative.link_credit > 0) console.error('ERROR: received flow with drain set, but non zero credit');
            else this.dispatch('receiver_drained', this._context());
        }
    };
    Receiver.prototype.flow = function(credit) {
        if (credit > 0) {
            this.credit += credit;
            this.issue_flow = true;
            this.connection._register();
        }
    };
    Receiver.prototype.add_credit = Receiver.prototype.flow;//alias
    Receiver.prototype._get_drain = function () {
        return this.drain;
    };

    Receiver.prototype.set_credit_window = function(credit_window) {
        if (credit_window > 0) {
            var flow_controller = new FlowController(credit_window);
            var listener = flow_controller.update.bind(flow_controller);
            this.observers.on('message', listener);
            this.observers.on('receiver_open', listener);
        }
    };

    var link_1 = {'Sender': Sender, 'Receiver':Receiver};

    var link$1 = link_1;






    var EventEmitter$2 = events.EventEmitter;

    function SessionError(message, condition, session) {
        Error.call(this);
        Error.captureStackTrace(this, this.constructor);
        this.message = message;
        this.condition = condition;
        this.description = message;
        this.session = session;
    }
    util.inherits(SessionError, Error);

    var CircularBuffer = function (capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.head = 0;
        this.tail = 0;
        this.entries = [];
    };

    CircularBuffer.prototype.available = function () {
        return this.capacity - this.size;
    };

    CircularBuffer.prototype.push = function (o) {
        if (this.size < this.capacity) {
            this.entries[this.tail] = o;
            this.tail = (this.tail + 1) % this.capacity;
            this.size++;
        } else {
            throw Error('circular buffer overflow: head=' + this.head + ' tail=' + this.tail + ' size=' + this.size + ' capacity=' + this.capacity);
        }
    };

    CircularBuffer.prototype.pop_if = function (f) {
        var count = 0;
        while (this.size && f(this.entries[this.head])) {
            this.entries[this.head] = undefined;
            this.head = (this.head + 1) % this.capacity;
            this.size--;
            count++;
        }
        return count;
    };

    CircularBuffer.prototype.by_id = function (id) {
        if (this.size > 0) {
            var gap = id - this.entries[this.head].id;
            if (gap < this.size) {
                return this.entries[(this.head + gap) % this.capacity];
            }
        }
        return undefined;
    };

    CircularBuffer.prototype.get_head = function () {
        return this.size > 0 ? this.entries[this.head] : undefined;
    };

    CircularBuffer.prototype.get_tail = function () {
        return this.size > 0 ? this.entries[(this.head + this.size - 1) % this.capacity] : undefined;
    };

    function write_dispositions(deliveries) {
        var first, last, next_id, i, delivery;

        for (i = 0; i < deliveries.length; i++) {
            delivery = deliveries[i];
            if (first === undefined) {
                first = delivery;
                last = delivery;
                next_id = delivery.id;
            }

            if ((first !== last && !message_1.are_outcomes_equivalent(last.state, delivery.state)) || last.settled !== delivery.settled || next_id !== delivery.id) {
                first.link.session.output(frames_1.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));
                first = delivery;
                last = delivery;
                next_id = delivery.id;
            } else {
                if (last.id !== delivery.id) {
                    last = delivery;
                }
                next_id++;
            }
        }
        if (first !== undefined && last !== undefined) {
            first.link.session.output(frames_1.disposition({'role' : first.link.is_receiver(), 'first' : first.id, 'last' : last.id, 'state' : first.state, 'settled' : first.settled}));
        }
    }

    var Outgoing = function (connection) {
        /* TODO: make size configurable? */
        this.deliveries = new CircularBuffer(2048);
        this.updated = [];
        this.pending_dispositions = [];
        this.next_delivery_id = 0;
        this.next_pending_delivery = 0;
        this.next_transfer_id = 0;
        this.window = types_1.MAX_UINT;
        this.remote_next_transfer_id = undefined;
        this.remote_window = undefined;
        this.connection = connection;
    };

    Outgoing.prototype.available = function () {
        return this.deliveries.available();
    };

    Outgoing.prototype.compute_max_payload = function (tag) {
        if (this.connection.max_frame_size) {
            return this.connection.max_frame_size - (50 + tag.length);
        } else {
            return undefined;
        }
    };

    Outgoing.prototype.send = function (sender, tag, data, format) {
        var fragments = [];
        var max_payload = this.compute_max_payload(tag);
        if (max_payload && data.length > max_payload) {
            var start = 0;
            while (start < data.length) {
                var end = Math.min(start + max_payload, data.length);
                fragments.push(data.slice(start, end));
                start = end;
            }
        } else {
            fragments.push(data);
        }
        var d = {
            'id':this.next_delivery_id++,
            'tag':tag,
            'link':sender,
            'data': fragments,
            'format':format ? format : 0,
            'sent': false,
            'settled': false,
            'state': undefined,
            'remote_settled': false,
            'remote_state': undefined
        };
        var self = this;
        d.update = function (settled, state) {
            self.update(d, settled, state);
        };
        this.deliveries.push(d);
        return d;
    };

    Outgoing.prototype.on_begin = function (fields) {
        this.remote_window = fields.incoming_window;
    };

    Outgoing.prototype.on_flow = function (fields) {
        this.remote_next_transfer_id = fields.next_incoming_id;
        this.remote_window = fields.incoming_window;
    };

    Outgoing.prototype.on_disposition = function (fields) {
        var last = fields.last ? fields.last : fields.first;
        for (var i = fields.first; i <= last; i++) {
            var d = this.deliveries.by_id(i);
            if (d && !d.remote_settled) {
                var updated = false;
                if (fields.settled) {
                    d.remote_settled = fields.settled;
                    updated = true;
                }
                if (fields.state && fields.state !== d.remote_state) {
                    d.remote_state = message_1.unwrap_outcome(fields.state);
                    updated = true;
                }
                if (updated) {
                    this.updated.push(d);
                }
            }
        }
    };

    Outgoing.prototype.update = function (delivery, settled, state) {
        if (delivery) {
            delivery.settled = settled;
            if (state !== undefined) delivery.state = state;
            if (!delivery.remote_settled) {
                this.pending_dispositions.push(delivery);
            }
            delivery.link.connection._register();
        }
    };

    Outgoing.prototype.transfer_window = function() {
        if (this.remote_window) {
            return this.remote_window - (this.next_transfer_id - this.remote_next_transfer_id);
        } else {
            return 0;
        }
    };

    Outgoing.prototype.process = function() {
        var d;
        // send pending deliveries for which there is credit:
        while (this.next_pending_delivery < this.next_delivery_id) {
            d = this.deliveries.by_id(this.next_pending_delivery);
            if (d) {
                if (d.link.has_credit()) {
                    if (this.transfer_window() >= d.data.length) {
                        this.window -= d.data.length;
                        for (var i = 0; i < d.data.length; i++) {
                            this.next_transfer_id++;
                            var more = (i+1) < d.data.length;
                            var transfer = frames_1.transfer({'handle':d.link.local.handle,'message_format':d.format,'delivery_id':d.id, 'delivery_tag':d.tag, 'settled':d.settled, 'more':more});
                            d.link.session.output(transfer, d.data[i]);
                            if (d.settled) {
                                d.remote_settled = true;//if sending presettled, it can now be cleaned up
                            }
                        }
                        d.link.credit--;
                        d.link.delivery_count++;
                        this.next_pending_delivery++;
                    } else {
                        log.flow('[%s] Incoming window of peer preventing sending further transfers: remote_window=%d, remote_next_transfer_id=%d, next_transfer_id=%d',
                            this.connection.options.id, this.remote_window, this.remote_next_transfer_id, this.next_transfer_id);
                        break;
                    }
                } else {
                    log.flow('[%s] Link has no credit', this.connection.options.id);
                    break;
                }
            } else {
                console.error('ERROR: Next pending delivery not found: ' + this.next_pending_delivery);
                break;
            }
        }

        // notify application of any updated deliveries:
        for (var i = 0; i < this.updated.length; i++) {
            d = this.updated[i];
            if (d.remote_state && d.remote_state.constructor.composite_type) {
                d.link.dispatch(d.remote_state.constructor.composite_type, d.link._context({'delivery':d}));
            }
            if (d.remote_settled) d.link.dispatch('settled', d.link._context({'delivery':d}));
        }
        this.updated = [];

        if (this.pending_dispositions.length) {
            write_dispositions(this.pending_dispositions);
            this.pending_dispositions = [];
        }

        // remove any fully settled deliveries:
        this.deliveries.pop_if(function (d) { return d.settled && d.remote_settled; });
    };

    var Incoming = function () {
        this.deliveries = new CircularBuffer(2048/*TODO: configurable?*/);
        this.updated = [];
        this.next_transfer_id = 0;
        this.next_delivery_id = undefined;
        Object.defineProperty(this, 'window', { get: function () { return this.deliveries.available(); } });
        this.remote_next_transfer_id = undefined;
        this.remote_window = undefined;
        this.max_transfer_id = this.next_transfer_id + this.window;
    };

    Incoming.prototype.update = function (delivery, settled, state) {
        if (delivery) {
            delivery.settled = settled;
            if (state !== undefined) delivery.state = state;
            if (!delivery.remote_settled) {
                this.updated.push(delivery);
            }
            delivery.link.connection._register();
        }
    };

    Incoming.prototype.on_transfer = function(frame, receiver) {
        this.next_transfer_id++;
        if (receiver.is_remote_open()) {
            if (this.next_delivery_id === undefined) {
                this.next_delivery_id = frame.performative.delivery_id;
            }
            var current;
            var data;
            if (receiver._incomplete) {
                current = receiver._incomplete;
                if (util_1$1.is_defined(frame.performative.delivery_id) && current.id !== frame.performative.delivery_id) {
                    throw Error('frame sequence error: delivery ' + current.id + ' not complete, got ' + frame.performative.delivery_id);
                }
                data = buffer_1.concat([current.data, frame.payload], current.data.length + frame.payload.length);
            } else if (this.next_delivery_id === frame.performative.delivery_id) {
                current = {'id':frame.performative.delivery_id,
                    'tag':frame.performative.delivery_tag,
                    'format':frame.performative.message_format,
                    'link':receiver,
                    'settled': false,
                    'state': undefined,
                    'remote_settled': frame.performative.settled === undefined ? false : frame.performative.settled,
                    'remote_state': frame.performative.state};
                var self = this;
                current.update = function (settled, state) {
                    var settled_ = settled;
                    if (settled_ === undefined) {
                        settled_ = receiver.local.attach.rcv_settle_mode !== 1;
                    }
                    self.update(current, settled_, state);
                };
                current.accept = function () { this.update(undefined, message_1.accepted().described()); };
                current.release = function (params) {
                    if (params) {
                        this.update(undefined, message_1.modified(params).described());
                    } else {
                        this.update(undefined, message_1.released().described());
                    }
                };
                current.reject = function (error) { this.update(undefined, message_1.rejected({'error':error}).described()); };
                current.modified = function (params) { this.update(undefined, message_1.modified(params).described()); };

                this.deliveries.push(current);
                this.next_delivery_id++;
                data = frame.payload;
            } else {
                //TODO: better error handling
                throw Error('frame sequence error: expected ' + this.next_delivery_id + ', got ' + frame.performative.delivery_id);
            }
            current.incomplete = frame.performative.more;
            if (current.incomplete) {
                receiver._incomplete = current;
                current.data = data;
            } else {
                receiver._incomplete = undefined;
                if (receiver.credit > 0) receiver.credit--;
                else console.error('Received transfer when credit was %d', receiver.credit);
                receiver.delivery_count++;
                var msgctxt = current.format === 0 ? {'message':message_1.decode(data), 'delivery':current} : {'message':data, 'delivery':current, 'format':current.format};
                receiver.dispatch('message', receiver._context(msgctxt));
            }
        } else {
            throw Error('transfer after detach');
        }
    };

    Incoming.prototype.process = function (session) {
        if (this.updated.length > 0) {
            write_dispositions(this.updated);
            this.updated = [];
        }

        // remove any fully settled deliveries:
        this.deliveries.pop_if(function (d) { return d.settled; });

        if (this.max_transfer_id - this.next_transfer_id < (this.window / 2)) {
            session._write_flow();
        }
    };

    Incoming.prototype.on_begin = function (fields) {
        this.remote_window = fields.outgoing_window;
        this.remote_next_transfer_id = fields.next_outgoing_id;
    };

    Incoming.prototype.on_flow = function (fields) {
        this.remote_next_transfer_id = fields.next_outgoing_id;
        this.remote_window = fields.outgoing_window;
    };

    Incoming.prototype.on_disposition = function (fields) {
        var last = fields.last ? fields.last : fields.first;
        for (var i = fields.first; i <= last; i++) {
            var d = this.deliveries.by_id(i);
            if (d && !d.remote_settled) {
                if (fields.state && fields.state !== d.remote_state) {
                    d.remote_state = message_1.unwrap_outcome(fields.state);
                }
                if (fields.settled) {
                    d.remote_settled = fields.settled;
                    d.link.dispatch('settled', d.link._context({'delivery':d}));
                }
            }
        }
    };

    var Session = function (connection, local_channel) {
        this.connection = connection;
        this.outgoing = new Outgoing(connection);
        this.incoming = new Incoming();
        this.state = new endpoint();
        this.local = {'channel': local_channel, 'handles':{}};
        this.local.begin = frames_1.begin({next_outgoing_id:this.outgoing.next_transfer_id,incoming_window:this.incoming.window,outgoing_window:this.outgoing.window});
        this.local.end = frames_1.end();
        this.remote = {'handles':{}};
        this.links = {}; // map by name
        this.options = {};
        Object.defineProperty(this, 'error', { get:  function() { return this.remote.end ? this.remote.end.error : undefined; }});
        this.observers = new EventEmitter$2();
    };
    Session.prototype = Object.create(EventEmitter$2.prototype);
    Session.prototype.constructor = Session;

    Session.prototype._disconnect = function() {
        this.state.disconnected();
        for (var l in this.links) {
            this.links[l]._disconnect();
        }
        if (!this.state.was_open) {
            this.remove();
        }
    };

    Session.prototype._reconnect = function() {
        this.state.reconnect();
        this.outgoing = new Outgoing(this.connection);
        this.incoming = new Incoming();
        this.remote = {'handles':{}};
        for (var l in this.links) {
            this.links[l]._reconnect();
        }
    };

    Session.prototype.dispatch = function(name) {
        log.events('[%s] Session got event: %s', this.connection.options.id, name);
        EventEmitter$2.prototype.emit.apply(this.observers, arguments);
        if (this.listeners(name).length) {
            EventEmitter$2.prototype.emit.apply(this, arguments);
            return true;
        } else {
            return this.connection.dispatch.apply(this.connection, arguments);
        }
    };
    Session.prototype.output = function (frame, payload) {
        this.connection._write_frame(this.local.channel, frame, payload);
    };

    Session.prototype.create_sender = function (name, opts) {
        return this.create_link(name, link$1.Sender, opts);
    };

    Session.prototype.create_receiver = function (name, opts) {
        return this.create_link(name, link$1.Receiver, opts);
    };

    function merge(defaults, specific) {
        for (var f in specific) {
            if (f === 'properties' && defaults.properties) {
                merge(defaults.properties, specific.properties);
            } else {
                defaults[f] = specific[f];
            }
        }
    }

    function attach$1(factory, args, remote_terminus, default_args) {
        var opts = Object.create(default_args || {});
        if (typeof args === 'string') {
            opts[remote_terminus] = args;
        } else if (args) {
            merge(opts, args);
        }
        if (!opts.name) opts.name = util_1$1.generate_uuid();
        var l = factory(opts.name, opts);
        for (var t in {'source':0, 'target':0}) {
            if (opts[t]) {
                if (typeof opts[t] === 'string') {
                    opts[t] = {'address' : opts[t]};
                }
                l['set_' + t](opts[t]);
            }
        }
        if (l.is_sender() && opts.source === undefined) {
            opts.source = l.set_source({});
        }
        if (l.is_receiver() && opts.target === undefined) {
            opts.target = l.set_target({});
        }
        l.attach();
        return l;
    }

    Session.prototype.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else return this.connection.get_option(name, default_value);
    };

    Session.prototype.attach_sender = function (args) {
        return attach$1(this.create_sender.bind(this), args, 'target', this.get_option('sender_options', {}));
    };
    Session.prototype.open_sender = Session.prototype.attach_sender;//alias

    Session.prototype.attach_receiver = function (args) {
        return attach$1(this.create_receiver.bind(this), args, 'source', this.get_option('receiver_options', {}));
    };
    Session.prototype.open_receiver = Session.prototype.attach_receiver;//alias

    Session.prototype.find_sender = function (filter) {
        return this.find_link(util_1$1.sender_filter(filter));
    };

    Session.prototype.find_receiver = function (filter) {
        return this.find_link(util_1$1.receiver_filter(filter));
    };

    Session.prototype.find_link = function (filter) {
        for (var name in this.links) {
            var link = this.links[name];
            if (filter(link)) return link;
        }
        return undefined;
    };

    Session.prototype.each_receiver = function (action, filter) {
        this.each_link(action, util_1$1.receiver_filter(filter));
    };

    Session.prototype.each_sender = function (action, filter) {
        this.each_link(action, util_1$1.sender_filter(filter));
    };

    Session.prototype.each_link = function (action, filter) {
        for (var name in this.links) {
            var link = this.links[name];
            if (filter === undefined || filter(link)) action(link);
        }
    };

    Session.prototype.create_link = function (name, constructor, opts) {
        var i = 0;
        while (this.local.handles[i]) i++;
        var l = new constructor(this, name, i, opts);
        this.links[name] = l;
        this.local.handles[i] = l;
        return l;
    };

    Session.prototype.begin = function () {
        if (this.state.open()) {
            this.connection._register();
        }
    };
    Session.prototype.open = Session.prototype.begin;

    Session.prototype.end = function (error) {
        if (error) this.local.end.error = error;
        if (this.state.close()) {
            this.connection._register();
        }
    };
    Session.prototype.close = Session.prototype.end;

    Session.prototype.is_open = function () {
        return this.connection.is_open() && this.state.is_open();
    };

    Session.prototype.is_remote_open = function () {
        return this.connection.is_remote_open() && this.state.remote_open;
    };

    Session.prototype.is_itself_closed = function () {
        return this.state.is_closed();
    };

    Session.prototype.is_closed = function () {
        return this.connection.is_closed() || this.is_itself_closed();
    };

    function notify_sendable(sender) {
        sender.dispatch('sendable', sender._context());
    }

    function is_sender_sendable(sender) {
        return sender.is_open() && sender.sendable();
    }

    Session.prototype._process = function () {
        do {
            if (this.state.need_open()) {
                this.output(this.local.begin);
            }

            var was_blocked = this.outgoing.deliveries.available() === 0;
            this.outgoing.process();
            if (was_blocked && this.outgoing.deliveries.available()) {
                this.each_sender(notify_sendable, is_sender_sendable);
            }
            this.incoming.process(this);
            for (var k in this.links) {
                this.links[k]._process();
            }

            if (this.state.need_close()) {
                this.output(this.local.end);
            }
        } while (!this.state.has_settled());
    };

    Session.prototype.send = function (sender, tag, data, format) {
        var d = this.outgoing.send(sender, tag, data, format);
        this.connection._register();
        return d;
    };

    Session.prototype._write_flow = function (link) {
        var fields = {'next_incoming_id':this.incoming.next_transfer_id,
            'incoming_window':this.incoming.window,
            'next_outgoing_id':this.outgoing.next_transfer_id,
            'outgoing_window':this.outgoing.window
        };
        this.incoming.max_transfer_id = fields.next_incoming_id + fields.incoming_window;
        if (link) {
            if (link._get_drain()) fields.drain = true;
            fields.delivery_count = link.delivery_count;
            fields.handle = link.local.handle;
            fields.link_credit = link.credit;
        }
        this.output(frames_1.flow(fields));
    };

    Session.prototype.on_begin = function (frame) {
        if (this.state.remote_opened()) {
            if (!this.remote.channel) {
                this.remote.channel = frame.channel;
            }
            this.remote.begin = frame.performative;
            this.outgoing.on_begin(frame.performative);
            this.incoming.on_begin(frame.performative);
            this.open();
            this.dispatch('session_open', this._context());
        } else {
            throw Error('Begin already received');
        }
    };
    Session.prototype.on_end = function (frame) {
        if (this.state.remote_closed()) {
            this.remote.end = frame.performative;
            var error = this.remote.end.error;
            if (error) {
                var handled = this.dispatch('session_error', this._context());
                handled = this.dispatch('session_close', this._context()) || handled;
                if (!handled) {
                    EventEmitter$2.prototype.emit.call(this.connection.container, 'error', new SessionError(error.description, error.condition, this));
                }
            } else {
                this.dispatch('session_close', this._context());
            }
            var self = this;
            var token = this.state.mark();
            browser.nextTick(function () {
                if (self.state.marker === token) {
                    self.close();
                    browser.nextTick(function () { self.remove(); });
                }
            });
        } else {
            throw Error('End already received');
        }
    };

    Session.prototype.on_attach = function (frame) {
        var name = frame.performative.name;
        var link = this.links[name];
        if (!link) {
            // if role is true, peer is receiver, so we are sender
            link = frame.performative.role ? this.create_sender(name) : this.create_receiver(name);
        }
        this.remote.handles[frame.performative.handle] = link;
        link.on_attach(frame);
        link.remote.attach = frame.performative;
    };

    Session.prototype.on_disposition = function (frame) {
        if (frame.performative.role) {
            log.events('[%s] Received disposition for outgoing transfers', this.connection.options.id);
            this.outgoing.on_disposition(frame.performative);
        } else {
            log.events('[%s] Received disposition for incoming transfers', this.connection.options.id);
            this.incoming.on_disposition(frame.performative);
        }
        this.connection._register();
    };

    Session.prototype.on_flow = function (frame) {
        this.outgoing.on_flow(frame.performative);
        this.incoming.on_flow(frame.performative);
        if (util_1$1.is_defined(frame.performative.handle)) {
            this._get_link(frame).on_flow(frame);
        }
        this.connection._register();
    };

    Session.prototype._context = function (c) {
        var context = c ? c : {};
        context.session = this;
        return this.connection._context(context);
    };

    Session.prototype._get_link = function (frame) {
        var handle = frame.performative.handle;
        var link = this.remote.handles[handle];
        if (!link) {
            throw Error('Invalid handle ' + handle);
        }
        return link;
    };

    Session.prototype.on_detach = function (frame) {
        this._get_link(frame).on_detach(frame);
    };

    Session.prototype.remove_link = function (link) {
        delete this.remote.handles[link.remote.handle];
        delete this.local.handles[link.local.handle];
        delete this.links[link.name];
    };

    /**
     * This forcibly removes the session from the parent connection. It
     * should not be called for a link on an active connection, where
     * close() should be used instead.
     */
    Session.prototype.remove = function () {
        this.connection.remove_session(this);
    };

    Session.prototype.on_transfer = function (frame) {
        this.incoming.on_transfer(frame, this._get_link(frame));
    };

    var session = Session;

    var _rollupPluginShim1 = {};

    var _rollupPluginShim1$1 = /*#__PURE__*/Object.freeze({
        'default': _rollupPluginShim1
    });

    function arch() { return "javascript" }
              function type() { return "Browser" }
              function release() { typeof navigator === 'undefined' ? '' : navigator.appVersion; }

    var _rollupPluginShim5 = /*#__PURE__*/Object.freeze({
        arch: arch,
        type: type,
        release: release
    });

    var _rollupPluginShim6 = {};

    var _rollupPluginShim6$1 = /*#__PURE__*/Object.freeze({
        'default': _rollupPluginShim6
    });

    var _rollupPluginShim2 = {};

    var _rollupPluginShim2$1 = /*#__PURE__*/Object.freeze({
        'default': _rollupPluginShim2
    });

    var _rollupPluginShim3 = {};

    var _rollupPluginShim3$1 = /*#__PURE__*/Object.freeze({
        'default': _rollupPluginShim3
    });

    var fs = getCjsExportFromNamespace(_rollupPluginShim1$1);

    var os = getCjsExportFromNamespace(_rollupPluginShim5);

    var path = getCjsExportFromNamespace(_rollupPluginShim6$1);

    var net = getCjsExportFromNamespace(_rollupPluginShim2$1);

    var tls = getCjsExportFromNamespace(_rollupPluginShim3$1);

    var EventEmitter$3 = events.EventEmitter;

    var AMQP_PROTOCOL_ID = 0x00;

    function find_connect_config() {
        var paths;
        if (browser.env.MESSAGING_CONNECT_FILE) {
            paths = [browser.env.MESSAGING_CONNECT_FILE];
        } else {
            paths = [browser.cwd(), path.join(os.homedir(), '.config/messaging'),'/etc/messaging'].map(function (base) { return path.join(base, '/connect.json'); });
        }
        for (var i = 0; i < paths.length; i++) {
            if (fs.existsSync(paths[i])) {
                var obj = JSON.parse(fs.readFileSync(paths[i], 'utf8'));
                log.config('using config from %s: %j', paths[i], obj);
                return obj;
            }
        }
        return {};
    }

    function get_default_connect_config() {
        var config = find_connect_config();
        var options = {};
        if (config.scheme === 'amqps') options.transport = 'tls';
        if (config.host) options.host = config.host;
        if(config.port === 'amqp') options.port = 5762;
        else if(config.port === 'amqps') options.port = 5761;
        else options.port = config.port;
        if (!(config.sasl && config.sasl.enabled === false)) {
            if (config.user) options.username = config.user;
            else options.username = 'anonymous';
            if (config.password) options.password = config.password;
            if (config.sasl_mechanisms) options.sasl_mechanisms = config.sasl_mechanisms;
        }
        if (config.tls) {
            if (config.tls.key) options.key = fs.readFileSync(config.tls.key);
            if (config.tls.cert) options.cert = fs.readFileSync(config.tls.cert);
            if (config.tls.ca) options.ca = [ fs.readFileSync(config.tls.ca) ];
            if (config.verify === false || config.tls.verify === false) options.rejectUnauthorized = false;
        }
        if (options.transport === 'tls') {
            options.servername = options.host;
        }
        return options;
    }

    function get_socket_id(socket) {
        if (socket.get_id_string) return socket.get_id_string();
        return socket.localAddress + ':' + socket.localPort + ' -> ' + socket.remoteAddress + ':' + socket.remotePort;
    }

    function session_per_connection(conn) {
        var ssn = null;
        return {
            'get_session' : function () {
                if (!ssn) {
                    ssn = conn.create_session();
                    ssn.observers.on('session_close', function () { ssn = null; });
                    ssn.begin();
                }
                return ssn;
            }
        };
    }

    function restrict(count, f) {
        if (count) {
            var current = count;
            var reset;
            return function (successful_attempts) {
                if (reset !== successful_attempts) {
                    current = count;
                    reset = successful_attempts;
                }
                if (current--) return f(successful_attempts);
                else return -1;
            };
        } else {
            return f;
        }
    }

    function backoff(initial, max) {
        var delay = initial;
        var reset;
        return function (successful_attempts) {
            if (reset !== successful_attempts) {
                delay = initial;
                reset = successful_attempts;
            }
            var current = delay;
            var next = delay*2;
            delay = max > next ? next : max;
            return current;
        };
    }

    function get_connect_fn(options) {
        if (options.transport === undefined || options.transport === 'tcp') {
            return net.connect;
        } else if (options.transport === 'tls' || options.transport === 'ssl') {
            return tls.connect;
        } else {
            throw Error('Unrecognised transport: ' + options.transport);
        }
    }

    function connection_details(options) {
        var details = {};
        details.connect = options.connect ? options.connect : get_connect_fn(options);
        details.host = options.host ? options.host : 'localhost';
        details.port = options.port ? options.port : 5672;
        details.options = options;
        return details;
    }

    var aliases$1 = [
        'container_id',
        'hostname',
        'max_frame_size',
        'channel_max',
        'idle_time_out',
        'outgoing_locales',
        'incoming_locales',
        'offered_capabilities',
        'desired_capabilities',
        'properties'
    ];

    function remote_property_shortcut$1(name) {
        return function() { return this.remote.open ? this.remote.open[name] : undefined; };
    }

    function connection_fields(fields) {
        var o = {};
        aliases$1.forEach(function (name) {
            if (fields[name] !== undefined) {
                o[name] = fields[name];
            }
        });
        return o;
    }

    var conn_counter = 1;

    var Connection = function (options, container) {
        this.options = {};
        if (options) {
            for (var k in options) {
                this.options[k] = options[k];
            }
            if ((options.transport === 'tls' || options.transport === 'ssl')
                && options.servername === undefined && options.host !== undefined) {
                this.options.servername = options.host;
            }
        } else {
            this.options = get_default_connect_config();
        }
        this.container = container;
        if (!this.options.id) {
            this.options.id = 'connection-' + conn_counter++;
        }
        if (!this.options.container_id) {
            this.options.container_id = container ? container.id : util_1$1.generate_uuid();
        }
        if (!this.options.connection_details) {
            var self = this;
            this.options.connection_details = function() { return connection_details(self.options); };
        }
        var reconnect = this.get_option('reconnect', true);
        if (typeof reconnect === 'boolean' && reconnect) {
            var initial = this.get_option('initial_reconnect_delay', 100);
            var max = this.get_option('max_reconnect_delay', 60000);
            this.options.reconnect = restrict(this.get_option('reconnect_limit'), backoff(initial, max));
        } else if (typeof reconnect === 'number') {
            var fixed = this.options.reconnect;
            this.options.reconnect = restrict(this.get_option('reconnect_limit'), function () { return fixed; });
        }
        this.registered = false;
        this.state = new endpoint();
        this.local_channel_map = {};
        this.remote_channel_map = {};
        this.local = {};
        this.remote = {};
        this.local.open = frames_1.open(connection_fields(this.options));
        this.local.close = frames_1.close({});
        this.session_policy = session_per_connection(this);
        this.amqp_transport = new transport(this.options.id, AMQP_PROTOCOL_ID, frames_1.TYPE_AMQP, this);
        this.sasl_transport = undefined;
        this.transport = this.amqp_transport;
        this.conn_established_counter = 0;
        this.heartbeat_out = undefined;
        this.heartbeat_in = undefined;
        this.abort_idle = false;
        this.socket_ready = false;
        this.scheduled_reconnect = undefined;
        this.default_sender = undefined;
        this.closed_with_non_fatal_error = false;

        for (var i in aliases$1) {
            var f = aliases$1[i];
            Object.defineProperty(this, f, { get: remote_property_shortcut$1(f) });
        }
        Object.defineProperty(this, 'error', { get:  function() { return this.remote.close ? this.remote.close.error : undefined; }});
    };

    Connection.prototype = Object.create(EventEmitter$3.prototype);
    Connection.prototype.constructor = Connection;
    Connection.prototype.dispatch = function(name) {
        log.events('[%s] Connection got event: %s', this.options.id, name);
        if (this.listeners(name).length) {
            EventEmitter$3.prototype.emit.apply(this, arguments);
            return true;
        } else if (this.container) {
            return this.container.dispatch.apply(this.container, arguments);
        } else {
            return false;
        }
    };

    Connection.prototype._disconnect = function() {
        this.state.disconnected();
        for (var k in this.local_channel_map) {
            this.local_channel_map[k]._disconnect();
        }
        this.socket_ready = false;
    };

    Connection.prototype._reconnect = function() {
        if (this.abort_idle) {
            this.abort_idle = false;
            this.local.close.error = undefined;
            this.state = new endpoint();
            this.state.open();
        }

        this.state.reconnect();
        this._reset_remote_state();
    };

    Connection.prototype._reset_remote_state = function() {
        //reset transport
        this.amqp_transport = new transport(this.options.id, AMQP_PROTOCOL_ID, frames_1.TYPE_AMQP, this);
        this.sasl_transport = undefined;
        this.transport = this.amqp_transport;

        //reset remote endpoint state
        this.remote = {};
        //reset sessions:
        this.remote_channel_map = {};
        for (var k in this.local_channel_map) {
            this.local_channel_map[k]._reconnect();
        }
    };

    Connection.prototype.connect = function () {
        this.is_server = false;
        this.abort_idle = false;
        this._reset_remote_state();
        this._connect(this.options.connection_details(this.conn_established_counter));
        this.open();
        return this;
    };

    Connection.prototype.reconnect = function () {
        this.scheduled_reconnect = undefined;
        log.reconnect('[%s] reconnecting...', this.options.id);
        this._reconnect();
        this._connect(this.options.connection_details(this.conn_established_counter));
        browser.nextTick(this._process.bind(this));
        return this;
    };

    Connection.prototype._connect = function (details) {
        if (details.connect) {
            this.init(details.connect(details.port, details.host, details.options, this.connected.bind(this)));
        } else {
            this.init(get_connect_fn(details)(details.port, details.host, details.options, this.connected.bind(this)));
        }
        return this;
    };

    Connection.prototype.accept = function (socket) {
        this.is_server = true;
        log.io('[%s] client accepted: %s', this.id, get_socket_id(socket));
        this.socket_ready = true;
        return this.init(socket);
    };


    Connection.prototype.abort_socket = function (socket) {
        if (socket === this.socket) {
            log.io('[%s] aborting socket', this.options.id);
            this.socket.end();
            this.socket.removeAllListeners('data');
            this.socket.removeAllListeners('error');
            this.socket.removeAllListeners('end');
            this._disconnected();
        }
    };

    Connection.prototype.init = function (socket) {
        this.socket = socket;
        if (this.get_option('tcp_no_delay', false) && this.socket.setNoDelay) {
            this.socket.setNoDelay(true);
        }
        this.socket.on('data', this.input.bind(this));
        this.socket.on('error', this.on_error.bind(this));
        this.socket.on('end', this.eof.bind(this));

        if (this.is_server) {
            var mechs;
            if (this.container && Object.getOwnPropertyNames(this.container.sasl_server_mechanisms).length) {
                mechs = this.container.sasl_server_mechanisms;
            }
            if (this.socket.encrypted && this.socket.authorized && this.get_option('enable_sasl_external', false)) {
                mechs = sasl.server_add_external(mechs ? util_1$1.clone(mechs) : {});
            }
            if (mechs) {
                if (mechs.ANONYMOUS !== undefined && !this.get_option('require_sasl', false)) {
                    this.sasl_transport = new sasl.Selective(this, mechs);
                } else {
                    this.sasl_transport = new sasl.Server(this, mechs);
                }
            } else {
                if (!this.get_option('disable_sasl', false)) {
                    var anon = sasl.server_mechanisms();
                    anon.enable_anonymous();
                    this.sasl_transport = new sasl.Selective(this, anon);
                }
            }
        } else {
            var mechanisms = this.get_option('sasl_mechanisms');
            if (!mechanisms) {
                var username = this.get_option('username');
                var password = this.get_option('password');
                var token = this.get_option('token');
                if (username) {
                    mechanisms = sasl.client_mechanisms();
                    if (password) mechanisms.enable_plain(username, password);
                    else if (token) mechanisms.enable_xoauth2(username, token);
                    else mechanisms.enable_anonymous(username);
                }
            }
            if (this.socket.encrypted && this.options.cert && this.get_option('enable_sasl_external', false)) {
                if (!mechanisms) mechanisms = sasl.client_mechanisms();
                mechanisms.enable_external();
            }

            if (mechanisms) {
                this.sasl_transport = new sasl.Client(this, mechanisms, this.options.sasl_init_hostname || this.options.servername || this.options.host);
            }
        }
        this.transport = this.sasl_transport ? this.sasl_transport : this.amqp_transport;
        return this;
    };

    Connection.prototype.attach_sender = function (options) {
        return this.session_policy.get_session().attach_sender(options);
    };
    Connection.prototype.open_sender = Connection.prototype.attach_sender;//alias

    Connection.prototype.attach_receiver = function (options) {
        if (this.get_option('tcp_no_delay', true) && this.socket.setNoDelay) {
            this.socket.setNoDelay(true);
        }
        return this.session_policy.get_session().attach_receiver(options);
    };
    Connection.prototype.open_receiver = Connection.prototype.attach_receiver;//alias

    Connection.prototype.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else if (this.container) return this.container.get_option(name, default_value);
        else return default_value;
    };

    Connection.prototype.send = function(msg) {
        if (this.default_sender === undefined) {
            this.default_sender = this.open_sender({target:{}});
        }
        return this.default_sender.send(msg);
    };

    Connection.prototype.connected = function () {
        this.socket_ready = true;
        this.conn_established_counter++;
        log.io('[%s] connected %s', this.options.id, get_socket_id(this.socket));
        this.output();
    };

    Connection.prototype.sasl_failed = function (text, condition) {
        this.transport_error = new errors.ConnectionError(text, condition ? condition : 'amqp:unauthorized-access', this);
        this._handle_error();
        this.socket.end();
    };

    Connection.prototype._is_fatal = function (error_condition) {
        var non_fatal = this.get_option('non_fatal_errors', ['amqp:connection:forced']);
        return non_fatal.indexOf(error_condition) < 0;
    };

    Connection.prototype._handle_error = function () {
        var error = this.get_error();
        if (error) {
            var handled = this.dispatch('connection_error', this._context({error:error}));
            handled = this.dispatch('connection_close', this._context({error:error})) || handled;

            if (!this._is_fatal(error.condition)) {
                this.closed_with_non_fatal_error = true;
            } else if (!handled) {
                this.dispatch('error', new errors.ConnectionError(error.description, error.condition, this));
            }
            return true;
        } else {
            return false;
        }
    };

    Connection.prototype.get_error = function () {
        if (this.transport_error) return this.transport_error;
        if (this.remote.close && this.remote.close.error) {
            return new errors.ConnectionError(this.remote.close.error.description, this.remote.close.error.condition, this);
        }
        return undefined;
    };

    Connection.prototype._get_peer_details = function () {
        var s = '';
        if (this.remote.open && this.remote.open.container) {
            s += this.remote.open.container + ' ';
        }
        if (this.remote.open && this.remote.open.properties) {
            s += JSON.stringify(this.remote.open.properties);
        }
        return s;
    };

    Connection.prototype.output = function () {
        try {
            if (this.socket && this.socket_ready) {
                if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
                this.transport.write(this.socket);
                if (((this.is_closed() && this.state.has_settled()) || this.abort_idle || this.transport_error) && !this.transport.has_writes_pending()) {
                    this.socket.end();
                } else if (this.is_open() && this.remote.open.idle_time_out) {
                    this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
                }
                if (this.local.open.idle_time_out && this.heartbeat_in === undefined) {
                    this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);
                }
            }
        } catch (e) {
            this.saved_error = e;
            if (e.name === 'ProtocolError') {
                console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details() + ' ' + e.name);
                this.dispatch('protocol_error', e) || console.error('[' + this.options.id + '] error on write: ' + e + ' ' + this._get_peer_details());
            } else {
                this.dispatch('error', e);
            }
            this.socket.end();
        }
    };

    function byte_to_hex(value) {
        if (value < 16) return '0x0' + Number(value).toString(16);
        else return '0x' + Number(value).toString(16);
    }

    function buffer_to_hex(buffer) {
        var bytes = [];
        for (var i = 0; i < buffer.length; i++) {
            bytes.push(byte_to_hex(buffer[i]));
        }
        return bytes.join(',');
    }

    Connection.prototype.input = function (buff) {
        var buffer;
        try {
            if (this.heartbeat_in) clearTimeout(this.heartbeat_in);
            log.io('[%s] read %d bytes', this.options.id, buff.length);
            if (this.previous_input) {
                buffer = buffer_1.concat([this.previous_input, buff], this.previous_input.length + buff.length);
                this.previous_input = null;
            } else {
                buffer = buff;
            }
            var read = this.transport.read(buffer, this);
            if (read < buffer.length) {
                this.previous_input = buffer.slice(read);
            }
            if (this.local.open.idle_time_out) this.heartbeat_in = setTimeout(this.idle.bind(this), this.local.open.idle_time_out);
            if (this.transport.has_writes_pending()) {
                this.output();
            } else if (this.is_closed() && this.state.has_settled()) {
                this.socket.end();
            } else if (this.is_open() && this.remote.open.idle_time_out && !this.heartbeat_out) {
                this.heartbeat_out = setTimeout(this._write_frame.bind(this), this.remote.open.idle_time_out / 2);
            }
        } catch (e) {
            this.saved_error = e;
            if (e.name === 'ProtocolError') {
                this.dispatch('protocol_error', e) ||
                    console.error('[' + this.options.id + '] error on read: ' + e + ' ' + this._get_peer_details() + ' (buffer:' + buffer_to_hex(buffer) + ')');
            } else {
                this.dispatch('error', e);
            }
            this.socket.end();
        }

    };

    Connection.prototype.idle = function () {
        if (!this.is_closed()) {
            this.abort_idle = true;
            this.closed_with_non_fatal_error = true;
            this.local.close.error = {condition:'amqp:resource-limit-exceeded', description:'max idle time exceeded'};
            this.close();
            setTimeout(this.abort_socket.bind(this, this.socket), 1000);
        }
    };

    Connection.prototype.on_error = function (e) {
        this._disconnected(e);
    };

    Connection.prototype.eof = function (e) {
        var error = e || this.saved_error;
        this.saved_error = undefined;
        this._disconnected(error);
    };

    Connection.prototype._disconnected = function (error) {
        if (this.heartbeat_out) {
            clearTimeout(this.heartbeat_out);
            this.heartbeat_out = undefined;
        }
        if (this.heartbeat_in) {
            clearTimeout(this.heartbeat_in);
            this.heartbeat_in = undefined;
        }
        var was_closed_with_non_fatal_error = this.closed_with_non_fatal_error;
        if (this.closed_with_non_fatal_error) {
            this.closed_with_non_fatal_error = false;
            if (this.options.reconnect) this.open();
        }
        if ((!this.is_closed() || was_closed_with_non_fatal_error) && this.scheduled_reconnect === undefined) {
            this._disconnect();
            var disconnect_ctxt = {};
            if (error) {
                disconnect_ctxt.error = error;
            }
            if (!this.is_server && !this.transport_error && this.options.reconnect) {
                var delay = this.options.reconnect(this.conn_established_counter);
                if (delay >= 0) {
                    log.reconnect('[%s] Scheduled reconnect in ' + delay + 'ms', this.options.id);
                    this.scheduled_reconnect = setTimeout(this.reconnect.bind(this), delay);
                    disconnect_ctxt.reconnecting = true;
                } else {
                    disconnect_ctxt.reconnecting = false;
                }
            }
            if (!this.dispatch('disconnected', this._context(disconnect_ctxt))) {
                console.warn('[' + this.options.id + '] disconnected %s', disconnect_ctxt.error || '');
            }
        }
    };

    Connection.prototype.open = function () {
        if (this.state.open()) {
            this._register();
        }
    };

    Connection.prototype.close = function (error) {
        if (error) this.local.close.error = error;
        if (this.state.close()) {
            this._register();
        }
    };

    Connection.prototype.is_open = function () {
        return this.state.is_open();
    };

    Connection.prototype.is_remote_open = function () {
        return this.state.remote_open;
    };

    Connection.prototype.is_closed = function () {
        return this.state.is_closed();
    };

    Connection.prototype.create_session = function () {
        var i = 0;
        while (this.local_channel_map[i]) i++;
        var session$1 = new session(this, i);
        this.local_channel_map[i] = session$1;
        return session$1;
    };

    Connection.prototype.find_sender = function (filter) {
        return this.find_link(util_1$1.sender_filter(filter));
    };

    Connection.prototype.find_receiver = function (filter) {
        return this.find_link(util_1$1.receiver_filter(filter));
    };

    Connection.prototype.find_link = function (filter) {
        for (var channel in this.local_channel_map) {
            var session = this.local_channel_map[channel];
            var result = session.find_link(filter);
            if (result) return result;
        }
        return undefined;
    };

    Connection.prototype.each_receiver = function (action, filter) {
        this.each_link(action, util_1$1.receiver_filter(filter));
    };

    Connection.prototype.each_sender = function (action, filter) {
        this.each_link(action, util_1$1.sender_filter(filter));
    };

    Connection.prototype.each_link = function (action, filter) {
        for (var channel in this.local_channel_map) {
            var session = this.local_channel_map[channel];
            session.each_link(action, filter);
        }
    };

    Connection.prototype.on_open = function (frame) {
        if (this.state.remote_opened()) {
            this.remote.open = frame.performative;
            this.open();
            this.dispatch('connection_open', this._context());
        } else {
            throw new errors.ProtocolError('Open already received');
        }
    };

    Connection.prototype.on_close = function (frame) {
        if (this.state.remote_closed()) {
            this.remote.close = frame.performative;
            if (this.remote.close.error) {
                this._handle_error();
            } else {
                this.dispatch('connection_close', this._context());
            }
            if (this.heartbeat_out) clearTimeout(this.heartbeat_out);
            var self = this;
            browser.nextTick(function () {
                self.close();
            });
        } else {
            throw new errors.ProtocolError('Close already received');
        }
    };

    Connection.prototype._register = function () {
        if (!this.registered) {
            this.registered = true;
            browser.nextTick(this._process.bind(this));
        }
    };

    Connection.prototype._process = function () {
        this.registered = false;
        do {
            if (this.state.need_open()) {
                this._write_open();
            }
            for (var k in this.local_channel_map) {
                this.local_channel_map[k]._process();
            }
            if (this.state.need_close()) {
                this._write_close();
            }
        } while (!this.state.has_settled());
    };

    Connection.prototype._write_frame = function (channel, frame, payload) {
        this.amqp_transport.encode(frames_1.amqp_frame(channel, frame, payload));
        this.output();
    };

    Connection.prototype._write_open = function () {
        this._write_frame(0, this.local.open);
    };

    Connection.prototype._write_close = function () {
        this._write_frame(0, this.local.close);
    };

    Connection.prototype.on_begin = function (frame) {
        var session;
        if (frame.performative.remote_channel === null || frame.performative.remote_channel === undefined) {
            //peer initiated
            session = this.create_session();
            session.local.begin.remote_channel = frame.channel;
        } else {
            session = this.local_channel_map[frame.performative.remote_channel];
            if (!session) throw new errors.ProtocolError('Invalid value for remote channel ' + frame.performative.remote_channel);
        }
        session.on_begin(frame);
        this.remote_channel_map[frame.channel] = session;
    };

    Connection.prototype.get_peer_certificate = function() {
        if (this.socket && this.socket.getPeerCertificate) {
            return this.socket.getPeerCertificate();
        } else {
            return undefined;
        }
    };

    Connection.prototype.get_tls_socket = function() {
        if (this.socket && (this.options.transport === 'tls' || this.options.transport === 'ssl')) {
            return this.socket;
        } else {
            return undefined;
        }
    };

    Connection.prototype._context = function (c) {
        var context = c ? c : {};
        context.connection = this;
        if (this.container) context.container = this.container;
        return context;
    };

    Connection.prototype.remove_session = function (session) {
        if (this.remote_channel_map[session.remote.channel] === session) {
            delete this.remote_channel_map[session.remote.channel];
        }
        if (this.local_channel_map[session.local.channel] === session) {
            delete this.local_channel_map[session.local.channel];
        }
    };

    Connection.prototype.remove_all_sessions = function () {
        this.remote_channel_map = {};
        this.local_channel_map = {};
    };

    function delegate_to_session(name) {
        Connection.prototype['on_' + name] = function (frame) {
            var session = this.remote_channel_map[frame.channel];
            if (!session) {
                throw new errors.ProtocolError(name + ' received on invalid channel ' + frame.channel);
            }
            session['on_' + name](frame);
        };
    }

    delegate_to_session('end');
    delegate_to_session('attach');
    delegate_to_session('detach');
    delegate_to_session('transfer');
    delegate_to_session('disposition');
    delegate_to_session('flow');

    var connection = Connection;

    /*
     * Copyright 2018 Red Hat Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the 'License');
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an 'AS IS' BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    var ReceiverEvents;
    (function (ReceiverEvents) {
        /**
         * @property {string} message Raised when a message is received.
         */
        ReceiverEvents['message'] = 'message';
        /**
         * @property {string} receiverOpen Raised when the remote peer indicates the link is
         * open (i.e. attached in AMQP parlance).
         */
        ReceiverEvents['receiverOpen'] = 'receiver_open';
        /**
         * @property {string} receiverDrained Raised when the remote peer
         * indicates that it has drained all credit (and therefore there
         * are no more messages at present that it can send).
         */
        ReceiverEvents['receiverDrained'] = 'receiver_drained';
        /**
         * @property {string} receiverFlow Raised when a flow is received for receiver.
         */
        ReceiverEvents['receiverFlow'] = 'receiver_flow';
        /**
         * @property {string} receiverError Raised when the remote peer
         * closes the receiver with an error. The context may also have an
         * error property giving some information about the reason for the
         * error.
         */
        ReceiverEvents['receiverError'] = 'receiver_error';
        /**
         * @property {string} receiverClose Raised when the remote peer indicates the link is closed.
         */
        ReceiverEvents['receiverClose'] = 'receiver_close';
        /**
         * @property {string} settled Raised when the receiver link receives a disposition.
         */
        ReceiverEvents['settled'] = 'settled';
    })(ReceiverEvents || (ReceiverEvents = {}));

    var SenderEvents;
    (function (SenderEvents) {
        /**
         * @property {string} sendable Raised when the sender has sufficient credit to be able
         * to transmit messages to its peer.
         */
        SenderEvents['sendable'] = 'sendable';
        /**
         * @property {string} senderOpen Raised when the remote peer indicates the link is
         * open (i.e. attached in AMQP parlance).
         */
        SenderEvents['senderOpen'] = 'sender_open';
        /**
         * @property {string} senderDraining Raised when the remote peer
         * requests that the sender drain its credit; sending all
         * available messages within the credit limit and ensuring credit
         * is used up..
         */
        SenderEvents['senderDraining'] = 'sender_draining';
        /**
         * @property {string} senderFlow Raised when a flow is received for sender.
         */
        SenderEvents['senderFlow'] = 'sender_flow';
        /**
         * @property {string} senderError Raised when the remote peer
         * closes the sender with an error. The context may also have an
         * error property giving some information about the reason for the
         * error.
         */
        SenderEvents['senderError'] = 'sender_error';
        /**
         * @property {string} senderClose Raised when the remote peer indicates the link is closed.
         */
        SenderEvents['senderClose'] = 'sender_close';
        /**
         * @property {string} accepted Raised when a sent message is accepted by the peer.
         */
        SenderEvents['accepted'] = 'accepted';
        /**
         * @property {string} released Raised when a sent message is released by the peer.
         */
        SenderEvents['released'] = 'released';
        /**
         * @property {string} rejected Raised when a sent message is rejected by the peer.
         */
        SenderEvents['rejected'] = 'rejected';
        /**
         * @property {string} modified Raised when a sent message is modified by the peer.
         */
        SenderEvents['modified'] = 'modified';
        /**
         * @property {string} settled Raised when the sender link receives a disposition.
         */
        SenderEvents['settled'] = 'settled';
    })(SenderEvents || (SenderEvents = {}));


    var SessionEvents;
    (function (SessionEvents) {
        /**
         * @property {string} sessionOpen Raised when the remote peer indicates the session is
         * open (i.e. attached in AMQP parlance).
         */
        SessionEvents['sessionOpen'] = 'session_open';
        /**
         * @property {string} sessionError Raised when the remote peer receives an error. The context
         * may also have an error property giving some information about the reason for the error.
         */
        SessionEvents['sessionError'] = 'session_error';
        /**
         * @property {string} sessionClose Raised when the remote peer indicates the session is closed.
         */
        SessionEvents['sessionClose'] = 'session_close';
        /**
         * @property {string} settled Raised when the session receives a disposition.
         */
        SessionEvents['settled'] = 'settled';
    })(SessionEvents || (SessionEvents = {}));

    var ConnectionEvents;
    (function (ConnectionEvents) {
        /**
         * @property {string} connectionOpen Raised when the remote peer indicates the connection is open.
         */
        ConnectionEvents['connectionOpen'] = 'connection_open';
        /**
         * @property {string} connectionClose Raised when the remote peer indicates the connection is closed.
         */
        ConnectionEvents['connectionClose'] = 'connection_close';
        /**
         * @property {string} connectionError Raised when the remote peer indicates an error occurred on
         * the connection.
         */
        ConnectionEvents['connectionError'] = 'connection_error';
        /**
         * @property {string} protocolError Raised when a protocol error is received on the underlying socket.
         */
        ConnectionEvents['protocolError'] = 'protocol_error',
        /**
         * @property {string} error Raised when an error is received on the underlying socket.
         */
        ConnectionEvents['error'] = 'error',
        /**
         * @property {string} disconnected Raised when the underlying tcp connection is lost. The context
         * has a reconnecting property which is true if the library is attempting to automatically reconnect
         * and false if it has reached the reconnect limit. If reconnect has not been enabled or if the connection
         * is a tcp server, then the reconnecting property is undefined. The context may also have an error
         * property giving some information about the reason for the disconnect.
         */
        ConnectionEvents['disconnected'] = 'disconnected';
        /**
         * @property {string} settled Raised when the connection receives a disposition.
         */
        ConnectionEvents['settled'] = 'settled';
    })(ConnectionEvents || (ConnectionEvents = {}));

    var eventTypes = {
        ReceiverEvents: ReceiverEvents,
        SenderEvents: SenderEvents,
        SessionEvents: SessionEvents,
        ConnectionEvents: ConnectionEvents
    };

    function nulltransform(data) { return data; }

    function from_arraybuffer(data) {
        if (data instanceof ArrayBuffer) return buffer_1.from(new Uint8Array(data));
        else return buffer_1.from(data);
    }

    function to_typedarray(data) {
        return new Uint8Array(data);
    }

    function wrap(ws) {
        var data_recv = nulltransform;
        var data_send = nulltransform;
        if (ws.binaryType) {
            ws.binaryType = 'arraybuffer';
            data_recv = from_arraybuffer;
            data_send = to_typedarray;
        }
        return {
            end: function() {
                ws.close();
            },
            write: function(data) {
                try {
                    ws.send(data_send(data), {binary:true});
                } catch (e) {
                    ws.onerror(e);
                }
            },
            on: function(event, handler) {
                if (event === 'data') {
                    ws.onmessage = function(msg_evt) {
                        handler(data_recv(msg_evt.data));
                    };
                } else if (event === 'end') {
                    ws.onclose = handler;
                } else if (event === 'error') {
                    ws.onerror = handler;
                } else {
                    console.error('ERROR: Attempt to set unrecognised handler on websocket wrapper: ' + event);
                }
            },
            get_id_string: function() {
                return ws.url;
            }
        };
    }

    var ws = {

        'connect': function(Impl) {
            return function (url, protocols, options) {
                return function () {
                    return {
                        connect: function(port_ignore, host_ignore, options_ignore, callback) {
                            var c = new Impl(url, protocols, options);
                            c.onopen = callback;
                            return wrap(c);
                        }
                    };
                };
            };
        },
        'wrap': wrap
    };

    var filter = {
        selector : function (s) {
            return {'jms-selector':types_1.wrap_described(s, 0x468C00000004)};
        }
    };

    var EventEmitter$4 = events.EventEmitter;

    var Container = function (options) {
        this.options = options ? Object.create(options) : {};
        if (!this.options.id) {
            this.options.id = util_1$1.generate_uuid();
        }
        this.id = this.options.id;
        this.sasl_server_mechanisms = sasl.server_mechanisms();
    };

    Container.prototype = Object.create(EventEmitter$4.prototype);
    Container.prototype.constructor = Container;
    Container.prototype.dispatch = function(name) {
        log.events('[%s] Container got event: ' + name, this.id);
        EventEmitter$4.prototype.emit.apply(this, arguments);
        if (this.listeners(name).length) {
            return true;
        } else {
            return false;
        }
    };

    Container.prototype.connect = function (options) {
        return new connection(options, this).connect();
    };

    Container.prototype.create_connection = function (options) {
        return new connection(options, this);
    };

    Container.prototype.listen = function (options) {
        var container = this;
        var server;
        if (options.transport === undefined || options.transport === 'tcp') {
            server = net.createServer();
            server.on('connection', function (socket) {
                new connection(options, container).accept(socket);
            });
        } else if (options.transport === 'tls' || options.transport === 'ssl') {
            server = tls.createServer(options);
            server.on('secureConnection', function (socket) {
                new connection(options, container).accept(socket);
            });
        } else {
            throw Error('Unrecognised transport: ' + options.transport);
        }
        if (browser.version.match(/v0\.10\.\d+/)) {
            server.listen(options.port, options.host);
        } else {
            server.listen(options);
        }
        return server;
    };

    Container.prototype.create_container = function (options) {
        return new Container(options);
    };

    Container.prototype.get_option = function (name, default_value) {
        if (this.options[name] !== undefined) return this.options[name];
        else return default_value;
    };

    Container.prototype.generate_uuid = util_1$1.generate_uuid;
    Container.prototype.string_to_uuid = util_1$1.string_to_uuid;
    Container.prototype.uuid_to_string = util_1$1.uuid_to_string;

    Container.prototype.websocket_accept = function(socket, options) {
        new connection(options, this).accept(ws.wrap(socket));
    };
    Container.prototype.websocket_connect = ws.connect;
    Container.prototype.filter = filter;
    Container.prototype.types = types_1;
    Container.prototype.message = message_1;
    Container.prototype.sasl = sasl;
    Container.prototype.ReceiverEvents = eventTypes.ReceiverEvents;
    Container.prototype.SenderEvents = eventTypes.SenderEvents;
    Container.prototype.SessionEvents = eventTypes.SessionEvents;
    Container.prototype.ConnectionEvents = eventTypes.ConnectionEvents;

    var container = new Container();

    var log$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * @ignore
     * log statements for container
     */
    exports.container = browser$1("rhea-promise:container");
    /**
     * @ignore
     * log statements for connection
     */
    exports.connection = browser$1("rhea-promise:connection");
    /**
     * @ignore
     * log statements for session
     */
    exports.session = browser$1("rhea-promise:session");
    /**
     * @ignore
     * log statements for sender
     */
    exports.sender = browser$1("rhea-promise:sender");
    /**
     * @ignore
     * log statements for receiver
     */
    exports.receiver = browser$1("rhea-promise:receiver");
    /**
     * @ignore
     * log statements for error
     */
    exports.error = browser$1("rhea-promise:error");
    /**
     * @ignore
     * log statements for error
     */
    exports.eventHandler = browser$1("rhea-promise:eventhandler");
    /**
     * @ignore
     * log statements for error
     */
    exports.contextTranslator = browser$1("rhea-promise:translate");

    });

    unwrapExports(log$1);
    var log_1 = log$1.container;
    var log_2 = log$1.connection;
    var log_3 = log$1.session;
    var log_4 = log$1.sender;
    var log_5 = log$1.receiver;
    var log_6 = log$1.error;
    var log_7 = log$1.eventHandler;
    var log_8 = log$1.contextTranslator;

    var utils = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });


    /**
     * Defines a mapping for Http like response status codes for different status-code values
     * provided by an AMQP broker.
     * @enum AmqpResponseStatusCode
     */
    var AmqpResponseStatusCode;
    (function (AmqpResponseStatusCode) {
        AmqpResponseStatusCode[AmqpResponseStatusCode["Continue"] = 100] = "Continue";
        AmqpResponseStatusCode[AmqpResponseStatusCode["SwitchingProtocols"] = 101] = "SwitchingProtocols";
        AmqpResponseStatusCode[AmqpResponseStatusCode["OK"] = 200] = "OK";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Created"] = 201] = "Created";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Accepted"] = 202] = "Accepted";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NoContent"] = 204] = "NoContent";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ResetContent"] = 205] = "ResetContent";
        AmqpResponseStatusCode[AmqpResponseStatusCode["PartialContent"] = 206] = "PartialContent";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Ambiguous"] = 300] = "Ambiguous";
        AmqpResponseStatusCode[AmqpResponseStatusCode["MultipleChoices"] = 300] = "MultipleChoices";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Moved"] = 301] = "Moved";
        AmqpResponseStatusCode[AmqpResponseStatusCode["MovedPermanently"] = 301] = "MovedPermanently";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Found"] = 302] = "Found";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Redirect"] = 302] = "Redirect";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectMethod"] = 303] = "RedirectMethod";
        AmqpResponseStatusCode[AmqpResponseStatusCode["SeeOther"] = 303] = "SeeOther";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotModified"] = 304] = "NotModified";
        AmqpResponseStatusCode[AmqpResponseStatusCode["UseProxy"] = 305] = "UseProxy";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Unused"] = 306] = "Unused";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RedirectKeepVerb"] = 307] = "RedirectKeepVerb";
        AmqpResponseStatusCode[AmqpResponseStatusCode["TemporaryRedirect"] = 307] = "TemporaryRedirect";
        AmqpResponseStatusCode[AmqpResponseStatusCode["BadRequest"] = 400] = "BadRequest";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Unauthorized"] = 401] = "Unauthorized";
        AmqpResponseStatusCode[AmqpResponseStatusCode["PaymentRequired"] = 402] = "PaymentRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Forbidden"] = 403] = "Forbidden";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotFound"] = 404] = "NotFound";
        AmqpResponseStatusCode[AmqpResponseStatusCode["MethodNotAllowed"] = 405] = "MethodNotAllowed";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotAcceptable"] = 406] = "NotAcceptable";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestTimeout"] = 408] = "RequestTimeout";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Conflict"] = 409] = "Conflict";
        AmqpResponseStatusCode[AmqpResponseStatusCode["Gone"] = 410] = "Gone";
        AmqpResponseStatusCode[AmqpResponseStatusCode["LengthRequired"] = 411] = "LengthRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["PreconditionFailed"] = 412] = "PreconditionFailed";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestUriTooLong"] = 414] = "RequestUriTooLong";
        AmqpResponseStatusCode[AmqpResponseStatusCode["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
        AmqpResponseStatusCode[AmqpResponseStatusCode["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ExpectationFailed"] = 417] = "ExpectationFailed";
        AmqpResponseStatusCode[AmqpResponseStatusCode["UpgradeRequired"] = 426] = "UpgradeRequired";
        AmqpResponseStatusCode[AmqpResponseStatusCode["InternalServerError"] = 500] = "InternalServerError";
        AmqpResponseStatusCode[AmqpResponseStatusCode["NotImplemented"] = 501] = "NotImplemented";
        AmqpResponseStatusCode[AmqpResponseStatusCode["BadGateway"] = 502] = "BadGateway";
        AmqpResponseStatusCode[AmqpResponseStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
        AmqpResponseStatusCode[AmqpResponseStatusCode["GatewayTimeout"] = 504] = "GatewayTimeout";
        AmqpResponseStatusCode[AmqpResponseStatusCode["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
    })(AmqpResponseStatusCode = exports.AmqpResponseStatusCode || (exports.AmqpResponseStatusCode = {}));
    /**
     * Provides a list of predefined (amqp) protocol level properties for an amqp message.
     */
    exports.messageProperties = [
        "message_id", "reply_to", "to", "correlation_id", "content_type", "absolute_expiry_time",
        "group_id", "group_sequence", "reply_to_group_id", "content_encoding", "creation_time", "subject",
        "user_id"
    ];
    /**
     * Provides a list of predefined (amqp) protocol level properties for an amqp message header.
     */
    exports.messageHeader = [
        "first_acquirer", "delivery_count", "ttl", "durable", "priority"
    ];
    /**
     * Determines whether the given error object is like an AmqpError object.
     * @param {object} err The AmqpError object
     * @returns {boolean} result - `true` if it is an AMQP Error; `false` otherwise.
     */
    function isAmqpError(err) {
        if (!err || typeof err !== "object") {
            throw new Error("err is a required parameter and must be of type 'object'.");
        }
        let result = false;
        if (((err.condition && typeof err.condition === "string") && (err.description && typeof err.description === "string"))
            || (err.value && Array.isArray(err.value))
            || (err.constructor && err.constructor.name === "c")) {
            result = true;
        }
        return result;
    }
    exports.isAmqpError = isAmqpError;
    /**
     * A wrapper for setTimeout that resolves a promise after t milliseconds.
     * @param {number} t - The number of milliseconds to be delayed.
     * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
     * @returns {Promise<T>} - Resolved promise
     */
    function delay(t, value) {
        return new Promise((resolve) => setTimeout(() => resolve(value), t));
    }
    exports.delay = delay;
    /**
     * Parses the connection string and returns an object of type T.
     * @param {string} connectionString The connection string to be parsed.
     * @returns {ParsedOutput<T>} ParsedOutput<T>.
     */
    function parseConnectionString(connectionString, options) {
        if (!options)
            options = {};
        const entitySeperator = options.entitySeperator || ";";
        const keyValueSeparator = options.keyValueSeparator || "=";
        return connectionString.split(entitySeperator).reduce((acc, part) => {
            const splitIndex = part.indexOf(keyValueSeparator);
            return Object.assign({}, acc, { [part.substring(0, splitIndex)]: part.substring(splitIndex + 1) });
        }, {});
    }
    exports.parseConnectionString = parseConnectionString;
    /**
     * @ignore
     * Emits an event.
     * @param params parameters needed to emit an event from one of the rhea-promise objects.
     * @returns void
     */
    function emitEvent(params) {
        const emit = () => {
            log$1[params.emitterType]("[%s] %s got event: '%s'. Re-emitting the translated context.", params.connectionId, params.emitterType, params.eventName);
            params.emitter.emit(params.eventName, eventContext.EventContext.translate(params.rheaContext, params.emitter, params.eventName));
        };
        if (params.eventName.indexOf("error") !== -1 && params.emitter.actionInitiated > 0) {
            log$1[params.emitterType]("[%s] %s got event: '%s'. Will re-emit in the next tick, since " +
                "this happened before the promise for create/close was resolved.", params.connectionId, params.emitterType, params.eventName);
            // setTimeout() without any time is equivalent to process.nextTick() and works in node.js and
            // browsers. We wait for a tick to emit error events in general. This should give enough
            // time for promises to resolve on *_open (create) and *_close (close).
            setTimeout(emit);
        }
        else {
            emit();
        }
    }
    exports.emitEvent = emitEvent;

    });

    unwrapExports(utils);
    var utils_1 = utils.AmqpResponseStatusCode;
    var utils_2 = utils.messageProperties;
    var utils_3 = utils.messageHeader;
    var utils_4 = utils.isAmqpError;
    var utils_5 = utils.delay;
    var utils_6 = utils.parseConnectionString;
    var utils_7 = utils.emitEvent;

    var entity = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * Abstract base class for all the entities like Connection, Session, Sender, Receiver in the
     * AMQP protocol.
     * @class Entity
     */
    class Entity extends events.EventEmitter {
        constructor() {
            super();
            /**
             * @property actionInitiated Indicates whether the action of creating or closing an entity has
             * been initiated. Whenever an action has been initiated, the count will be incremented by 1.
             * Whenever the action completes (succeeds/fails) the count will be decremented by 1.
             * Default value: `0`.
             */
            this.actionInitiated = 0;
        }
    }
    exports.Entity = Entity;

    });

    unwrapExports(entity);
    var entity_1 = entity.Entity;

    var operationTimeoutError = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Defines the error that occurs when an operation timeout occurs.
     */
    class OperationTimeoutError extends Error {
        constructor(message) {
            super(message);
            /**
             * Describes the name of the error.
             */
            this.name = "OperationTimeoutError";
            /**
             * Provides a logical amqp error condition.
             */
            this.condition = "amqp:operation-timeout";
            this.description = message;
        }
    }
    exports.OperationTimeoutError = OperationTimeoutError;

    });

    unwrapExports(operationTimeoutError);
    var operationTimeoutError_1 = operationTimeoutError.OperationTimeoutError;

    var link$2 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });






    var LinkType;
    (function (LinkType) {
        LinkType["sender"] = "sender";
        LinkType["receiver"] = "receiver";
    })(LinkType = exports.LinkType || (exports.LinkType = {}));
    class Link extends entity.Entity {
        constructor(type, session, link, options) {
            super();
            this.type = type;
            this._session = session;
            this._link = link;
            this.linkOptions = options;
            this._initializeEventListeners();
        }
        get name() {
            return this._link.name;
        }
        get error() {
            return this._link.error;
        }
        get properties() {
            return this._link.properties;
        }
        get sendSettleMode() {
            return this._link.snd_settle_mode;
        }
        get receiveSettleMode() {
            return this._link.rcv_settle_mode;
        }
        get source() {
            return this._link.source;
        }
        set source(fields) {
            this._link.set_source(fields);
        }
        get target() {
            return this._link.target;
        }
        set target(fields) {
            this._link.set_source(fields);
        }
        get maxMessageSize() {
            return this._link.max_message_size;
        }
        get offeredCapabilities() {
            return this._link.offered_capabilities;
        }
        get desiredCapabilities() {
            return this._link.desired_capabilities;
        }
        get address() {
            return this.source.address;
        }
        get credit() {
            return this._link.credit;
        }
        get session() {
            return this._session;
        }
        get connection() {
            return this._session.connection;
        }
        /**
         * Determines whether the sender link and its underlying session is open.
         * @returns {boolean} `true` open. `false` closed.
         */
        isOpen() {
            let result = false;
            if (this._session.isOpen() && this._link.is_open()) {
                result = true;
            }
            return result;
        }
        /**
         * Determines whether the remote end of the link is open.
         * @return {boolean} boolean `true` - is open; `false` otherwise.
         */
        isRemoteOpen() {
            return this._link.is_remote_open();
        }
        /**
         * Determines whether the link has credit.
         * @return {boolean} boolean `true` - has credit; `false` otherwise.
         */
        hasCredit() {
            return this._link.has_credit();
        }
        /**
         * Determines whether the link is a sender.
         * @return {boolean} boolean `true` - sender; `false` otherwise.
         */
        isSender() {
            return this._link.is_sender();
        }
        /**
         * Determines whether the link is a receiver.
         * @return {boolean} boolean `true` - receiver; `false` otherwise.
         */
        isReceiver() {
            return this._link.is_receiver();
        }
        /**
         * Determines whether both local and remote endpoint for link or it's underlying session
         * or it's underlying connection are closed.
         * Within the "sender_close", "session_close" event handler, if this
         * method returns `false` it means that the local end is still open. It can be useful to
         * determine whether the close was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` if closed, `false` otherwise.
         */
        isClosed() {
            return this._link.is_closed();
        }
        /**
         * Determines whether both local and remote endpoint for just the link itself are closed.
         * Within the "sender_close" event handler, if this method returns `false` it
         * means that the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isItselfClosed() {
            return this._link.is_itself_closed();
        }
        /**
         * Determines whether both local and remote endpoint for session or it's underlying
         * connection are closed.
         *
         * Within the "session_close" event handler, if this method returns `false` it means that
         * the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isSessionClosed() {
            return this._session.isClosed();
        }
        /**
         * Determines whether both local and remote endpoint for just the session itself are closed.
         * Within the "session_close" event handler, if this method returns `false` it means that
         * the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isSessionItselfClosed() {
            return this._session.isItselfClosed();
        }
        /**
         * Removes the underlying amqp link and it's session from the internal map in rhea. Also removes
         * all the event handlers added in the rhea-promise library on the link and it's session.
         * @returns {void} void
         */
        remove() {
            if (this._link) {
                // Remove our listeners and listeners from rhea's link object.
                this.removeAllListeners();
                this._link.removeAllListeners();
                this._link.remove();
            }
            if (this._session) {
                this._session.remove();
            }
        }
        /**
         * Closes the underlying amqp link and session in rhea if open. Also removes all the event
         * handlers added in the rhea-promise library on the link and it's session
         * @return {Promise<void>} Promise<void>
         * - **Resolves** the promise when rhea emits the "sender_close" | "receiver_close" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the
         * "sender_error" | "receiver_error" event while trying to close the amqp link.
         */
        close() {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                this.removeAllListeners();
                yield new Promise((resolve, reject) => {
                    log$1.error("[%s] The %s is open ? -> %s", this.connection.id, this.type, this.isOpen());
                    if (this.isOpen()) {
                        const errorEvent = this.type === LinkType.sender
                            ? container.SenderEvents.senderError
                            : container.ReceiverEvents.receiverError;
                        const closeEvent = this.type === LinkType.sender
                            ? container.SenderEvents.senderClose
                            : container.ReceiverEvents.receiverClose;
                        let onError;
                        let onClose;
                        let waitTimer;
                        const removeListeners = () => {
                            clearTimeout(waitTimer);
                            this.actionInitiated--;
                            this._link.removeListener(errorEvent, onError);
                            this._link.removeListener(closeEvent, onClose);
                        };
                        onClose = (context) => {
                            removeListeners();
                            log$1[this.type]("[%s] Resolving the promise as the amqp %s has been closed.", this.connection.id, this.type);
                            return resolve();
                        };
                        onError = (context) => {
                            removeListeners();
                            log$1.error("[%s] Error occurred while closing amqp %s: %O.", this.connection.id, this.type, context.session.error);
                            return reject(context.session.error);
                        };
                        const actionAfterTimeout = () => {
                            removeListeners();
                            const msg = `Unable to close the amqp %s ${this.name} due to operation timeout.`;
                            log$1.error("[%s] %s", this.connection.id, this.type, msg);
                            return reject(new operationTimeoutError.OperationTimeoutError(msg));
                        };
                        // listeners that we add for completing the operation are added directly to rhea's objects.
                        this._link.once(closeEvent, onClose);
                        this._link.once(errorEvent, onError);
                        waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                        this._link.close();
                        this.actionInitiated++;
                    }
                    else {
                        return resolve();
                    }
                });
                log$1[this.type]("[%s] %s has been closed, now closing it's session.", this.connection.id, this.type);
                return this._session.close();
            });
        }
        /**
         * Adds event listeners for the possible events that can occur on the link object and
         * re-emits the same event back with the received arguments from rhea's event emitter.
         * @private
         * @returns {void} void
         */
        _initializeEventListeners() {
            const events = this.type === LinkType.sender ? container.SenderEvents : container.ReceiverEvents;
            for (const eventName in events) {
                this._link.on(events[eventName], (context) => {
                    const params = {
                        rheaContext: context,
                        emitter: this,
                        eventName: events[eventName],
                        emitterType: this.type,
                        connectionId: this.connection.id
                    };
                    utils.emitEvent(params);
                });
            }
            if (typeof this._link.eventNames === "function") {
                log$1.eventHandler("[%s] rhea-promise '%s' object is listening for events: %o " +
                    "emitted by rhea's '%s' object.", this.connection.id, this.type, this._link.eventNames(), this.type);
            }
            if (typeof this._link.listenerCount === "function") {
                log$1.eventHandler("[%s] ListenerCount for event '%s_error' on rhea's '%s' object is: %d.", this.connection.id, this.type, this.type, this._link.listenerCount(`${this.type}_error`));
            }
        }
    }
    exports.Link = Link;

    });

    unwrapExports(link$2);
    var link_1$1 = link$2.LinkType;
    var link_2 = link$2.Link;

    var receiver = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * Describes the receiver that wraps the rhea receiver.
     * @class Receiver.
     */
    class Receiver extends link$2.Link {
        constructor(session, receiver, options) {
            super(link$2.LinkType.receiver, session, receiver, options);
        }
        get drain() {
            return this._link.drain;
        }
        set drain(value) {
            this._link.drain = value;
        }
        addCredit(credit) {
            this._link.add_credit(credit);
        }
        setCreditWindow(creditWindow) {
            this._link.set_credit_window(creditWindow);
        }
    }
    exports.Receiver = Receiver;

    });

    unwrapExports(receiver);
    var receiver_1 = receiver.Receiver;

    var sender = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    /**
     * Describes the sender that wraps the rhea sender.
     * @class Sender
     */
    class Sender extends link$2.Link {
        constructor(session, sender, options) {
            super(link$2.LinkType.sender, session, sender, options);
        }
        setDrained(drained) {
            this._link.set_drained(drained);
        }
        /**
         * Determines whether the message is sendable.
         * @returns {boolean} `true` Sendable. `false` Not Sendable.
         */
        sendable() {
            return this._link.sendable();
        }
        /**
         * Sends the message
         * @param {Message | Buffer} msg The AMQP message to be sent.
         * @param {Buffer | string} [tag] The optional tag that can be sent
         * @param {number} [format] The format in which the message needs to be sent.
         * @returns {Delivery} Delivery The delivery information about the sent message.
         */
        send(msg, tag, format) {
            return this._link.send(msg, tag, format);
        }
    }
    exports.Sender = Sender;

    });

    unwrapExports(sender);
    var sender_1 = sender.Sender;

    var session$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });







    /**
     * Describes the session that wraps the rhea session.
     * @class Session
     */
    class Session extends entity.Entity {
        constructor(connection, session) {
            super();
            this._connection = connection;
            this._session = session;
            this._initializeEventListeners();
        }
        /**
         * @property {Connection} connection The underlying AMQP connection.
         * @readonly
         */
        get connection() {
            return this._connection;
        }
        get outgoing() {
            return this._session.outgoing;
        }
        get error() {
            return this._session.error;
        }
        /**
         * Determines whether the session and the underlying connection is open.
         * @returns {boolean} result `true` - is open; `false` otherwise.
         */
        isOpen() {
            let result = false;
            if (this._connection.isOpen() && this._session.is_open()) {
                result = true;
            }
            return result;
        }
        /**
         * Determines whether the close from the peer is a response to a locally initiated close request.
         * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
         */
        isClosed() {
            return this._session.is_closed();
        }
        /**
         * Determines whether both local and remote endpoint for just the session itself are closed.
         * Within the "session_close" event handler, if this method returns `false` it means that
         * the local end is still open. It can be useful to determine whether the close
         * was initiated locally under such circumstances.
         *
         * @returns {boolean} `true` - closed, `false` otherwise.
         */
        isItselfClosed() {
            return this._session.is_itself_closed();
        }
        /**
         * Removes the underlying amqp session from the internal map in rhea.
         * Also removes all the event handlers added in the rhea-promise library on the session.
         */
        remove() {
            if (this._session) {
                // Remove our listeners and listeners from rhea's 'session' object.
                this.removeAllListeners();
                this._session.removeAllListeners();
                this._session.remove();
            }
        }
        begin() {
            if (this._session) {
                this._session.begin();
            }
        }
        /**
         * Closes the underlying amqp session in rhea if open. Also removes all the event
         * handlers added in the rhea-promise library on the session
         * @return {Promise<void>} Promise<void>
         * - **Resolves** the promise when rhea emits the "session_close" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "session_error" event while trying
         * to close an amqp session.
         */
        close() {
            this.removeAllListeners();
            return new Promise((resolve, reject) => {
                log$1.error("[%s] The session is open ? -> %s", this.connection.id, this.isOpen());
                if (this.isOpen()) {
                    let onError;
                    let onClose;
                    let waitTimer;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._session.removeListener(container.SessionEvents.sessionError, onError);
                        this._session.removeListener(container.SessionEvents.sessionClose, onClose);
                    };
                    onClose = (context) => {
                        removeListeners();
                        log$1.session("[%s] Resolving the promise as the amqp session has been closed.", this.connection.id);
                        return resolve();
                    };
                    onError = (context) => {
                        removeListeners();
                        log$1.error("[%s] Error occurred while closing amqp session.", this.connection.id, context.session.error);
                        reject(context.session.error);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const msg = `Unable to close the amqp session due to operation timeout.`;
                        log$1.error("[%s] %s", this.connection.id, msg);
                        reject(new operationTimeoutError.OperationTimeoutError(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._session.once(container.SessionEvents.sessionClose, onClose);
                    this._session.once(container.SessionEvents.sessionError, onError);
                    log$1.session("[%s] Calling session.close()", this.connection.id);
                    waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
                    this._session.close();
                    this.actionInitiated++;
                }
                else {
                    return resolve();
                }
            });
        }
        /**
         * Creates an amqp receiver on this session.
         * @param {Session} session The amqp session object on which the receiver link needs to be established.
         * @param {ReceiverOptions} [options] Options that can be provided while creating an amqp receiver.
         * @return {Promise<Receiver>} Promise<Receiver>
         * - **Resolves** the promise with the Receiver object when rhea emits the "receiver_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "receiver_close" event while trying
         * to create an amqp receiver or the operation timeout occurs.
         */
        createReceiver(options) {
            return new Promise((resolve, reject) => {
                if (options &&
                    ((options.onMessage && !options.onError) || (options.onError && !options.onMessage))) {
                    if (options.credit_window !== 0) {
                        // - If the 'onMessage' handler is not provided and the credit_window is not set to 0,
                        // then messages may be lost between the receiver link getting created and the message
                        // handler being attached.
                        // - It can be possible for a service to initially accept the link attach, which would
                        // cause the promise to resolve. However, moments later the service may send a detach
                        // due to some internal or configuration issue. If no error handler is attached, then
                        // the error may fall through.
                        // - Hence it is advised to either provide both 'onMessage' and 'onError' handlers, or
                        // please set the credit_window to `0`, if you want to provide only the 'onError' handler.
                        return reject(new Error("Either provide both 'onMessage' and 'onError' handlers, or pl" +
                            "ease set the credit_window to 0, if you want to provide only the 'onError' " +
                            "handler. This ensures no messages are lost between the receiver getting created " +
                            " and the 'onMessage' handler being added."));
                    }
                }
                // Register session handlers for session_error and session_close if provided.
                // listeners provided by the user in the options object should be added
                // to our (rhea-promise) object.
                if (options && options.onSessionError) {
                    this.on(container.SessionEvents.sessionError, options.onSessionError);
                    log$1.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        "while creating the 'receiver'.", this.connection.id, container.SessionEvents.sessionError);
                }
                if (options && options.onSessionClose) {
                    this.on(container.SessionEvents.sessionClose, options.onSessionClose);
                    log$1.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        " while creating the 'receiver'.", this.connection.id, container.SessionEvents.sessionClose);
                }
                const rheaReceiver = this._session.attach_receiver(options);
                const receiver$1 = new receiver.Receiver(this, rheaReceiver, options);
                receiver$1.actionInitiated++;
                let onOpen;
                let onClose;
                let waitTimer;
                if (options && options.onMessage) {
                    receiver$1.on(container.ReceiverEvents.message, options.onMessage);
                    log$1.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.message);
                }
                if (options && options.onError) {
                    receiver$1.on(container.ReceiverEvents.receiverError, options.onError);
                    log$1.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.receiverError);
                }
                if (options && options.onClose) {
                    receiver$1.on(container.ReceiverEvents.receiverClose, options.onClose);
                    log$1.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.receiverClose);
                }
                if (options && options.onSettled) {
                    receiver$1.on(container.ReceiverEvents.settled, options.onSettled);
                    log$1.receiver("[%s] Added event handler for event '%s' on rhea-promise 'receiver'.", this.connection.id, container.ReceiverEvents.settled);
                }
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    receiver$1.actionInitiated--;
                    rheaReceiver.removeListener(container.ReceiverEvents.receiverOpen, onOpen);
                    rheaReceiver.removeListener(container.ReceiverEvents.receiverClose, onClose);
                };
                onOpen = (context) => {
                    removeListeners();
                    log$1.receiver("[%s] Resolving the promise with amqp receiver '%s'.", this.connection.id, receiver$1.name);
                    return resolve(receiver$1);
                };
                onClose = (context) => {
                    removeListeners();
                    log$1.error("[%s] Error occurred while creating a receiver over amqp connection: %O.", this.connection.id, context.receiver.error);
                    return reject(context.receiver.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to create the amqp receiver ${receiver$1.name} due to ` +
                        `operation timeout.`;
                    log$1.error("[%s] %s", this.connection.id, msg);
                    return reject(new operationTimeoutError.OperationTimeoutError(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                rheaReceiver.once(container.ReceiverEvents.receiverOpen, onOpen);
                rheaReceiver.once(container.ReceiverEvents.receiverClose, onClose);
                waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
            });
        }
        /**
         * Creates an amqp sender on this session.
         * @param {SenderOptions} [options] Options that can be provided while creating an amqp sender.
         * @return {Promise<Sender>} Promise<Sender>
         * - **Resolves** the promise with the Sender object when rhea emits the "sender_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "sender_close" event while trying
         * to create an amqp sender or the operation timeout occurs.
         */
        createSender(options) {
            return new Promise((resolve, reject) => {
                // Register session handlers for session_error and session_close if provided.
                if (options && options.onSessionError) {
                    this.on(container.SessionEvents.sessionError, options.onSessionError);
                    log$1.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        "while creating the sender.", this.connection.id, container.SessionEvents.sessionError);
                }
                if (options && options.onSessionClose) {
                    this.on(container.SessionEvents.sessionClose, options.onSessionClose);
                    log$1.session("[%s] Added event handler for event '%s' on rhea-promise 'session', " +
                        "while creating the sender.", this.connection.id, container.SessionEvents.sessionClose);
                }
                const rheaSender = this._session.attach_sender(options);
                const sender$1 = new sender.Sender(this, rheaSender, options);
                sender$1.actionInitiated++;
                let onSendable;
                let onClose;
                let waitTimer;
                // listeners provided by the user in the options object should be added
                // to our (rhea-promise) object.
                if (options) {
                    if (options.onError) {
                        sender$1.on(container.SenderEvents.senderError, options.onError);
                    }
                    if (options.onClose) {
                        sender$1.on(container.SenderEvents.senderClose, options.onClose);
                    }
                    if (options.onAccepted) {
                        sender$1.on(container.SenderEvents.accepted, options.onAccepted);
                    }
                    if (options.onRejected) {
                        sender$1.on(container.SenderEvents.rejected, options.onRejected);
                    }
                    if (options.onReleased) {
                        sender$1.on(container.SenderEvents.released, options.onReleased);
                    }
                    if (options.onModified) {
                        sender$1.on(container.SenderEvents.modified, options.onModified);
                    }
                }
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    sender$1.actionInitiated--;
                    rheaSender.removeListener(container.SenderEvents.senderOpen, onSendable);
                    rheaSender.removeListener(container.SenderEvents.senderClose, onClose);
                };
                onSendable = (context) => {
                    removeListeners();
                    log$1.sender("[%s] Resolving the promise with amqp sender '%s'.", this.connection.id, sender$1.name);
                    return resolve(sender$1);
                };
                onClose = (context) => {
                    removeListeners();
                    log$1.error("[%s] Error occurred while creating a sender over amqp connection: %O.", this.connection.id, context.sender.error);
                    return reject(context.sender.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to create the amqp sender ${sender$1.name} due to ` +
                        `operation timeout.`;
                    log$1.error("[%s] %s", this.connection.id, msg);
                    return reject(new operationTimeoutError.OperationTimeoutError(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                rheaSender.once(container.SenderEvents.sendable, onSendable);
                rheaSender.once(container.SenderEvents.senderClose, onClose);
                waitTimer = setTimeout(actionAfterTimeout, this.connection.options.operationTimeoutInSeconds * 1000);
            });
        }
        /**
         * Adds event listeners for the possible events that can occur on the session object and
         * re-emits the same event back with the received arguments from rhea's event emitter.
         * @private
         * @returns {void} void
         */
        _initializeEventListeners() {
            for (const eventName in container.SessionEvents) {
                this._session.on(container.SessionEvents[eventName], (context) => {
                    const params = {
                        rheaContext: context,
                        emitter: this,
                        eventName: container.SessionEvents[eventName],
                        emitterType: "session",
                        connectionId: this.connection.id
                    };
                    utils.emitEvent(params);
                });
            }
            // Add event handlers for *_error and *_close events that can be propogated to the session
            // object, if they are not handled at their level. * denotes - Sender and Receiver.
            // Sender
            this._session.on(container.SenderEvents.senderError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderError,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils.emitEvent(params);
            });
            this._session.on(container.SenderEvents.senderClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderClose,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils.emitEvent(params);
            });
            // Receiver
            this._session.on(container.ReceiverEvents.receiverError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverError,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils.emitEvent(params);
            });
            this._session.on(container.ReceiverEvents.receiverClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverClose,
                    emitterType: "session",
                    connectionId: this.connection.id
                };
                utils.emitEvent(params);
            });
            if (typeof this._session.eventNames === "function") {
                log$1.eventHandler("[%s] rhea-promise 'session' object is listening for events: %o " +
                    "emitted by rhea's 'session' object.", this.connection.id, this._session.eventNames());
            }
        }
    }
    exports.Session = Session;

    });

    unwrapExports(session$1);
    var session_1 = session$1.Session;

    var container$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });




    /**
     * An AMQP container from which outgoing connections can be made and/or
     * to which incoming connections can be accepted.
     * @class Container
     */
    class Container extends events.EventEmitter {
        constructor(options) {
            if (!options)
                options = {};
            super();
            if (options.createdInstance) {
                this._container = options.createdInstance;
                delete options.createdInstance;
            }
            else {
                this._container = container.create_container(options);
            }
            this.options = this._container.options;
        }
        get id() {
            return this._container.id;
        }
        get filter() {
            return this._container.filter;
        }
        get types() {
            return this._container.types;
        }
        get message() {
            return this._container.message;
        }
        get sasl() {
            return this._container.sasl;
        }
        get saslServerMechanisms() {
            return this._container.sasl_server_mechanisms;
        }
        createConnection(options) {
            const rheaConnection = this._container.create_connection(options);
            return new connection$1.Connection({ rheaConnection: rheaConnection, container: this });
        }
        connect(options) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                return this.createConnection(options).open();
            });
        }
        listen(options) {
            return this._container.listen(options);
        }
        generateUUid() {
            return this._container.generate_uuid();
        }
        stringToUuid(uuidString) {
            return this._container.string_to_uuid(uuidString);
        }
        uuidToString(buffer) {
            return this._container.uuid_to_string(buffer);
        }
        websocketAccept(socket, options) {
            return this._container.websocket_accept(socket, options);
        }
        websocketConnect(impl) {
            return this._container.websocket_connect(impl);
        }
        static create(options) {
            return new Container(options);
        }
        static copyFromContainerInstance(instance) {
            return new Container({ createdInstance: instance });
        }
    }
    exports.Container = Container;

    });

    unwrapExports(container$1);
    var container_1 = container$1.Container;

    var constants$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Describes the default operation timeout in seconds. Value: `60`.
     */
    exports.defaultOperationTimeoutInSeconds = 60;

    });

    unwrapExports(constants$1);
    var constants_1 = constants$1.defaultOperationTimeoutInSeconds;

    var connection$1 = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });









    // Determines whether the given object is a CreatedRheConnectionOptions object.
    function isCreatedRheaConnectionOptions(obj) {
        return (obj && typeof obj.container === "object" && typeof obj.rheaConnection === "object");
    }
    /**
     * Descibes the AQMP Connection.
     * @class Connection
     */
    class Connection extends entity.Entity {
        /**
         * Creates an instance of the Connection object.
         * @constructor
         * @param {Connection} _connection The connection object from rhea library.
         */
        constructor(options) {
            super();
            if (!options)
                options = {};
            if (options.operationTimeoutInSeconds == undefined) {
                options.operationTimeoutInSeconds = constants$1.defaultOperationTimeoutInSeconds;
            }
            if (isCreatedRheaConnectionOptions(options)) {
                this._connection = options.rheaConnection;
                this.container = options.container;
            }
            else {
                const connectionOptions = options;
                if (connectionOptions.webSocketOptions) {
                    const ws = container.websocket_connect(connectionOptions.webSocketOptions.webSocket);
                    connectionOptions.connection_details = ws(connectionOptions.webSocketOptions.url, connectionOptions.webSocketOptions.protocol, connectionOptions.webSocketOptions.options);
                }
                this._connection = container.create_connection(connectionOptions);
                this.container = container$1.Container.copyFromContainerInstance(this._connection.container);
            }
            this.options = this._connection.options;
            this.options.operationTimeoutInSeconds = options.operationTimeoutInSeconds;
            this._initializeEventListeners();
        }
        /**
         * @property {string} id Returns the connection id.
         * @readonly
         */
        get id() {
            return this._connection.options.id;
        }
        /**
         * @property {Dictionary<any> | undefined} [properties] Provides the connection properties.
         * @readonly
         */
        get properties() {
            return this._connection.properties;
        }
        /**
         * @property {number | undefined} [maxFrameSize] Provides the max frame size.
         * @readonly
         */
        get maxFrameSize() {
            return this._connection.max_frame_size;
        }
        /**
         * @property {number | undefined} [idleTimeout] Provides the idle timeout for the connection.
         * @readonly
         */
        get idleTimeout() {
            return this._connection.idle_time_out;
        }
        /**
         * @property {number | undefined} [channelMax] Provides the maximum number of channels supported.
         * @readonly
         */
        get channelMax() {
            return this._connection.channel_max;
        }
        /**
         * @property {AmqpError | Error | undefined} [error] Provides the last error that occurred on the
         * connection.
         */
        get error() {
            return this._connection.error;
        }
        /**
         * Removes the provided session from the internal map in rhea.
         * Also removes all the event handlers added in the rhea-promise library on the provided session.
         * @param {Session} session The session to be removed.
         */
        removeSession(session) {
            return session.remove();
        }
        /**
         * Creates a new amqp connection.
         * @return {Promise<Connection>} Promise<Connection>
         * - **Resolves** the promise with the Connection object when rhea emits the "connection_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "connection_close" event
         * while trying to establish an amqp connection.
         */
        open() {
            return new Promise((resolve, reject) => {
                if (!this.isOpen()) {
                    let onOpen;
                    let onClose;
                    let waitTimer;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._connection.removeListener(container.ConnectionEvents.connectionOpen, onOpen);
                        this._connection.removeListener(container.ConnectionEvents.connectionClose, onClose);
                        this._connection.removeListener(container.ConnectionEvents.disconnected, onClose);
                    };
                    onOpen = (context) => {
                        removeListeners();
                        log$1.connection("[%s] Resolving the promise with amqp connection.", this.id);
                        return resolve(this);
                    };
                    onClose = (context) => {
                        removeListeners();
                        const err = context.error || context.connection.error || Error('Failed to connect');
                        log$1.error("[%s] Error occurred while establishing amqp connection: %O", this.id, err);
                        return reject(err);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const msg = `Unable to open the amqp connection "${this.id}" due to operation timeout.`;
                        log$1.error("[%s] %s", this.id, msg);
                        return reject(new Error(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._connection.once(container.ConnectionEvents.connectionOpen, onOpen);
                    this._connection.once(container.ConnectionEvents.connectionClose, onClose);
                    this._connection.once(container.ConnectionEvents.disconnected, onClose);
                    waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                    log$1.connection("[%s] Trying to create a new amqp connection.", this.id);
                    this._connection.connect();
                    this.actionInitiated++;
                }
                else {
                    return resolve(this);
                }
            });
        }
        /**
         * Closes the amqp connection.
         * @return {Promise<void>} Promise<void>
         * - **Resolves** the promise when rhea emits the "connection_close" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "connection_error" event while
         * trying to close an amqp connection.
         */
        close() {
            return new Promise((resolve, reject) => {
                log$1.error("[%s] The connection is open ? -> %s", this.id, this.isOpen());
                if (this.isOpen()) {
                    let onClose;
                    let onError;
                    let waitTimer;
                    const removeListeners = () => {
                        clearTimeout(waitTimer);
                        this.actionInitiated--;
                        this._connection.removeListener(container.ConnectionEvents.connectionError, onError);
                        this._connection.removeListener(container.ConnectionEvents.connectionClose, onClose);
                    };
                    onClose = (context) => {
                        removeListeners();
                        log$1.connection("[%s] Resolving the promise as the connection has been successfully closed.", this.id);
                        return resolve();
                    };
                    onError = (context) => {
                        removeListeners();
                        log$1.error("[%s] Error occurred while closing amqp connection: %O.", this.id, context.connection.error);
                        return reject(context.connection.error);
                    };
                    const actionAfterTimeout = () => {
                        removeListeners();
                        const msg = `Unable to close the amqp connection "${this.id}" due to operation timeout.`;
                        log$1.error("[%s] %s", this.id, msg);
                        return reject(new Error(msg));
                    };
                    // listeners that we add for completing the operation are added directly to rhea's objects.
                    this._connection.once(container.ConnectionEvents.connectionClose, onClose);
                    this._connection.once(container.ConnectionEvents.connectionError, onError);
                    waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                    this._connection.close();
                    this.actionInitiated++;
                }
                else {
                    return resolve();
                }
            });
        }
        /**
         * Determines whether the connection is open.
         * @returns {boolean} result `true` - is open; `false` otherwise.
         */
        isOpen() {
            let result = false;
            if (this._connection && this._connection.is_open && this._connection.is_open()) {
                result = true;
            }
            return result;
        }
        /**
         * Clears all the amqp sessions from the internal map maintained in rhea. This does not remove any
         * of the event handlers added in the rhea-promise library. To clear such event handlers, either
         * call remove() or close() on each session
         */
        removeAllSessions() {
            if (this._connection) {
                this._connection.remove_all_sessions();
            }
        }
        /**
         * Determines whether the remote end of the connection is open.
         * @returns {boolean} result `true` - is open; `false` otherwise.
         */
        isRemoteOpen() {
            return this._connection.is_remote_open();
        }
        /**
         * Gets the connection error if present.
         * @returns {ConnectionError | undefined} ConnectionError | undefined
         */
        getError() {
            return this._connection.get_error();
        }
        /**
         * Gets the peer certificate if present.
         * @returns {PeerCertificate | undefined} PeerCertificate | undefined
         */
        getPeerCertificate() {
            return this._connection.get_peer_certificate();
        }
        /**
         * Gets the tls socket if present.
         * @returns {Socket | undefined} Socket | undefined
         */
        getTlsSocket() {
            return this._connection.get_tls_socket();
        }
        /**
         * Determines whether the close from the peer is a response to a locally initiated close request
         * for the connection.
         * @returns {boolean} `true` if close was locally initiated, `false` otherwise.
         */
        wasCloseInitiated() {
            return this._connection.is_closed();
        }
        /**
         * Creates an amqp session on the provided amqp connection.
         * @return {Promise<Session>} Promise<Session>
         * - **Resolves** the promise with the Session object when rhea emits the "session_open" event.
         * - **Rejects** the promise with an AmqpError when rhea emits the "session_close" event while
         * trying to create an amqp session.
         */
        createSession() {
            return new Promise((resolve, reject) => {
                const rheaSession = this._connection.create_session();
                const session = new session$1.Session(this, rheaSession);
                session.actionInitiated++;
                let onOpen;
                let onClose;
                let waitTimer;
                const removeListeners = () => {
                    clearTimeout(waitTimer);
                    session.actionInitiated--;
                    rheaSession.removeListener(container.SessionEvents.sessionOpen, onOpen);
                    rheaSession.removeListener(container.SessionEvents.sessionClose, onClose);
                };
                onOpen = (context) => {
                    removeListeners();
                    log$1.session("[%s] Resolving the promise with amqp session.", this.id);
                    return resolve(session);
                };
                onClose = (context) => {
                    removeListeners();
                    log$1.error("[%s] Error occurred while establishing a session over amqp connection: %O.", this.id, context.session.error);
                    return reject(context.session.error);
                };
                const actionAfterTimeout = () => {
                    removeListeners();
                    const msg = `Unable to create the amqp session due to operation timeout.`;
                    log$1.error("[%s] %s", this.id, msg);
                    return reject(new operationTimeoutError.OperationTimeoutError(msg));
                };
                // listeners that we add for completing the operation are added directly to rhea's objects.
                rheaSession.once(container.SessionEvents.sessionOpen, onOpen);
                rheaSession.once(container.SessionEvents.sessionClose, onClose);
                log$1.session("[%s] Calling amqp session.begin().", this.id);
                waitTimer = setTimeout(actionAfterTimeout, this.options.operationTimeoutInSeconds * 1000);
                rheaSession.begin();
            });
        }
        /**
         * Creates an amqp sender link. It either uses the provided session or creates a new one.
         * @param {SenderOptionsWithSession} options Optional parameters to create a sender link.
         * @return {Promise<Sender>} Promise<Sender>.
         */
        createSender(options) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                if (options && options.session && options.session.createSender) {
                    return options.session.createSender(options);
                }
                const session = yield this.createSession();
                return session.createSender(options);
            });
        }
        /**
         * Creates an amqp receiver link. It either uses the provided session or creates a new one.
         * @param {ReceiverOptionsWithSession} options Optional parameters to create a receiver link.
         * @return {Promise<Receiver>} Promise<Receiver>.
         */
        createReceiver(options) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                if (options && options.session && options.session.createReceiver) {
                    return options.session.createReceiver(options);
                }
                const session = yield this.createSession();
                return session.createReceiver(options);
            });
        }
        /**
         * Creates an amqp sender-receiver link. It either uses the provided session or creates a new one.
         * This method creates a sender-receiver link on the same session. It is useful for management
         * style operations where one may want to send a request and await for response.
         * @param {SenderOptions} senderOptions Parameters to create a sender.
         * @param {ReceiverOptions} receiverOptions Parameters to create a receiver.
         * @param {Session} [session] The optional session on which the sender and receiver links will be
         * created.
         * @return {Promise<ReqResLink>} Promise<ReqResLink>
         */
        createRequestResponseLink(senderOptions, receiverOptions, providedSession) {
            return tslib_es6.__awaiter(this, void 0, void 0, function* () {
                if (!senderOptions) {
                    throw new Error(`Please provide sender options.`);
                }
                if (!receiverOptions) {
                    throw new Error(`Please provide receiver options.`);
                }
                const session = providedSession || (yield this.createSession());
                const [sender, receiver] = yield Promise.all([
                    session.createSender(senderOptions),
                    session.createReceiver(receiverOptions)
                ]);
                log$1.connection("[%s] Successfully created the sender and receiver links on the same session.", this.id);
                return {
                    session: session,
                    sender: sender,
                    receiver: receiver
                };
            });
        }
        /**
         * Adds event listeners for the possible events that can occur on the connection object and
         * re-emits the same event back with the received arguments from rhea's event emitter.
         * @private
         * @returns {void} void
         */
        _initializeEventListeners() {
            for (const eventName in container.ConnectionEvents) {
                this._connection.on(container.ConnectionEvents[eventName], (context) => {
                    const params = {
                        rheaContext: context,
                        emitter: this,
                        eventName: container.ConnectionEvents[eventName],
                        emitterType: "connection",
                        connectionId: this.id
                    };
                    utils.emitEvent(params);
                });
            }
            // Add event handlers for *_error and *_close events that can be propogated to the connection
            // object, if they are not handled at their level. * denotes - Sender, Receiver, Session
            // Sender
            this._connection.on(container.SenderEvents.senderError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderError,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils.emitEvent(params);
            });
            this._connection.on(container.SenderEvents.senderClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SenderEvents.senderClose,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils.emitEvent(params);
            });
            // Receiver
            this._connection.on(container.ReceiverEvents.receiverError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverError,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils.emitEvent(params);
            });
            this._connection.on(container.ReceiverEvents.receiverClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.ReceiverEvents.receiverClose,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils.emitEvent(params);
            });
            // Session
            this._connection.on(container.SessionEvents.sessionError, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SessionEvents.sessionError,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils.emitEvent(params);
            });
            this._connection.on(container.SessionEvents.sessionClose, (context) => {
                const params = {
                    rheaContext: context,
                    emitter: this,
                    eventName: container.SessionEvents.sessionClose,
                    emitterType: "connection",
                    connectionId: this.id
                };
                utils.emitEvent(params);
            });
            if (typeof this._connection.eventNames === "function") {
                log$1.eventHandler("[%s] rhea-promise 'connection' object is listening for events: %o " +
                    "emitted by rhea's 'connection' object.", this.id, this._connection.eventNames());
            }
        }
    }
    exports.Connection = Connection;

    });

    unwrapExports(connection$1);
    var connection_1 = connection$1.Connection;

    var eventContext = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });




    var EventContext;
    (function (EventContext) {
        /**
         * Translates rhea's EventContext into rhea-promise EventContext
         * @param rheaContext The received context from rhea's event emitter
         * @param emitter The rhea-promise equivalent object that is supposed emit the same event
         * @param eventName The name of the event for which the context will be translated
         *
         * @returns EventContext The translated EventContext.
         */
        function translate(rheaContext, emitter, eventName) {
            const connectionId = (rheaContext.connection && rheaContext.connection.options) ? rheaContext.connection.options.id : "";
            log$1.contextTranslator("[%s] Translating the context for event: '%s'.", connectionId, eventName);
            // initialize the result
            const result = Object.assign({ _context: rheaContext }, rheaContext);
            const connection = emitter instanceof connection$1.Connection
                ? emitter
                : emitter.connection;
            // set rhea-promise connection and container
            result.connection = connection;
            result.container = connection.container;
            // set rhea-promise session, sender/receiver.
            if (emitter instanceof link$2.Link) {
                result.session = emitter.session;
                if (emitter.type === link$2.LinkType.receiver && rheaContext.receiver) {
                    result.receiver = emitter;
                }
                else if (emitter.type === link$2.LinkType.sender && rheaContext.sender) {
                    result.sender = emitter;
                }
            }
            else if (emitter instanceof session$1.Session) {
                result.session = emitter;
            }
            return result;
        }
        EventContext.translate = translate;
    })(EventContext = exports.EventContext || (exports.EventContext = {}));

    });

    unwrapExports(eventContext);
    var eventContext_1 = eventContext.EventContext;

    var lib = createCommonjsModule(function (module, exports) {
    // Copyright (c) Microsoft Corporation. All rights reserved.
    // Licensed under the Apache License. See License in the project root for license information.
    Object.defineProperty(exports, "__esModule", { value: true });

    exports.types = container.types;
    exports.message = container.message;
    exports.filter = container.filter;
    exports.uuid_to_string = container.uuid_to_string;
    exports.generate_uuid = container.generate_uuid;
    exports.string_to_uuid = container.string_to_uuid;
    exports.ReceiverEvents = container.ReceiverEvents;
    exports.SenderEvents = container.SenderEvents;
    exports.ConnectionEvents = container.ConnectionEvents;
    exports.SessionEvents = container.SessionEvents;
    exports.Typed = container.Typed;

    exports.EventContext = eventContext.EventContext;

    exports.Container = container$1.Container;

    exports.Connection = connection$1.Connection;

    exports.Session = session$1.Session;

    exports.Receiver = receiver.Receiver;

    exports.Sender = sender.Sender;

    exports.AmqpResponseStatusCode = utils.AmqpResponseStatusCode;
    exports.isAmqpError = utils.isAmqpError;
    exports.delay = utils.delay;
    exports.messageHeader = utils.messageHeader;
    exports.messageProperties = utils.messageProperties;
    exports.parseConnectionString = utils.parseConnectionString;

    });

    unwrapExports(lib);
    var lib_1 = lib.types;
    var lib_2 = lib.message;
    var lib_3 = lib.filter;
    var lib_4 = lib.uuid_to_string;
    var lib_5 = lib.generate_uuid;
    var lib_6 = lib.string_to_uuid;
    var lib_7 = lib.ReceiverEvents;
    var lib_8 = lib.SenderEvents;
    var lib_9 = lib.ConnectionEvents;
    var lib_10 = lib.SessionEvents;
    var lib_11 = lib.Typed;
    var lib_12 = lib.EventContext;
    var lib_13 = lib.Container;
    var lib_14 = lib.Connection;
    var lib_15 = lib.Session;
    var lib_16 = lib.Receiver;
    var lib_17 = lib.Sender;
    var lib_18 = lib.AmqpResponseStatusCode;
    var lib_19 = lib.isAmqpError;
    var lib_20 = lib.delay;
    var lib_21 = lib.messageHeader;
    var lib_22 = lib.messageProperties;
    var lib_23 = lib.parseConnectionString;

    var AsyncLock = function (opts) {
    	opts = opts || {};

    	this.Promise = opts.Promise || Promise;

    	// format: {key : [fn, fn]}
    	// queues[key] = null indicates no job running for key
    	this.queues = {};

    	// domain of current running func {key : fn}
    	this.domains = {};

    	// lock is reentrant for same domain
    	this.domainReentrant = opts.domainReentrant || false;

    	this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
    	this.maxPending = opts.maxPending || AsyncLock.DEFAULT_MAX_PENDING;
    };

    AsyncLock.DEFAULT_TIMEOUT = 0; //Never
    AsyncLock.DEFAULT_MAX_PENDING = 1000;

    /**
     * Acquire Locks
     *
     * @param {String|Array} key 	resource key or keys to lock
     * @param {function} fn 	async function
     * @param {function} cb 	callback function, otherwise will return a promise
     * @param {Object} opts 	options
     */
    AsyncLock.prototype.acquire = function (key, fn, cb, opts) {
    	if (Array.isArray(key)) {
    		return this._acquireBatch(key, fn, cb, opts);
    	}

    	if (typeof (fn) !== 'function') {
    		throw new Error('You must pass a function to execute');
    	}

    	// faux-deferred promise using new Promise() (as Promise.defer is deprecated)
    	var deferredResolve = null;
    	var deferredReject = null;
    	var deferred = null;

    	if (typeof (cb) !== 'function') {
    		opts = cb;
    		cb = null;

    		// will return a promise
    		deferred =  new this.Promise(function(resolve, reject) {
    			deferredResolve = resolve;
    			deferredReject = reject;
    		});
    	}

    	opts = opts || {};

    	var resolved = false;
    	var timer = null;
    	var self = this;

    	var done = function (locked, err, ret) {
    		if (locked) {
    			if (self.queues[key].length === 0) {
    				delete self.queues[key];
    			}
    			delete self.domains[key];
    		}

    		if (!resolved) {
    			if (!deferred) {
    				if (typeof (cb) === 'function') {
    					cb(err, ret);
    				}
    			}
    			else {
    				//promise mode
    				if (err) {
    					deferredReject(err);
    				}
    				else {
    					deferredResolve(ret);
    				}
    			}
    			resolved = true;
    		}

    		if (locked) {
    			//run next func
    			if (!!self.queues[key] && self.queues[key].length > 0) {
    				self.queues[key].shift()();
    			}
    		}
    	};

    	var exec = function (locked) {
    		if (resolved) { // may due to timed out
    			return done(locked);
    		}

    		if (timer) {
    			clearTimeout(timer);
    			timer = null;
    		}

    		if (locked) {
    			self.domains[key] = browser.domain;
    		}

    		// Callback mode
    		if (fn.length === 1) {
    			var called = false;
    			fn(function (err, ret) {
    				if (!called) {
    					called = true;
    					done(locked, err, ret);
    				}
    			});
    		}
    		else {
    			// Promise mode
    			self._promiseTry(function () {
    				return fn();
    			})
    			.then(function(ret){
    				done(locked, undefined, ret);
    			}, function(error){
    				done(locked, error);
    			});
    		}
    	};
    	if (!!browser.domain) {
    		exec = browser.domain.bind(exec);
    	}

    	if (!self.queues[key]) {
    		self.queues[key] = [];
    		exec(true);
    	}
    	else if (self.domainReentrant && !!browser.domain && browser.domain === self.domains[key]) {
    		// If code is in the same domain of current running task, run it directly
    		// Since lock is re-enterable
    		exec(false);
    	}
    	else if (self.queues[key].length >= self.maxPending) {
    		done(false, new Error('Too much pending tasks'));
    	}
    	else {
    		var taskFn = function () {
    			exec(true);
    		};
    		if (opts.skipQueue) {
    			self.queues[key].unshift(taskFn);
    		} else {
    			self.queues[key].push(taskFn);
    		}

    		var timeout = opts.timeout || self.timeout;
    		if (timeout) {
    			timer = setTimeout(function () {
    				timer = null;
    				done(false, new Error('async-lock timed out'));
    			}, timeout);
    		}
    	}

    	if (deferred) {
    		return deferred;
    	}
    };

    /*
     * Below is how this function works:
     *
     * Equivalent code:
     * self.acquire(key1, function(cb){
     *     self.acquire(key2, function(cb){
     *         self.acquire(key3, fn, cb);
     *     }, cb);
     * }, cb);
     *
     * Equivalent code:
     * var fn3 = getFn(key3, fn);
     * var fn2 = getFn(key2, fn3);
     * var fn1 = getFn(key1, fn2);
     * fn1(cb);
     */
    AsyncLock.prototype._acquireBatch = function (keys, fn, cb, opts) {
    	if (typeof (cb) !== 'function') {
    		opts = cb;
    		cb = null;
    	}

    	var self = this;
    	var getFn = function (key, fn) {
    		return function (cb) {
    			self.acquire(key, fn, cb, opts);
    		};
    	};

    	var fnx = fn;
    	keys.reverse().forEach(function (key) {
    		fnx = getFn(key, fnx);
    	});

    	if (typeof (cb) === 'function') {
    		fnx(cb);
    	}
    	else {
    		return new this.Promise(function (resolve, reject) {
    			// check for promise mode in case keys is empty array
    			if (fnx.length === 1) {
    				fnx(function (err, ret) {
    					if (err) {
    						reject(err);
    					}
    					else {
    						resolve(ret);
    					}
    				});
    			} else {
    				resolve(fnx());
    			}
    		});
    	}
    };

    /*
     *	Whether there is any running or pending asyncFunc
     *
     *	@param {String} key
     */
    AsyncLock.prototype.isBusy = function (key) {
    	if (!key) {
    		return Object.keys(this.queues).length > 0;
    	}
    	else {
    		return !!this.queues[key];
    	}
    };

    /**
     * Promise.try() implementation to become independent of Q-specific methods
     */
    AsyncLock.prototype._promiseTry = function(fn) {
    	try {
    		return this.Promise.resolve(fn());
    	} catch (e) {
    		return this.Promise.reject(e);
    	}
    };

    var lib$1 = AsyncLock;

    var asyncLock = lib$1;

    /**
     * A constant that indicates whether the environment is node.js or browser based.
     */
    const isNode = !!browser &&
        !!browser.version &&
        !!browser.versions &&
        !!browser.versions.node;
    /**
     * Parses the connection string and returns an object of type T.
     *
     * Connection strings have the following syntax:
     *
     * ConnectionString ::= Part { ";" Part } [ ";" ] [ WhiteSpace ]
     * Part             ::= [ PartLiteral [ "=" PartLiteral ] ]
     * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]
     * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?
     * WhiteSpace       ::= ? all whitespace characters including \r and \n ?
     *
     * @param {string} connectionString The connection string to be parsed.
     * @returns {ParsedOutput<T>} ParsedOutput<T>.
     */
    function parseConnectionString(connectionString) {
        const output = {};
        const parts = connectionString.trim().split(";");
        for (let part of parts) {
            part = part.trim();
            if (part === "") {
                // parts can be empty
                continue;
            }
            const splitIndex = part.indexOf("=");
            if (splitIndex === -1) {
                throw new Error("Connection string malformed: each part of the connection string must have an `=` assignment.");
            }
            const key = part.substring(0, splitIndex).trim();
            if (key === "") {
                throw new Error("Connection string malformed: missing key for assignment");
            }
            const value = part.substring(splitIndex + 1).trim();
            output[key] = value;
        }
        return output;
    }
    /**
     * Gets a new instance of the async lock with desired settings.
     * @param {AsyncLockOptions} [options] The async lock options.
     * @returns {AsyncLock} AsyncLock
     */
    function getNewAsyncLock(options) {
        return new asyncLock(options);
    }
    /**
     * @constant {AsyncLock} defaultLock The async lock instance with default settings.
     */
    const defaultLock = new asyncLock({ maxPending: 10000 });
    /**
     * Describes a Timeout class that can wait for the specified amount of time and then resolve/reject
     * the promise with the given value.
     * @class Timout
     */
    class Timeout {
        set(t, value) {
            return new Promise((resolve, reject) => {
                this.clear();
                const callback = value ? () => reject(new Error(`${value}`)) : resolve;
                this._timer = setTimeout(callback, t);
            });
        }
        clear() {
            if (this._timer) {
                clearTimeout(this._timer);
            }
        }
        wrap(promise, t, value) {
            const wrappedPromise = this._promiseFinally(promise, () => this.clear());
            const timer = this.set(t, value);
            return Promise.race([wrappedPromise, timer]);
        }
        _promiseFinally(promise, fn) {
            const success = (result) => {
                fn();
                return result;
            };
            const error = (e) => {
                fn();
                return Promise.reject(e);
            };
            return Promise.resolve(promise).then(success, error);
        }
        static set(t, value) {
            return new Timeout().set(t, value);
        }
        static wrap(promise, t, value) {
            return new Timeout().wrap(promise, t, value);
        }
    }
    /**
     * A wrapper for setTimeout that resolves a promise after t milliseconds.
     * @param {number} t - The number of milliseconds to be delayed.
     * @param {T} value - The value to be resolved with after a timeout of t milliseconds.
     * @returns {Promise<T>} - Resolved promise
     */
    function delay(t, value) {
        return new Promise(resolve => setTimeout(() => resolve(value), t));
    }
    /**
     * Generates a random number between the given interval
     * @param {number} min Min number of the range (inclusive).
     * @param {number} max Max number of the range (inclusive).
     */
    function randomNumberFromInterval(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    /*
     * Executes an array of promises sequentially. Inspiration of this method is here:
     * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
     *
     * @param {Array} promiseFactories An array of promise factories(A function that return a promise)
     *
     * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.
     * If not provided then the promise chain starts with undefined.
     *
     * @return A chain of resolved or rejected promises
     */
    function executePromisesSequentially(promiseFactories, kickstart) {
        let result = Promise.resolve(kickstart);
        promiseFactories.forEach(promiseFactory => {
            result = result.then(promiseFactory);
        });
        return result;
    }
    /**
     * Determines whether the given connection string is an iothub connection string.
     * @param {string} connectionString The connection string.
     * @return {boolean} boolean.
     */
    function isIotHubConnectionString(connectionString) {
        connectionString = String(connectionString);
        let result = false;
        const model = parseConnectionString(connectionString);
        if (model &&
            model.HostName &&
            model.SharedAccessKey &&
            model.SharedAccessKeyName) {
            result = true;
        }
        return result;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (ConditionStatusMapper) {
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:timeout"] = 408] = "com.microsoft:timeout";
        ConditionStatusMapper[ConditionStatusMapper["amqp:not-found"] = 404] = "amqp:not-found";
        ConditionStatusMapper[ConditionStatusMapper["amqp:not-implemented"] = 501] = "amqp:not-implemented";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-already-exists"] = 409] = "com.microsoft:entity-already-exists";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:message-lock-lost"] = 410] = "com.microsoft:message-lock-lost";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-lock-lost"] = 410] = "com.microsoft:session-lock-lost";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:no-matching-subscription"] = 500] = "com.microsoft:no-matching-subscription";
        ConditionStatusMapper[ConditionStatusMapper["amqp:link:message-size-exceeded"] = 403] = "amqp:link:message-size-exceeded";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:server-busy"] = 503] = "com.microsoft:server-busy";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-error"] = 400] = "com.microsoft:argument-error";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:argument-out-of-range"] = 400] = "com.microsoft:argument-out-of-range";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:store-lock-lost"] = 410] = "com.microsoft:store-lock-lost";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:session-cannot-be-locked"] = 410] = "com.microsoft:session-cannot-be-locked";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:partition-not-owned"] = 410] = "com.microsoft:partition-not-owned";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:entity-disabled"] = 400] = "com.microsoft:entity-disabled";
        ConditionStatusMapper[ConditionStatusMapper["com.microsoft:publisher-revoked"] = 401] = "com.microsoft:publisher-revoked";
        ConditionStatusMapper[ConditionStatusMapper["amqp:link:stolen"] = 410] = "amqp:link:stolen";
        ConditionStatusMapper[ConditionStatusMapper["amqp:not-allowed"] = 400] = "amqp:not-allowed";
        ConditionStatusMapper[ConditionStatusMapper["amqp:unauthorized-access"] = 401] = "amqp:unauthorized-access";
        ConditionStatusMapper[ConditionStatusMapper["amqp:resource-limit-exceeded"] = 403] = "amqp:resource-limit-exceeded";
    })(exports.ConditionStatusMapper || (exports.ConditionStatusMapper = {}));
    (function (ConditionErrorNameMapper) {
        /**
         * Error is thrown when the address is already in use.
         */
        ConditionErrorNameMapper["com.microsoft:address-already-in-use"] = "AddressAlreadyInUseError";
        /**
         * Error is thrown when the store lock is lost.
         */
        ConditionErrorNameMapper["com.microsoft:store-lock-lost"] = "StoreLockLostError";
        /**
         * Error is thrown when a matching subscription is not found.
         */
        ConditionErrorNameMapper["com.microsoft:no-matching-subscription"] = "NoMatchingSubscriptionError";
        /**
         * Error is thrown when an attempt is made to access a parition that is not owned by the
         * requesting entity.
         */
        ConditionErrorNameMapper["com.microsoft:partition-not-owned"] = "PartitionNotOwnedError";
        /**
         * Error is thrown when access to publisher has been revoked.
         */
        ConditionErrorNameMapper["com.microsoft:publisher-revoked"] = "PublisherRevokedError";
        /**
         * Error is thrown when an attempt is made to create an entity that already exists.
         */
        ConditionErrorNameMapper["com.microsoft:entity-already-exists"] = "MessagingEntityAlreadyExistsError";
        /**
         * Error is thrown when trying to access/connect to a disabled messaging entity.
         */
        ConditionErrorNameMapper["com.microsoft:entity-disabled"] = "MessagingEntityDisabledError";
        /**
         * Error is thrown when the lock on the message is lost.
         */
        ConditionErrorNameMapper["com.microsoft:message-lock-lost"] = "MessageLockLostError";
        /**
         * Error is thrown when the lock on the Azure ServiceBus session is lost.
         */
        ConditionErrorNameMapper["com.microsoft:session-lock-lost"] = "SessionLockLostError";
        /**
         * Error is thrown when the Azure ServiceBus session cannot be locked.
         */
        ConditionErrorNameMapper["com.microsoft:session-cannot-be-locked"] = "SessionCannotBeLockedError";
        /**
         * Error is thrown when an internal server error occured. You may have found a bug?
         */
        ConditionErrorNameMapper["amqp:internal-error"] = "InternalServerError";
        /**
         * Error for signaling general communication errors related to messaging operations.
         */
        ConditionErrorNameMapper["amqp:not-found"] = "ServiceCommunicationError";
        /**
         * Error is thrown when the message is not found.
         */
        ConditionErrorNameMapper["com.microsoft:message-not-found"] = "MessageNotFoundError";
        /**
         * Error is thrown when relay is not found.
         */
        ConditionErrorNameMapper["com.microsoft:relay-not-found"] = "RelayNotFoundError";
        /**
         * Error is thrown when a feature is not implemented yet but the placeholder is present.
         */
        ConditionErrorNameMapper["amqp:not-implemented"] = "NotImplementedError";
        /**
         * Error is thrown when an operation is attempted but is not allowed.
         */
        ConditionErrorNameMapper["amqp:not-allowed"] = "InvalidOperationError";
        /**
         * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
         * Quotas are reset periodically, this operation will have to wait until then.
         * The messaging entity has reached its maximum allowable size.
         * This can happen if the maximum number of receivers (which is 5) has already
         * been opened on a per-consumer group level.
         */
        ConditionErrorNameMapper["amqp:resource-limit-exceeded"] = "QuotaExceededError";
        /**
         * Error is thrown when the connection parameters are wrong and the server refused the connection.
         */
        ConditionErrorNameMapper["amqp:unauthorized-access"] = "UnauthorizedError";
        /**
         * Error is thrown when the connection parameters are wrong and the server refused the connection.
         */
        ConditionErrorNameMapper["com.microsoft:auth-failed"] = "UnauthorizedError";
        /**
         * Error is thrown when the service is unavailable. The operation should be retried.
         */
        ConditionErrorNameMapper["com.microsoft:timeout"] = "ServiceUnavailableError";
        /**
         * Error is thrown when no new messages are received for the specified time.
         */
        ConditionErrorNameMapper["com.microsoft:message-wait-timeout"] = "MessageWaitTimeout";
        /**
         * Error is thrown when timeout happens for the said operation.
         */
        ConditionErrorNameMapper["amqp:operation-timeout"] = "OperationTimeoutError";
        /**
         * Error is thrown when an argument has a value that is out of the admissible range.
         */
        ConditionErrorNameMapper["com.microsoft:argument-out-of-range"] = "ArgumentOutOfRangeError";
        /**
         * Error is thrown when a condition that should have been met in order to execute an operation was not.
         */
        ConditionErrorNameMapper["amqp:precondition-failed"] = "PreconditionFailedError";
        /**
         * Error is thrown when a condition that should have been met in order to execute an operation was not.
         */
        ConditionErrorNameMapper["com.microsoft:precondition-failed"] = "PreconditionFailedError";
        /**
         * Error is thrown when data could not be decoded.
         */
        ConditionErrorNameMapper["amqp:decode-error"] = "DecodeError";
        /**
         * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
         */
        ConditionErrorNameMapper["amqp:invalid-field"] = "InvalidFieldError";
        /**
         * Error is thrown when the client attempted to work with a server entity to which it
         * has no access because another client is working with it.
         */
        ConditionErrorNameMapper["amqp:resource-locked"] = "ResourceLockedError";
        /**
         * Error is thrown when a server entity the client is working with has been deleted.
         */
        ConditionErrorNameMapper["amqp:resource-deleted"] = "ResourceDeletedError";
        /**
         * Error is thrown when the peer sent a frame that is not permitted in the current state.
         */
        ConditionErrorNameMapper["amqp:illegal-state"] = "IllegalStateError";
        /**
         * Error is thrown when the peer cannot send a frame because the smallest encoding of
         * the performative with the currently valid values would be too large to fit within
         * a frame of the agreed maximum frame size.
         */
        ConditionErrorNameMapper["amqp:frame-size-too-small"] = "FrameSizeTooSmallError";
        /**
         * Error is thrown when an operator intervened to detach for some reason.
         */
        ConditionErrorNameMapper["amqp:link:detach-forced"] = "DetachForcedError";
        /**
         * Error is thrown when the peer sent more message transfers than currently allowed on the link.
         */
        ConditionErrorNameMapper["amqp:link:transfer-limit-exceeded"] = "TransferLimitExceededError";
        /**
         * Error is thrown when the message sent is too large: the maximum size is 256Kb.
         */
        ConditionErrorNameMapper["amqp:link:message-size-exceeded"] = "MessageTooLargeError";
        /**
         * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
         */
        ConditionErrorNameMapper["amqp:link:redirect"] = "LinkRedirectError";
        /**
         * Error is thrown when two or more instances connect to the same partition
         * with different epoch values.
         */
        ConditionErrorNameMapper["amqp:link:stolen"] = "ReceiverDisconnectedError";
        /**
         * Error is thrown when the peer violated incoming window for the session.
         */
        ConditionErrorNameMapper["amqp:session:window-violation"] = "SessionWindowViolationError";
        /**
         * Error is thrown when input was received for a link that was detached with an error.
         */
        ConditionErrorNameMapper["amqp:session:errant-link"] = "ErrantLinkError";
        /**
         * Error is thrown when an attach was received using a handle that is already in use for an attached link.
         */
        ConditionErrorNameMapper["amqp:session:handle-in-use"] = "HandleInUseError";
        /**
         * Error is thrown when a frame (other than attach) was received referencing a handle which is not
         * currently in use of an attached link.
         */
        ConditionErrorNameMapper["amqp:session:unattached-handle"] = "UnattachedHandleError";
        /**
         * Error is thrown when an operator intervened to close the connection for some reason.
         */
        ConditionErrorNameMapper["amqp:connection:forced"] = "ConnectionForcedError";
        /**
         * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
         */
        ConditionErrorNameMapper["amqp:connection:framing-error"] = "FramingError";
        /**
         * Error is thrown when the container is no longer available on the current connection.
         */
        ConditionErrorNameMapper["amqp:connection:redirect"] = "ConnectionRedirectError";
        /**
         * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
         */
        ConditionErrorNameMapper["com.microsoft:server-busy"] = "ServerBusyError";
        /**
         * Error is thrown when an incorrect argument was received.
         */
        ConditionErrorNameMapper["com.microsoft:argument-error"] = "ArgumentError";
        /**
         * Error is thrown when server cancels the operation due to an internal issue.
         */
        ConditionErrorNameMapper["com.microsoft:operation-cancelled"] = "OperationCancelledError";
        /**
         * Error is thrown when the client sender does not have enough link credits to send the message.
         */
        ConditionErrorNameMapper["client.sender:not-enough-link-credit"] = "SenderBusyError";
        /**
         * Error is thrown when a low level system error is thrown by node.js.
         * {@link https://nodejs.org/dist/latest-v8.x/docs/api/all.html#errors_class_system_error}
         */
        ConditionErrorNameMapper["system:error"] = "SystemError";
    })(exports.ConditionErrorNameMapper || (exports.ConditionErrorNameMapper = {}));
    (function (ErrorNameConditionMapper) {
        /**
         * Error is thrown when the address is already in use.
         */
        ErrorNameConditionMapper["AddressAlreadyInUseError"] = "com.microsoft:address-already-in-use";
        /**
         * Error is thrown when the store lock is lost.
         */
        ErrorNameConditionMapper["StoreLockLostError"] = "com.microsoft:store-lock-lost";
        /**
         * Error is thrown when a matching subscription is not found.
         */
        ErrorNameConditionMapper["NoMatchingSubscriptionError"] = "com.microsoft:no-matching-subscription";
        /**
         * Error is thrown when an attempt is made to access a parition that is not owned by the
         * requesting entity.
         */
        ErrorNameConditionMapper["PartitionNotOwnedError"] = "com.microsoft:partition-not-owned";
        /**
         * Error is thrown when access to publisher has been revoked.
         */
        ErrorNameConditionMapper["PublisherRevokedError"] = "com.microsoft:publisher-revoked";
        /**
         * Error is thrown when an attempt is made to create an entity that already exists.
         */
        ErrorNameConditionMapper["MessagingEntityAlreadyExistsError"] = "com.microsoft:entity-already-exists";
        /**
         * Error is thrown when trying to access/connect to a disabled messaging entity.
         */
        ErrorNameConditionMapper["MessagingEntityDisabledError"] = "com.microsoft:entity-disabled";
        /**
         * Error is thrown when the lock on the message is lost.
         */
        ErrorNameConditionMapper["MessageLockLostError"] = "com.microsoft:message-lock-lost";
        /**
         * Error is thrown when the lock on the Azure ServiceBus session is lost.
         */
        ErrorNameConditionMapper["SessionLockLostError"] = "com.microsoft:session-lock-lost";
        /**
         * Error is thrown when the Azure ServiceBus session cannot be locked.
         */
        ErrorNameConditionMapper["SessionCannotBeLockedError"] = "com.microsoft:session-cannot-be-locked";
        /**
         * Error is thrown when an internal server error occured. You may have found a bug?
         */
        ErrorNameConditionMapper["InternalServerError"] = "amqp:internal-error";
        /**
         * Error for signaling general communication errors related to messaging operations.
         */
        ErrorNameConditionMapper["ServiceCommunicationError"] = "amqp:not-found";
        /**
         * Error is thrown when message is not found.
         */
        ErrorNameConditionMapper["MessageNotFoundError"] = "com.microsoft:message-not-found";
        /**
         * Error is thrown when relay is not found.
         */
        ErrorNameConditionMapper["RelayNotFoundError"] = "com.microsoft:relay-not-found";
        /**
         * Error is thrown when a feature is not implemented yet but the placeholder is present.
         */
        ErrorNameConditionMapper["NotImplementedError"] = "amqp:not-implemented";
        /**
         * Error is thrown when an operation is attempted but is not allowed.
         */
        ErrorNameConditionMapper["InvalidOperationError"] = "amqp:not-allowed";
        /**
         * Error is thrown the the Azure EventHub/ServiceBus quota has been exceeded.
         * Quotas are reset periodically, this operation will have to wait until then.
         * The messaging entity has reached its maximum allowable size.
         * This can happen if the maximum number of receivers (which is 5) has already
         * been opened on a per-consumer group level.
         */
        ErrorNameConditionMapper["QuotaExceededError"] = "amqp:resource-limit-exceeded";
        /**
         * Error is thrown when the connection parameters are wrong and the server refused the connection.
         */
        ErrorNameConditionMapper["UnauthorizedError"] = "amqp:unauthorized-access";
        /**
         * Error is thrown when the service is unavailable. The operation should be retried.
         */
        ErrorNameConditionMapper["ServiceUnavailableError"] = "com.microsoft:timeout";
        /**
         * Error is thrown when no new messages are received for the specified time.
         */
        ErrorNameConditionMapper["MessageWaitTimeout"] = "com.microsoft:message-wait-timeout";
        /**
         * Error is thrown when timeout happens for the said operation.
         */
        ErrorNameConditionMapper["OperationTimeoutError"] = "amqp:operation-timeout";
        /**
         * Error is thrown when an argument has a value that is out of the admissible range.
         */
        ErrorNameConditionMapper["ArgumentOutOfRangeError"] = "com.microsoft:argument-out-of-range";
        /**
         * Error is thrown when a condition that should have been met in order to execute an operation was not.
         */
        ErrorNameConditionMapper["PreconditionFailedError"] = "amqp:precondition-failed";
        /**
         * Error is thrown when data could not be decoded.
         */
        ErrorNameConditionMapper["DecodeError"] = "amqp:decode-error";
        /**
         * Error is thrown when an invalid field was passed in a frame body, and the operation could not proceed.
         */
        ErrorNameConditionMapper["InvalidFieldError"] = "amqp:invalid-field";
        /**
         * Error is thrown when the client attempted to work with a server entity to which it
         * has no access because another client is working with it.
         */
        ErrorNameConditionMapper["ResourceLockedError"] = "amqp:resource-locked";
        /**
         * Error is thrown when a server entity the client is working with has been deleted.
         */
        ErrorNameConditionMapper["ResourceDeletedError"] = "amqp:resource-deleted";
        /**
         * Error is thrown when the peer sent a frame that is not permitted in the current state.
         */
        ErrorNameConditionMapper["IllegalStateError"] = "amqp:illegal-state";
        /**
         * Error is thrown when the peer cannot send a frame because the smallest encoding of
         * the performative with the currently valid values would be too large to fit within
         * a frame of the agreed maximum frame size.
         */
        ErrorNameConditionMapper["FrameSizeTooSmallError"] = "amqp:frame-size-too-small";
        /**
         * Error is thrown when an operator intervened to detach for some reason.
         */
        ErrorNameConditionMapper["DetachForcedError"] = "amqp:link:detach-forced";
        /**
         * Error is thrown when the peer sent more message transfers than currently allowed on the link.
         */
        ErrorNameConditionMapper["TransferLimitExceededError"] = "amqp:link:transfer-limit-exceeded";
        /**
         * Error is thrown when the message sent is too large: the maximum size is 256Kb.
         */
        ErrorNameConditionMapper["MessageTooLargeError"] = "amqp:link:message-size-exceeded";
        /**
         * Error is thrown when the address provided cannot be resolved to a terminus at the current container.
         */
        ErrorNameConditionMapper["LinkRedirectError"] = "amqp:link:redirect";
        /**
         * Error is thrown when two or more instances connect to the same partition
         * with different epoch values.
         */
        ErrorNameConditionMapper["ReceiverDisconnectedError"] = "amqp:link:stolen";
        /**
         * Error is thrown when the peer violated incoming window for the session.
         */
        ErrorNameConditionMapper["SessionWindowViolationError"] = "amqp:session:window-violation";
        /**
         * Error is thrown when input was received for a link that was detached with an error.
         */
        ErrorNameConditionMapper["ErrantLinkError"] = "amqp:session:errant-link";
        /**
         * Error is thrown when an attach was received using a handle that is already in use for an attached link.
         */
        ErrorNameConditionMapper["HandleInUseError"] = "amqp:session:handle-in-use";
        /**
         * Error is thrown when a frame (other than attach) was received referencing a handle which is not
         * currently in use of an attached link.
         */
        ErrorNameConditionMapper["UnattachedHandleError"] = "amqp:session:unattached-handle";
        /**
         * Error is thrown when an operator intervened to close the connection for some reason.
         */
        ErrorNameConditionMapper["ConnectionForcedError"] = "amqp:connection:forced";
        /**
         * Error is thrown when a valid frame header cannot be formed from the incoming byte stream.
         */
        ErrorNameConditionMapper["FramingError"] = "amqp:connection:framing-error";
        /**
         * Error is thrown when the container is no longer available on the current connection.
         */
        ErrorNameConditionMapper["ConnectionRedirectError"] = "amqp:connection:redirect";
        /**
         * Error is thrown when the server is busy. Callers should wait a while and retry the operation.
         */
        ErrorNameConditionMapper["ServerBusyError"] = "com.microsoft:server-busy";
        /**
         * Error is thrown when an incorrect argument was received.
         */
        ErrorNameConditionMapper["ArgumentError"] = "com.microsoft:argument-error";
        /**
         * Error is thrown when server cancels the operation due to an internal issue.
         */
        ErrorNameConditionMapper["OperationCancelledError"] = "com.microsoft:operation-cancelled";
        /**
         * Error is thrown when the client sender does not have enough link credits to send the message.
         */
        ErrorNameConditionMapper["SenderBusyError"] = "client.sender:not-enough-link-credit";
        /**
         * Error is thrown when a low level system error is thrown by node.js.
         * {@link https://nodejs.org/api/errors.html#errors_class_systemerror}
         */
        ErrorNameConditionMapper["SystemError"] = "system:error";
    })(exports.ErrorNameConditionMapper || (exports.ErrorNameConditionMapper = {}));
    /**
     * Describes the base class for Messaging Error.
     * @class {MessagingError}
     * @extends Error
     */
    class MessagingError extends Error {
        /**
         * @param {string} message The error message that provides more information about the error.
         */
        constructor(message) {
            super(message);
            /**
             * @property {string} name The error name. Default value: "MessagingError".
             */
            this.name = "MessagingError";
            /**
             * @property {boolean} translated Has the error been translated. Default: true.
             */
            this.translated = true;
            /**
             *
             * @property {boolean} retryable Describes whether the error is retryable. Default: true.
             */
            this.retryable = true;
        }
    }
    /**
     * Provides a list of retryable AMQP errors.
     * "InternalServerError", "ServerBusyError", "ServiceUnavailableError", "OperationCancelledError",
     * "SenderBusyError", "MessagingError", "DetachForcedError", "ConnectionForcedError",
     * "TransferLimitExceededError"
     */
    const retryableErrors = [
        "InternalServerError",
        "ServerBusyError",
        "ServiceUnavailableError",
        "OperationCancelledError",
        "SenderBusyError",
        "MessagingError",
        "DetachForcedError",
        "ConnectionForcedError",
        "TransferLimitExceededError"
    ];
    (function (SystemErrorConditionMapper) {
        SystemErrorConditionMapper["ENOTFOUND"] = "amqp:not-found";
        SystemErrorConditionMapper["EBUSY"] = "com.microsoft:server-busy";
        SystemErrorConditionMapper["ECONNREFUSED"] = "amqp:connection:forced";
        SystemErrorConditionMapper["ETIMEDOUT"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ECONNRESET"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENETDOWN"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["EHOSTDOWN"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENETRESET"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENETUNREACH"] = "com.microsoft:timeout";
        SystemErrorConditionMapper["ENONET"] = "com.microsoft:timeout";
    })(exports.SystemErrorConditionMapper || (exports.SystemErrorConditionMapper = {}));
    function isSystemError(err) {
        let result = false;
        if (err.code &&
            typeof err.code === "string" &&
            (err.syscall && typeof err.syscall === "string") &&
            (err.errno && (typeof err.errno === "string" || typeof err.errno === "number"))) {
            result = true;
        }
        return result;
    }
    /**
     * @internal
     * Since browser doesnt differentiate between the various kinds of service communication errors,
     * this utility is used to look at the error target to identify such category of errors.
     * For more information refer to - https://html.spec.whatwg.org/multipage/comms.html#feedback-from-the-protocol
     * @param err object that may contain error information
     */
    function isBrowserWebsocketError(err) {
        let result = false;
        if (!isNode &&
            window &&
            err.type === "error" &&
            err.target instanceof window.WebSocket) {
            result = true;
        }
        return result;
    }
    /**
     * Translates the AQMP error received at the protocol layer or a generic Error into a MessagingError.
     *
     * @param {AmqpError} err The amqp error that was received.
     * @returns {MessagingError} MessagingError object.
     */
    function translate(err) {
        if (err.translated) {
            // already translated
            return err;
        }
        let error = err;
        // Built-in errors like TypeError and RangeError should not be retryable as these indicate issues
        // with user input and not an issue with the Messaging process.
        if (err instanceof TypeError || err instanceof RangeError) {
            error.retryable = false;
            return error;
        }
        if (lib_19(err)) {
            // translate
            const condition = err.condition;
            const description = err.description;
            error = new MessagingError(description);
            if (err.stack)
                error.stack = err.stack;
            error.info = err.info;
            error.condition = condition;
            if (condition) {
                error.name = exports.ConditionErrorNameMapper[condition];
            }
            if (!error.name)
                error.name = "MessagingError";
            if (description &&
                (description.includes("status-code: 404") ||
                    description.match(/The messaging entity .* could not be found.*/i) !== null)) {
                error.name = "MessagingEntityNotFoundError";
            }
            if (retryableErrors.indexOf(error.name) === -1) {
                // not found
                error.retryable = false;
            }
        }
        else if (isSystemError(err)) {
            // translate
            const condition = err.code;
            const description = err.message;
            error = new MessagingError(description);
            if (err.stack)
                error.stack = err.stack;
            if (condition) {
                const amqpErrorCondition = exports.SystemErrorConditionMapper[condition];
                error.name = exports.ConditionErrorNameMapper[amqpErrorCondition];
            }
            if (!error.name)
                error.name = "SystemError";
            if (retryableErrors.indexOf(error.name) === -1) {
                // not found
                error.retryable = false;
            }
        }
        else if (isBrowserWebsocketError(err)) {
            // Translate browser communication errors during opening handshake to generic SeviceCommunicationError
            error = new MessagingError("Websocket connection failed.");
            error.name = exports.ConditionErrorNameMapper[exports.ErrorNameConditionMapper.ServiceCommunicationError];
            error.retryable = false;
        }
        else {
            // Translate a generic error into MessagingError.
            error = new MessagingError(err.message);
            error.stack = err.stack;
        }
        return error;
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @ignore
     * log statements for cbs
     */
    const cbs = browser$1("azure:amqp-common:cbs");
    /**
     * @ignore
     * log statements for error
     */
    const error$1 = browser$1("azure:amqp-common:error");
    /**
     * @ignore
     * log statements for datatransformer
     */
    const transformer = browser$1("azure:amqp-common:datatransformer");
    /**
     * @ignore
     * log statements for messageHeader
     */
    const msgHeader = browser$1("azure:amqp-common:messageHeader");
    /**
     * @ignore
     * log statements for messageProperties
     */
    const msgProperties = browser$1("azure:amqp-common:messageProperties");
    /**
     * @ignore
     * log statements for retry
     */
    const retry = browser$1("azure:amqp-common:retry");
    /**
     * @ignore
     * log statements for reqreslink
     */
    const reqres = browser$1("azure:amqp-common:reqreslink");

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Determines whether the object is a Delivery object.
     * @ignore
     */
    function isDelivery(obj) {
        let result = false;
        if (obj &&
            typeof obj.id === "number" &&
            typeof obj.settled === "boolean" &&
            typeof obj.remote_settled === "boolean" &&
            typeof obj.format === "number") {
            result = true;
        }
        return result;
    }
    (function (RetryOperationType) {
        RetryOperationType["cbsAuth"] = "cbsAuth";
        RetryOperationType["connection"] = "connection";
        RetryOperationType["management"] = "management";
        RetryOperationType["receiverLink"] = "receiverLink";
        RetryOperationType["senderLink"] = "senderLink";
        RetryOperationType["sendMessage"] = "sendMessage";
        RetryOperationType["session"] = "session";
    })(exports.RetryOperationType || (exports.RetryOperationType = {}));
    /**
     * Validates the retry config.
     * @ignore
     */
    function validateRetryConfig(config) {
        if (!config.operation) {
            throw new TypeError("Missing 'operation' in retry configuration");
        }
        if (!config.connectionId) {
            throw new TypeError("Missing 'connectionId' in retry configuration");
        }
        if (!config.operationType) {
            throw new TypeError("Missing 'operationType' in retry configuration");
        }
    }
    function checkNetworkConnection(host) {
        return __awaiter(this, void 0, void 0, function* () {
            {
                return window.navigator.onLine;
            }
        });
    }
    /**
     * It will attempt to linearly retry an operation specified number of times with a specified
     * delay in between each retry. The retries will only happen if the error is retryable.
     *
     * @param {RetryConfig<T>} config Parameters to configure retry operation.
     *
     * @return {Promise<T>} Promise<T>.
     */
    function retry$1(config) {
        return __awaiter(this, void 0, void 0, function* () {
            validateRetryConfig(config);
            if (config.times == undefined)
                config.times = defaultRetryAttempts;
            if (config.delayInSeconds == undefined) {
                config.delayInSeconds = defaultDelayBetweenRetriesInSeconds;
            }
            let lastError;
            let result;
            let success = false;
            for (let i = 0; i < config.times; i++) {
                const j = i + 1;
                retry("[%s] Retry for '%s', attempt number: %d", config.connectionId, config.operationType, j);
                try {
                    result = yield config.operation();
                    success = true;
                    retry("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, j);
                    if (result && !isDelivery(result)) {
                        retry("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
                    }
                    break;
                }
                catch (err) {
                    if (!err.translated) {
                        err = translate(err);
                    }
                    if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                        const isConnected = yield checkNetworkConnection(config.connectionHost);
                        if (!isConnected) {
                            err.name = "ConnectionLostError";
                            err.retryable = true;
                        }
                    }
                    lastError = err;
                    error$1("[%s] Error occured for '%s' in attempt number %d: %O", config.connectionId, config.operationType, j, err);
                    if (lastError && lastError.retryable) {
                        error$1("[%s] Sleeping for %d seconds for '%s'.", config.connectionId, config.delayInSeconds, config.operationType);
                        yield delay(config.delayInSeconds * 1000);
                        continue;
                    }
                    else {
                        break;
                    }
                }
            }
            if (success) {
                return result;
            }
            else {
                throw lastError;
            }
        });
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * Describes an amqp request(sender)-response(receiver) link that is created over an amqp session.
     * @class RequestResponseLink
     */
    class RequestResponseLink {
        /**
         * @constructor
         * @param {Session} session The amqp session.
         * @param {Sender} sender The amqp sender link.
         * @param {Receiver} receiver The amqp receiver link.
         */
        constructor(session, sender, receiver) {
            this.session = session;
            this.sender = sender;
            this.receiver = receiver;
            this.session = session;
            this.sender = sender;
            this.receiver = receiver;
        }
        /**
         * Provides the underlying amqp connection object.
         * @returns {Connection} Connection.
         */
        get connection() {
            return this.session.connection;
        }
        /**
         * Indicates whether the session and the sender and receiver links are all open or closed.
         * @returns {boolean} boolean - `true` - `open`, `false` - `closed`.
         */
        isOpen() {
            return (this.session.isOpen() && this.sender.isOpen() && this.receiver.isOpen());
        }
        /**
         * Sends the given request message and returns the received response. If the operation is not
         * completed in the provided timeout in seconds `default: 10`, then the request will be retried
         * linearly for the provided number of times `default: 3` with the provided delay in seconds
         * `default: 15` between each attempt.
         *
         * @param {Message} request The AMQP (request) message.
         * @param {SendRequestOptions} [options] Options that can be provided while sending a request.
         * @returns {Promise<Message>} Promise<Message> The AMQP (response) message.
         */
        sendRequest(request, options) {
            if (!options)
                options = {};
            if (!options.timeoutInSeconds) {
                options.timeoutInSeconds = 10;
            }
            let count = 0;
            const sendRequestPromise = () => new Promise((resolve, reject) => {
                let waitTimer;
                let timeOver = false;
                count++;
                if (count !== 1) {
                    // Generate a new message_id every time after the first attempt
                    request.message_id = lib_5();
                }
                else if (!request.message_id) {
                    // Set the message_id in the first attempt only if it is not set
                    request.message_id = lib_5();
                }
                // Handle different variations of property names in responses emitted by EventHubs and ServiceBus.
                const getCodeDescriptionAndError = (props) => {
                    if (!props)
                        props = {};
                    return {
                        statusCode: (props[statusCode] ||
                            props.statusCode),
                        statusDescription: (props[statusDescription] ||
                            props.statusDescription),
                        errorCondition: (props[errorCondition] ||
                            props.errorCondition)
                    };
                };
                const messageCallback = (context) => {
                    // remove the event listener as this will be registered next time when someone makes a request.
                    this.receiver.removeListener(lib_7.message, messageCallback);
                    const info = getCodeDescriptionAndError(context.message.application_properties);
                    const responseCorrelationId = context.message.correlation_id;
                    reqres("[%s] %s response: ", this.connection.id, request.to || "$management", context.message);
                    if (info.statusCode > 199 && info.statusCode < 300) {
                        if (request.message_id === responseCorrelationId ||
                            request.correlation_id === responseCorrelationId) {
                            if (!timeOver) {
                                clearTimeout(waitTimer);
                            }
                            reqres("[%s] request-messageId | '%s' == '%s' | response-correlationId.", this.connection.id, request.message_id, responseCorrelationId);
                            return resolve(context.message);
                        }
                        else {
                            error$1("[%s] request-messageId | '%s' != '%s' | response-correlationId. " +
                                "Hence dropping this response and waiting for the next one.", this.connection.id, request.message_id, responseCorrelationId);
                        }
                    }
                    else {
                        const condition = info.errorCondition ||
                            exports.ConditionStatusMapper[info.statusCode] ||
                            "amqp:internal-error";
                        const e = {
                            condition: condition,
                            description: info.statusDescription
                        };
                        const error = translate(e);
                        error$1(error);
                        return reject(error);
                    }
                };
                const actionAfterTimeout = () => {
                    timeOver = true;
                    this.receiver.removeListener(lib_7.message, messageCallback);
                    const address = this.receiver.address || "address";
                    const desc = `The request with message_id "${request.message_id}" to "${address}" ` +
                        `endpoint timed out. Please try again later.`;
                    const e = {
                        condition: exports.ConditionStatusMapper[408],
                        description: desc
                    };
                    return reject(translate(e));
                };
                this.receiver.on(lib_7.message, messageCallback);
                waitTimer = setTimeout(actionAfterTimeout, options.timeoutInSeconds * 1000);
                reqres("[%s] %s request sent: %O", this.connection.id, request.to || "$managment", request);
                this.sender.send(request);
            });
            const config = {
                operation: sendRequestPromise,
                connectionId: this.connection.id,
                operationType: request.to && request.to === cbsEndpoint
                    ? exports.RetryOperationType.cbsAuth
                    : exports.RetryOperationType.management,
                delayInSeconds: options.delayInSeconds,
                times: options.times
            };
            return retry$1(config);
        }
        /**
         * Closes the sender, receiver link and the underlying session.
         * @returns {Promise<void>} Promise<void>
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.sender.close();
                yield this.receiver.close();
                yield this.session.close();
            });
        }
        /**
         * Removes the sender, receiver link and it's underlying session.
         * @returns {void} void
         */
        remove() {
            this.sender.remove();
            this.receiver.remove();
            this.session.remove();
        }
        /**
         * Creates an amqp request/response link.
         *
         * @param {Connection} connection The amqp connection.
         * @param {SenderOptions} senderOptions Options that must be provided to create the sender link.
         * @param {ReceiverOptions} receiverOptions Options that must be provided to create the receiver link.
         * @returns {Promise<RequestResponseLink>} Promise<RequestResponseLink>
         */
        static create(connection, senderOptions, receiverOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                const session = yield connection.createSession();
                const sender = yield session.createSender(senderOptions);
                const receiver = yield session.createReceiver(receiverOptions);
                reqres("[%s] Successfully created the sender and receiver links on the same session.", connection.id);
                return new RequestResponseLink(session, sender, receiver);
            });
        }
    }

    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    var isBuffer = function isBuffer (obj) {
      return obj != null && obj.constructor != null &&
        typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    };

    var buffer$1 = createCommonjsModule(function (module, exports) {



    var customInspectSymbol =
      (typeof Symbol === 'function' && typeof Symbol.for === 'function')
        ? Symbol.for('nodejs.util.inspect.custom')
        : null;

    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;

    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
        typeof console.error === 'function') {
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by ' +
        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      );
    }

    function typedArraySupport () {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function () { return 42 } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42
      } catch (e) {
        return false
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.buffer
      }
    });

    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.byteOffset
      }
    });

    function createBuffer (length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"')
      }
      // Return an augmented `Uint8Array` instance
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          )
        }
        return allocUnsafe(arg)
      }
      return from(arg, encodingOrOffset, length)
    }

    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    if (typeof Symbol !== 'undefined' && Symbol.species != null &&
        Buffer[Symbol.species] === Buffer) {
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      });
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from (value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset)
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayLike(value)
      }

      if (value == null) {
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
          'or Array-like Object. Received type ' + (typeof value)
        )
      }

      if (isInstance(value, ArrayBuffer) ||
          (value && isInstance(value.buffer, ArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }

      if (typeof value === 'number') {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        )
      }

      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length)
      }

      var b = fromObject(value);
      if (b) return b

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
          typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(
          value[Symbol.toPrimitive]('string'), encodingOrOffset, length
        )
      }

      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length)
    };

    // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148
    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number')
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"')
      }
    }

    function alloc (size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(size).fill(fill, encoding)
          : createBuffer(size).fill(fill)
      }
      return createBuffer(size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding)
    };

    function allocUnsafe (size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0)
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size)
    };

    function fromString (string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);

      var actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf
    }

    function fromArrayLike (array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf
    }

    function fromArrayBuffer (array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds')
      }

      var buf;
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }

      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(buf, Buffer.prototype);

      return buf
    }

    function fromObject (obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf
        }

        obj.copy(buf, 0, 0, len);
        return buf
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0)
        }
        return fromArrayLike(obj)
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data)
      }
    }

    function checked (length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
      }
      return length | 0
    }

    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0;
      }
      return Buffer.alloc(+length)
    }

    Buffer.isBuffer = function isBuffer (b) {
      return b != null && b._isBuffer === true &&
        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare (a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          buf = Buffer.from(buf);
        }
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
          'Received type ' + typeof string
        )
      }

      var len = string.length;
      var mustMatch = (arguments.length > 2 && arguments[2] === true);
      if (!mustMatch && len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            }
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>'
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. ' +
          'Received type ' + (typeof target)
        )
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset; // Coerce to Number.
      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64Js.fromByteArray(buf)
      } else {
        return base64Js.fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
            : (firstByte > 0xBF) ? 2
              : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf = this.subarray(start, end);
      // Return an augmented `Uint8Array` instance
      Object.setPrototypeOf(newBuf, Buffer.prototype);

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2
    };

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (var i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if ((encoding === 'utf8' && code < 128) ||
              encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val +
            '" is invalid for argument "value"')
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0];
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = str.trim().replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }

    function base64ToBytes (str) {
      return base64Js.toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166
    function isInstance (obj, type) {
      return obj instanceof type ||
        (obj != null && obj.constructor != null && obj.constructor.name != null &&
          obj.constructor.name === type.name)
    }
    function numberIsNaN (obj) {
      // For IE11 support
      return obj !== obj // eslint-disable-line no-self-compare
    }

    // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219
    var hexSliceLookupTable = (function () {
      var alphabet = '0123456789abcdef';
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table
    })();
    });
    var buffer_1$1 = buffer$1.Buffer;
    var buffer_2$1 = buffer$1.SlowBuffer;
    var buffer_3$1 = buffer$1.INSPECT_MAX_BYTES;
    var buffer_4$1 = buffer$1.kMaxLength;

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * The default data transformer that will be used by the Azure SDK.
     */
    class DefaultDataTransformer {
        /**
         * A function that takes the body property from an EventData object
         * and returns an encoded body (some form of AMQP type).
         *
         * @param {*} body The AMQP message body
         * @return {DataSection} encodedBody - The encoded AMQP message body as an AMQP Data type
         * (data section in rhea terms). Section object with following properties:
         * - typecode: 117 (0x75)
         * - content: The given AMQP message body as a Buffer.
         * - multiple: true | undefined.
         */
        encode(body) {
            let result;
            transformer("[encode] The given message body that needs to be encoded is: ", body);
            if (isBuffer(body)) {
                result = lib_2.data_section(body);
            }
            else {
                // string, undefined, null, boolean, array, object, number should end up here
                // coercing undefined to null as that will ensure that null value will be given to the
                // customer on receive.
                if (body === undefined)
                    body = null; // tslint:disable-line
                try {
                    const bodyStr = JSON.stringify(body);
                    result = lib_2.data_section(buffer_1$1.from(bodyStr, "utf8"));
                }
                catch (err) {
                    const msg = `An error occurred while executing JSON.stringify() on the given body ` +
                        body +
                        `${err ? err.stack : JSON.stringify(err)}`;
                    error$1("[encode] " + msg);
                    throw new Error(msg);
                }
            }
            transformer("[encode] The encoded message body is: %O.", result);
            return result;
        }
        /**
         * @property {Function} [decode] A function that takes the body property from an AMQP message
         * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.
         * If it cannot decode the body then it returns the body
         * as-is.
         * @param {DataSection} body The AMQP message body
         * @return {*} decoded body or the given body as-is.
         */
        decode(body) {
            let processedBody = body;
            try {
                transformer("[decode] Received message body for decoding is: %O", body);
                if (body.content && isBuffer(body.content)) {
                    // This indicates that we are getting the AMQP described type. Let us try decoding it.
                    processedBody = body.content;
                }
                try {
                    // Trying to stringify and JSON.parse() anything else will fail flat and we shall return
                    // the original type back
                    const bodyStr = processedBody.toString("utf8");
                    processedBody = JSON.parse(bodyStr);
                }
                catch (err) {
                    error$1("[decode] An error occurred while trying JSON.parse() on the received body. " +
                        "The error is %O", err);
                }
            }
            catch (err) {
                error$1("[decode] An error occurred while decoding the received message body. The error is: %O", err);
            }
            transformer("[decode] The decoded message body is: %O", processedBody);
            return processedBody;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (TokenType) {
        /**
         * The "jwt" token type. Used with AADTokenProvider.
         */
        TokenType["CbsTokenTypeJwt"] = "jwt";
        /**
         * The sas token type. Used with SasTokenProvider.
         */
        TokenType["CbsTokenTypeSas"] = "servicebus.windows.net:sastoken";
    })(exports.TokenType || (exports.TokenType = {}));

    var sha = createCommonjsModule(function (module, exports) {
    (function(Y){function C(c,a,b){var e=0,h=[],n=0,g,l,d,f,m,q,u,r,I=!1,v=[],w=[],t,y=!1,z=!1,x=-1;b=b||{};g=b.encoding||"UTF8";t=b.numRounds||1;if(t!==parseInt(t,10)||1>t)throw Error("numRounds must a integer >= 1");if("SHA-1"===c)m=512,q=K,u=Z,f=160,r=function(a){return a.slice()};else if(0===c.lastIndexOf("SHA-",0))if(q=function(a,b){return L(a,b,c)},u=function(a,b,h,e){var k,f;if("SHA-224"===c||"SHA-256"===c)k=(b+65>>>9<<4)+15,f=16;else if("SHA-384"===c||"SHA-512"===c)k=(b+129>>>10<<
    5)+31,f=32;else throw Error("Unexpected error in SHA-2 implementation");for(;a.length<=k;)a.push(0);a[b>>>5]|=128<<24-b%32;b=b+h;a[k]=b&4294967295;a[k-1]=b/4294967296|0;h=a.length;for(b=0;b<h;b+=f)e=L(a.slice(b,b+f),e,c);if("SHA-224"===c)a=[e[0],e[1],e[2],e[3],e[4],e[5],e[6]];else if("SHA-256"===c)a=e;else if("SHA-384"===c)a=[e[0].a,e[0].b,e[1].a,e[1].b,e[2].a,e[2].b,e[3].a,e[3].b,e[4].a,e[4].b,e[5].a,e[5].b];else if("SHA-512"===c)a=[e[0].a,e[0].b,e[1].a,e[1].b,e[2].a,e[2].b,e[3].a,e[3].b,e[4].a,
    e[4].b,e[5].a,e[5].b,e[6].a,e[6].b,e[7].a,e[7].b];else throw Error("Unexpected error in SHA-2 implementation");return a},r=function(a){return a.slice()},"SHA-224"===c)m=512,f=224;else if("SHA-256"===c)m=512,f=256;else if("SHA-384"===c)m=1024,f=384;else if("SHA-512"===c)m=1024,f=512;else throw Error("Chosen SHA variant is not supported");else if(0===c.lastIndexOf("SHA3-",0)||0===c.lastIndexOf("SHAKE",0)){var F=6;q=D;r=function(a){var c=[],e;for(e=0;5>e;e+=1)c[e]=a[e].slice();return c};x=1;if("SHA3-224"===
    c)m=1152,f=224;else if("SHA3-256"===c)m=1088,f=256;else if("SHA3-384"===c)m=832,f=384;else if("SHA3-512"===c)m=576,f=512;else if("SHAKE128"===c)m=1344,f=-1,F=31,z=!0;else if("SHAKE256"===c)m=1088,f=-1,F=31,z=!0;else throw Error("Chosen SHA variant is not supported");u=function(a,c,e,b,h){e=m;var k=F,f,g=[],n=e>>>5,l=0,d=c>>>5;for(f=0;f<d&&c>=e;f+=n)b=D(a.slice(f,f+n),b),c-=e;a=a.slice(f);for(c%=e;a.length<n;)a.push(0);f=c>>>3;a[f>>2]^=k<<f%4*8;a[n-1]^=2147483648;for(b=D(a,b);32*g.length<h;){a=b[l%
    5][l/5|0];g.push(a.b);if(32*g.length>=h)break;g.push(a.a);l+=1;0===64*l%e&&D(null,b);}return g};}else throw Error("Chosen SHA variant is not supported");d=M(a,g,x);l=A(c);this.setHMACKey=function(a,b,h){var k;if(!0===I)throw Error("HMAC key already set");if(!0===y)throw Error("Cannot set HMAC key after calling update");if(!0===z)throw Error("SHAKE is not supported for HMAC");g=(h||{}).encoding||"UTF8";b=M(b,g,x)(a);a=b.binLen;b=b.value;k=m>>>3;h=k/4-1;if(k<a/8){for(b=u(b,a,0,A(c),f);b.length<=h;)b.push(0);
    b[h]&=4294967040;}else if(k>a/8){for(;b.length<=h;)b.push(0);b[h]&=4294967040;}for(a=0;a<=h;a+=1)v[a]=b[a]^909522486,w[a]=b[a]^1549556828;l=q(v,l);e=m;I=!0;};this.update=function(a){var c,b,k,f=0,g=m>>>5;c=d(a,h,n);a=c.binLen;b=c.value;c=a>>>5;for(k=0;k<c;k+=g)f+m<=a&&(l=q(b.slice(k,k+g),l),f+=m);e+=f;h=b.slice(f>>>5);n=a%m;y=!0;};this.getHash=function(a,b){var k,g,d,m;if(!0===I)throw Error("Cannot call getHash after setting HMAC key");d=N(b);if(!0===z){if(-1===d.shakeLen)throw Error("shakeLen must be specified in options");
    f=d.shakeLen;}switch(a){case "HEX":k=function(a){return O(a,f,x,d)};break;case "B64":k=function(a){return P(a,f,x,d)};break;case "BYTES":k=function(a){return Q(a,f,x)};break;case "ARRAYBUFFER":try{g=new ArrayBuffer(0);}catch(p){throw Error("ARRAYBUFFER not supported by this environment");}k=function(a){return R(a,f,x)};break;default:throw Error("format must be HEX, B64, BYTES, or ARRAYBUFFER");}m=u(h.slice(),n,e,r(l),f);for(g=1;g<t;g+=1)!0===z&&0!==f%32&&(m[m.length-1]&=16777215>>>24-f%32),m=u(m,f,
    0,A(c),f);return k(m)};this.getHMAC=function(a,b){var k,g,d,p;if(!1===I)throw Error("Cannot call getHMAC without first setting HMAC key");d=N(b);switch(a){case "HEX":k=function(a){return O(a,f,x,d)};break;case "B64":k=function(a){return P(a,f,x,d)};break;case "BYTES":k=function(a){return Q(a,f,x)};break;case "ARRAYBUFFER":try{k=new ArrayBuffer(0);}catch(v){throw Error("ARRAYBUFFER not supported by this environment");}k=function(a){return R(a,f,x)};break;default:throw Error("outputFormat must be HEX, B64, BYTES, or ARRAYBUFFER");
    }g=u(h.slice(),n,e,r(l),f);p=q(w,A(c));p=u(g,f,m,p,f);return k(p)};}function b(c,a){this.a=c;this.b=a;}function O(c,a,b,e){var h="";a/=8;var n,g,d;d=-1===b?3:0;for(n=0;n<a;n+=1)g=c[n>>>2]>>>8*(d+n%4*b),h+="0123456789abcdef".charAt(g>>>4&15)+"0123456789abcdef".charAt(g&15);return e.outputUpper?h.toUpperCase():h}function P(c,a,b,e){var h="",n=a/8,g,d,p,f;f=-1===b?3:0;for(g=0;g<n;g+=3)for(d=g+1<n?c[g+1>>>2]:0,p=g+2<n?c[g+2>>>2]:0,p=(c[g>>>2]>>>8*(f+g%4*b)&255)<<16|(d>>>8*(f+(g+1)%4*b)&255)<<8|p>>>8*(f+
    (g+2)%4*b)&255,d=0;4>d;d+=1)8*g+6*d<=a?h+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(p>>>6*(3-d)&63):h+=e.b64Pad;return h}function Q(c,a,b){var e="";a/=8;var h,d,g;g=-1===b?3:0;for(h=0;h<a;h+=1)d=c[h>>>2]>>>8*(g+h%4*b)&255,e+=String.fromCharCode(d);return e}function R(c,a,b){a/=8;var e,h=new ArrayBuffer(a),d,g;g=new Uint8Array(h);d=-1===b?3:0;for(e=0;e<a;e+=1)g[e]=c[e>>>2]>>>8*(d+e%4*b)&255;return h}function N(c){var a={outputUpper:!1,b64Pad:"=",shakeLen:-1};c=c||{};
    a.outputUpper=c.outputUpper||!1;!0===c.hasOwnProperty("b64Pad")&&(a.b64Pad=c.b64Pad);if(!0===c.hasOwnProperty("shakeLen")){if(0!==c.shakeLen%8)throw Error("shakeLen must be a multiple of 8");a.shakeLen=c.shakeLen;}if("boolean"!==typeof a.outputUpper)throw Error("Invalid outputUpper formatting option");if("string"!==typeof a.b64Pad)throw Error("Invalid b64Pad formatting option");return a}function M(c,a,b){switch(a){case "UTF8":case "UTF16BE":case "UTF16LE":break;default:throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");
    }switch(c){case "HEX":c=function(a,c,d){var g=a.length,l,p,f,m,q,u;if(0!==g%2)throw Error("String of HEX type must be in byte increments");c=c||[0];d=d||0;q=d>>>3;u=-1===b?3:0;for(l=0;l<g;l+=2){p=parseInt(a.substr(l,2),16);if(isNaN(p))throw Error("String of HEX type contains invalid characters");m=(l>>>1)+q;for(f=m>>>2;c.length<=f;)c.push(0);c[f]|=p<<8*(u+m%4*b);}return {value:c,binLen:4*g+d}};break;case "TEXT":c=function(c,h,d){var g,l,p=0,f,m,q,u,r,t;h=h||[0];d=d||0;q=d>>>3;if("UTF8"===a)for(t=-1===
    b?3:0,f=0;f<c.length;f+=1)for(g=c.charCodeAt(f),l=[],128>g?l.push(g):2048>g?(l.push(192|g>>>6),l.push(128|g&63)):55296>g||57344<=g?l.push(224|g>>>12,128|g>>>6&63,128|g&63):(f+=1,g=65536+((g&1023)<<10|c.charCodeAt(f)&1023),l.push(240|g>>>18,128|g>>>12&63,128|g>>>6&63,128|g&63)),m=0;m<l.length;m+=1){r=p+q;for(u=r>>>2;h.length<=u;)h.push(0);h[u]|=l[m]<<8*(t+r%4*b);p+=1;}else if("UTF16BE"===a||"UTF16LE"===a)for(t=-1===b?2:0,l="UTF16LE"===a&&1!==b||"UTF16LE"!==a&&1===b,f=0;f<c.length;f+=1){g=c.charCodeAt(f);
    !0===l&&(m=g&255,g=m<<8|g>>>8);r=p+q;for(u=r>>>2;h.length<=u;)h.push(0);h[u]|=g<<8*(t+r%4*b);p+=2;}return {value:h,binLen:8*p+d}};break;case "B64":c=function(a,c,d){var g=0,l,p,f,m,q,u,r,t;if(-1===a.search(/^[a-zA-Z0-9=+\/]+$/))throw Error("Invalid character in base-64 string");p=a.indexOf("=");a=a.replace(/\=/g,"");if(-1!==p&&p<a.length)throw Error("Invalid '=' found in base-64 string");c=c||[0];d=d||0;u=d>>>3;t=-1===b?3:0;for(p=0;p<a.length;p+=4){q=a.substr(p,4);for(f=m=0;f<q.length;f+=1)l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(q[f]),
    m|=l<<18-6*f;for(f=0;f<q.length-1;f+=1){r=g+u;for(l=r>>>2;c.length<=l;)c.push(0);c[l]|=(m>>>16-8*f&255)<<8*(t+r%4*b);g+=1;}}return {value:c,binLen:8*g+d}};break;case "BYTES":c=function(a,c,d){var g,l,p,f,m,q;c=c||[0];d=d||0;p=d>>>3;q=-1===b?3:0;for(l=0;l<a.length;l+=1)g=a.charCodeAt(l),m=l+p,f=m>>>2,c.length<=f&&c.push(0),c[f]|=g<<8*(q+m%4*b);return {value:c,binLen:8*a.length+d}};break;case "ARRAYBUFFER":try{c=new ArrayBuffer(0);}catch(e){throw Error("ARRAYBUFFER not supported by this environment");}c=
    function(a,c,d){var g,l,p,f,m,q;c=c||[0];d=d||0;l=d>>>3;m=-1===b?3:0;q=new Uint8Array(a);for(g=0;g<a.byteLength;g+=1)f=g+l,p=f>>>2,c.length<=p&&c.push(0),c[p]|=q[g]<<8*(m+f%4*b);return {value:c,binLen:8*a.byteLength+d}};break;default:throw Error("format must be HEX, TEXT, B64, BYTES, or ARRAYBUFFER");}return c}function y(c,a){return c<<a|c>>>32-a}function S(c,a){return 32<a?(a-=32,new b(c.b<<a|c.a>>>32-a,c.a<<a|c.b>>>32-a)):0!==a?new b(c.a<<a|c.b>>>32-a,c.b<<a|c.a>>>32-a):c}function w(c,a){return c>>>
    a|c<<32-a}function t(c,a){var k=null,k=new b(c.a,c.b);return k=32>=a?new b(k.a>>>a|k.b<<32-a&4294967295,k.b>>>a|k.a<<32-a&4294967295):new b(k.b>>>a-32|k.a<<64-a&4294967295,k.a>>>a-32|k.b<<64-a&4294967295)}function T(c,a){var k=null;return k=32>=a?new b(c.a>>>a,c.b>>>a|c.a<<32-a&4294967295):new b(0,c.a>>>a-32)}function aa(c,a,b){return c&a^~c&b}function ba(c,a,k){return new b(c.a&a.a^~c.a&k.a,c.b&a.b^~c.b&k.b)}function U(c,a,b){return c&a^c&b^a&b}function ca(c,a,k){return new b(c.a&a.a^c.a&k.a^a.a&
    k.a,c.b&a.b^c.b&k.b^a.b&k.b)}function da(c){return w(c,2)^w(c,13)^w(c,22)}function ea(c){var a=t(c,28),k=t(c,34);c=t(c,39);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function fa(c){return w(c,6)^w(c,11)^w(c,25)}function ga(c){var a=t(c,14),k=t(c,18);c=t(c,41);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function ha(c){return w(c,7)^w(c,18)^c>>>3}function ia(c){var a=t(c,1),k=t(c,8);c=T(c,7);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function ja(c){return w(c,17)^w(c,19)^c>>>10}function ka(c){var a=t(c,19),k=t(c,61);
    c=T(c,6);return new b(a.a^k.a^c.a,a.b^k.b^c.b)}function G(c,a){var b=(c&65535)+(a&65535);return ((c>>>16)+(a>>>16)+(b>>>16)&65535)<<16|b&65535}function la(c,a,b,e){var h=(c&65535)+(a&65535)+(b&65535)+(e&65535);return ((c>>>16)+(a>>>16)+(b>>>16)+(e>>>16)+(h>>>16)&65535)<<16|h&65535}function H(c,a,b,e,h){var d=(c&65535)+(a&65535)+(b&65535)+(e&65535)+(h&65535);return ((c>>>16)+(a>>>16)+(b>>>16)+(e>>>16)+(h>>>16)+(d>>>16)&65535)<<16|d&65535}function ma(c,a){var d,e,h;d=(c.b&65535)+(a.b&65535);e=(c.b>>>16)+
    (a.b>>>16)+(d>>>16);h=(e&65535)<<16|d&65535;d=(c.a&65535)+(a.a&65535)+(e>>>16);e=(c.a>>>16)+(a.a>>>16)+(d>>>16);return new b((e&65535)<<16|d&65535,h)}function na(c,a,d,e){var h,n,g;h=(c.b&65535)+(a.b&65535)+(d.b&65535)+(e.b&65535);n=(c.b>>>16)+(a.b>>>16)+(d.b>>>16)+(e.b>>>16)+(h>>>16);g=(n&65535)<<16|h&65535;h=(c.a&65535)+(a.a&65535)+(d.a&65535)+(e.a&65535)+(n>>>16);n=(c.a>>>16)+(a.a>>>16)+(d.a>>>16)+(e.a>>>16)+(h>>>16);return new b((n&65535)<<16|h&65535,g)}function oa(c,a,d,e,h){var n,g,l;n=(c.b&
    65535)+(a.b&65535)+(d.b&65535)+(e.b&65535)+(h.b&65535);g=(c.b>>>16)+(a.b>>>16)+(d.b>>>16)+(e.b>>>16)+(h.b>>>16)+(n>>>16);l=(g&65535)<<16|n&65535;n=(c.a&65535)+(a.a&65535)+(d.a&65535)+(e.a&65535)+(h.a&65535)+(g>>>16);g=(c.a>>>16)+(a.a>>>16)+(d.a>>>16)+(e.a>>>16)+(h.a>>>16)+(n>>>16);return new b((g&65535)<<16|n&65535,l)}function B(c,a){return new b(c.a^a.a,c.b^a.b)}function A(c){var a=[],d;if("SHA-1"===c)a=[1732584193,4023233417,2562383102,271733878,3285377520];else if(0===c.lastIndexOf("SHA-",0))switch(a=
    [3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428],d=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],c){case "SHA-224":break;case "SHA-256":a=d;break;case "SHA-384":a=[new b(3418070365,a[0]),new b(1654270250,a[1]),new b(2438529370,a[2]),new b(355462360,a[3]),new b(1731405415,a[4]),new b(41048885895,a[5]),new b(3675008525,a[6]),new b(1203062813,a[7])];break;case "SHA-512":a=[new b(d[0],4089235720),new b(d[1],2227873595),
    new b(d[2],4271175723),new b(d[3],1595750129),new b(d[4],2917565137),new b(d[5],725511199),new b(d[6],4215389547),new b(d[7],327033209)];break;default:throw Error("Unknown SHA variant");}else if(0===c.lastIndexOf("SHA3-",0)||0===c.lastIndexOf("SHAKE",0))for(c=0;5>c;c+=1)a[c]=[new b(0,0),new b(0,0),new b(0,0),new b(0,0),new b(0,0)];else throw Error("No SHA variants supported");return a}function K(c,a){var b=[],e,d,n,g,l,p,f;e=a[0];d=a[1];n=a[2];g=a[3];l=a[4];for(f=0;80>f;f+=1)b[f]=16>f?c[f]:y(b[f-
    3]^b[f-8]^b[f-14]^b[f-16],1),p=20>f?H(y(e,5),d&n^~d&g,l,1518500249,b[f]):40>f?H(y(e,5),d^n^g,l,1859775393,b[f]):60>f?H(y(e,5),U(d,n,g),l,2400959708,b[f]):H(y(e,5),d^n^g,l,3395469782,b[f]),l=g,g=n,n=y(d,30),d=e,e=p;a[0]=G(e,a[0]);a[1]=G(d,a[1]);a[2]=G(n,a[2]);a[3]=G(g,a[3]);a[4]=G(l,a[4]);return a}function Z(c,a,b,e){var d;for(d=(a+65>>>9<<4)+15;c.length<=d;)c.push(0);c[a>>>5]|=128<<24-a%32;a+=b;c[d]=a&4294967295;c[d-1]=a/4294967296|0;a=c.length;for(d=0;d<a;d+=16)e=K(c.slice(d,d+16),e);return e}function L(c,
    a,k){var e,h,n,g,l,p,f,m,q,u,r,t,v,w,y,A,z,x,F,B,C,D,E=[],J;if("SHA-224"===k||"SHA-256"===k)u=64,t=1,D=Number,v=G,w=la,y=H,A=ha,z=ja,x=da,F=fa,C=U,B=aa,J=d;else if("SHA-384"===k||"SHA-512"===k)u=80,t=2,D=b,v=ma,w=na,y=oa,A=ia,z=ka,x=ea,F=ga,C=ca,B=ba,J=V;else throw Error("Unexpected error in SHA-2 implementation");k=a[0];e=a[1];h=a[2];n=a[3];g=a[4];l=a[5];p=a[6];f=a[7];for(r=0;r<u;r+=1)16>r?(q=r*t,m=c.length<=q?0:c[q],q=c.length<=q+1?0:c[q+1],E[r]=new D(m,q)):E[r]=w(z(E[r-2]),E[r-7],A(E[r-15]),E[r-
    16]),m=y(f,F(g),B(g,l,p),J[r],E[r]),q=v(x(k),C(k,e,h)),f=p,p=l,l=g,g=v(n,m),n=h,h=e,e=k,k=v(m,q);a[0]=v(k,a[0]);a[1]=v(e,a[1]);a[2]=v(h,a[2]);a[3]=v(n,a[3]);a[4]=v(g,a[4]);a[5]=v(l,a[5]);a[6]=v(p,a[6]);a[7]=v(f,a[7]);return a}function D(c,a){var d,e,h,n,g=[],l=[];if(null!==c)for(e=0;e<c.length;e+=2)a[(e>>>1)%5][(e>>>1)/5|0]=B(a[(e>>>1)%5][(e>>>1)/5|0],new b(c[e+1],c[e]));for(d=0;24>d;d+=1){n=A("SHA3-");for(e=0;5>e;e+=1){h=a[e][0];var p=a[e][1],f=a[e][2],m=a[e][3],q=a[e][4];g[e]=new b(h.a^p.a^f.a^
    m.a^q.a,h.b^p.b^f.b^m.b^q.b);}for(e=0;5>e;e+=1)l[e]=B(g[(e+4)%5],S(g[(e+1)%5],1));for(e=0;5>e;e+=1)for(h=0;5>h;h+=1)a[e][h]=B(a[e][h],l[e]);for(e=0;5>e;e+=1)for(h=0;5>h;h+=1)n[h][(2*e+3*h)%5]=S(a[e][h],W[e][h]);for(e=0;5>e;e+=1)for(h=0;5>h;h+=1)a[e][h]=B(n[e][h],new b(~n[(e+1)%5][h].a&n[(e+2)%5][h].a,~n[(e+1)%5][h].b&n[(e+2)%5][h].b));a[0][0]=B(a[0][0],X[d]);}return a}var d,V,W,X;d=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,
    1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,
    2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];V=[new b(d[0],3609767458),new b(d[1],602891725),new b(d[2],3964484399),new b(d[3],2173295548),new b(d[4],4081628472),new b(d[5],3053834265),new b(d[6],2937671579),new b(d[7],3664609560),new b(d[8],2734883394),new b(d[9],1164996542),new b(d[10],1323610764),new b(d[11],3590304994),new b(d[12],4068182383),new b(d[13],991336113),new b(d[14],633803317),new b(d[15],3479774868),new b(d[16],2666613458),new b(d[17],944711139),new b(d[18],2341262773),
    new b(d[19],2007800933),new b(d[20],1495990901),new b(d[21],1856431235),new b(d[22],3175218132),new b(d[23],2198950837),new b(d[24],3999719339),new b(d[25],766784016),new b(d[26],2566594879),new b(d[27],3203337956),new b(d[28],1034457026),new b(d[29],2466948901),new b(d[30],3758326383),new b(d[31],168717936),new b(d[32],1188179964),new b(d[33],1546045734),new b(d[34],1522805485),new b(d[35],2643833823),new b(d[36],2343527390),new b(d[37],1014477480),new b(d[38],1206759142),new b(d[39],344077627),
    new b(d[40],1290863460),new b(d[41],3158454273),new b(d[42],3505952657),new b(d[43],106217008),new b(d[44],3606008344),new b(d[45],1432725776),new b(d[46],1467031594),new b(d[47],851169720),new b(d[48],3100823752),new b(d[49],1363258195),new b(d[50],3750685593),new b(d[51],3785050280),new b(d[52],3318307427),new b(d[53],3812723403),new b(d[54],2003034995),new b(d[55],3602036899),new b(d[56],1575990012),new b(d[57],1125592928),new b(d[58],2716904306),new b(d[59],442776044),new b(d[60],593698344),new b(d[61],
    3733110249),new b(d[62],2999351573),new b(d[63],3815920427),new b(3391569614,3928383900),new b(3515267271,566280711),new b(3940187606,3454069534),new b(4118630271,4000239992),new b(116418474,1914138554),new b(174292421,2731055270),new b(289380356,3203993006),new b(460393269,320620315),new b(685471733,587496836),new b(852142971,1086792851),new b(1017036298,365543100),new b(1126000580,2618297676),new b(1288033470,3409855158),new b(1501505948,4234509866),new b(1607167915,987167468),new b(1816402316,
    1246189591)];X=[new b(0,1),new b(0,32898),new b(2147483648,32906),new b(2147483648,2147516416),new b(0,32907),new b(0,2147483649),new b(2147483648,2147516545),new b(2147483648,32777),new b(0,138),new b(0,136),new b(0,2147516425),new b(0,2147483658),new b(0,2147516555),new b(2147483648,139),new b(2147483648,32905),new b(2147483648,32771),new b(2147483648,32770),new b(2147483648,128),new b(0,32778),new b(2147483648,2147483658),new b(2147483648,2147516545),new b(2147483648,32896),new b(0,2147483649),
    new b(2147483648,2147516424)];W=[[0,36,3,41,18],[1,44,10,45,2],[62,6,43,15,61],[28,55,25,21,56],[27,20,39,8,14]];(module.exports&&(module.exports=C),exports=C);})(commonjsGlobal);
    });

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @class SasTokenProvider
     * Defines the SasTokenProvider.
     */
    class SasTokenProvider {
        /**
         * Initializes a new instance of SasTokenProvider
         * @constructor
         * @param {string} namespace - The namespace of the EventHub/ServiceBus instance.
         * @param {string} keyName - The name of the EventHub/ServiceBus key.
         * @param {string} key - The secret value associated with the above EventHub/ServiceBus key
         */
        constructor(namespace, keyName, key, tokenValidTimeInSeconds, tokenRenewalMarginInSeconds) {
            this.namespace = namespace;
            this.keyName = keyName;
            this.key = key;
            this.tokenValidTimeInSeconds = tokenValidTimeInSeconds || 3600;
            this.tokenRenewalMarginInSeconds = tokenRenewalMarginInSeconds || 900;
            if (this.tokenValidTimeInSeconds <= this.tokenRenewalMarginInSeconds) {
                throw new Error("tokenRenewalMarginInSeconds must be less than tokenValidTimeInSeconds");
            }
        }
        /**
         * Gets the sas token for the specified audience
         * @param {string} [audience] - The audience for which the token is desired. If not
         * provided then the Endpoint from the connection string will be applied.
         */
        getToken(audience) {
            return __awaiter(this, void 0, void 0, function* () {
                return this._createToken(Math.floor(Date.now() / 1000) + this.tokenValidTimeInSeconds, audience);
            });
        }
        /**
         * @protected
         * Creates the sas token based on the provided information
         * @param {string | number} expiry - The time period in unix time after which the token will expire.
         * @param {string} [audience] - The audience for which the token is desired. If not
         * provided then the Endpoint from the connection string will be applied.
         * @param {string | Buffer} [hashInput] The input to be provided to hmac to create the hash.
         */
        _createToken(expiry, audience, hashInput) {
            if (!audience)
                audience = this.namespace;
            audience = encodeURIComponent(audience);
            const keyName = encodeURIComponent(this.keyName);
            const stringToSign = audience + "\n" + expiry;
            hashInput = hashInput || this.key;
            let shaObj;
            if (isBuffer(hashInput)) {
                shaObj = new sha("SHA-256", "ARRAYBUFFER");
                shaObj.setHMACKey(hashInput, "ARRAYBUFFER");
                shaObj.update(buffer_1$1.from(stringToSign));
            }
            else {
                shaObj = new sha("SHA-256", "TEXT");
                shaObj.setHMACKey(hashInput, "TEXT");
                shaObj.update(stringToSign);
            }
            const sig = encodeURIComponent(shaObj.getHMAC("B64"));
            return {
                token: `SharedAccessSignature sr=${audience}&sig=${sig}&se=${expiry}&skn=${keyName}`,
                tokenType: exports.TokenType.CbsTokenTypeSas,
                expiry: expiry
            };
        }
        /**
         * Creates a token provider from the EventHub/ServiceBus connection string;
         * @param {string} connectionString - The EventHub/ServiceBus connection string
         */
        static fromConnectionString(connectionString) {
            const parsed = parseConnectionString(connectionString);
            return new SasTokenProvider(parsed.Endpoint, parsed.SharedAccessKeyName, parsed.SharedAccessKey);
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @class IotSasTokenProvider
     * @ignore
     * Defines the SasTokenProvider for IotHub.
     */
    class IotSasTokenProvider extends SasTokenProvider {
        /**
         * Gets the sas token for the specified audience for IotHub.
         * @ignore
         * @param {string} [audience] - The audience for which the token is desired. If not
         * provided then the Endpoint from the connection string will be applied.
         */
        getToken(audience) {
            return __awaiter(this, void 0, void 0, function* () {
                return this._createToken(Math.floor(Date.now() / 1000) + this.tokenValidTimeInSeconds, audience, buffer_1$1.from(this.key, "base64"));
            });
        }
    }

    /* tslint:disable */
    // This file is a stub export filling in missing capabilities in the browser.
    // The AadTokenProvider is only supported in Node.
    const AadTokenProvider = undefined;

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (ConnectionConfig) {
        /**
         * Creates the connection config.
         * @param {string} connectionString - The connection string for a given service like
         * EventHub/ServiceBus.
         * @param {string} [path]           - The name/path of the entity (hub name) to which the
         * connection needs to happen. This will override the EntityPath in the connectionString
         * if present.
         * @returns {ConnectionConfig} ConnectionConfig
         */
        function create(connectionString, path) {
            connectionString = String(connectionString);
            const parsedCS = parseConnectionString(connectionString);
            if (!parsedCS.Endpoint) {
                throw new TypeError("Missing Endpoint in Connection String.");
            }
            if (!parsedCS.Endpoint.endsWith("/"))
                parsedCS.Endpoint += "/";
            const result = {
                connectionString: connectionString,
                endpoint: parsedCS.Endpoint,
                host: parsedCS && parsedCS.Endpoint
                    ? (parsedCS.Endpoint.match("sb://([^/]*)") || [])[1]
                    : "",
                sharedAccessKeyName: parsedCS.SharedAccessKeyName,
                sharedAccessKey: parsedCS.SharedAccessKey
            };
            if (path || parsedCS.EntityPath) {
                result.entityPath = path || parsedCS.EntityPath;
            }
            return result;
        }
        ConnectionConfig.create = create;
        /**
         * Validates the properties of connection config.
         * @param {ConnectionConfig} config The connection config to be validated.
         * @returns {void} void
         */
        function validate(config, options) {
            if (!options)
                options = {};
            if (!config) {
                throw new TypeError("Missing configuration");
            }
            if (!config.endpoint) {
                throw new TypeError("Missing 'endpoint' in configuration");
            }
            config.endpoint = String(config.endpoint);
            if (!config.host) {
                throw new TypeError("Missing 'host' in configuration");
            }
            config.host = String(config.host);
            if (options.isEntityPathRequired && !config.entityPath) {
                throw new TypeError("Missing 'entityPath' in configuration");
            }
            config.entityPath = String(config.entityPath);
            if (!config.sharedAccessKeyName) {
                throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
            }
            config.sharedAccessKeyName = String(config.sharedAccessKeyName);
            if (!config.sharedAccessKey) {
                throw new TypeError("Missing 'sharedAccessKey' in configuration");
            }
            config.sharedAccessKey = String(config.sharedAccessKey);
        }
        ConnectionConfig.validate = validate;
    })(exports.ConnectionConfig || (exports.ConnectionConfig = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (EventHubConnectionConfig) {
        /**
         * Creates the connection config.
         * @param {string} connectionString - The connection string for a given service like
         * EventHub/ServiceBus.
         * @param {string} [path]           - The name/path of the entity (hub name) to which the
         * connection needs to happen. This will override the EntityPath in the connectionString
         * if present.
         * @returns {EventHubConnectionConfig} EventHubConnectionConfig
         */
        function create(connectionString, path) {
            const config = exports.ConnectionConfig.create(connectionString, path);
            if (!config.entityPath) {
                throw new TypeError(`Either provide "path" or the "connectionString": "${connectionString}", ` +
                    `must contain EntityPath="<path-to-the-entity>".`);
            }
            return createFromConnectionConfig(config);
        }
        EventHubConnectionConfig.create = create;
        /**
         * Creates an EventHubConnectionConfig from the provided base ConnectionConfig.
         * @param config The base connection config from which the EventHubConnectionConfig needs to be
         * created.
         * @returns EventHubConnectionConfig
         */
        function createFromConnectionConfig(config) {
            exports.ConnectionConfig.validate(config, { isEntityPathRequired: true });
            config.getManagementAudience = () => {
                return `${config.endpoint}${config.entityPath}/$management`;
            };
            config.getManagementAddress = () => {
                return `${config.entityPath}/$management`;
            };
            config.getSenderAudience = (partitionId) => {
                if (partitionId != undefined) {
                    return `${config.endpoint}${config.entityPath}/Partitions/${partitionId}`;
                }
                else {
                    return `${config.endpoint}${config.entityPath}`;
                }
            };
            config.getSenderAddress = (partitionId) => {
                if (partitionId != undefined) {
                    return `${config.entityPath}/Partitions/${partitionId}`;
                }
                else {
                    return `${config.entityPath}`;
                }
            };
            config.getReceiverAudience = (partitionId, consumergroup) => {
                if (!consumergroup)
                    consumergroup = "$default";
                return (`${config.endpoint}${config.entityPath}/ConsumerGroups/${consumergroup}/` + `Partitions/${partitionId}`);
            };
            config.getReceiverAddress = (partitionId, consumergroup) => {
                if (!consumergroup)
                    consumergroup = "$default";
                return `${config.entityPath}/ConsumerGroups/${consumergroup}/Partitions/${partitionId}`;
            };
            return config;
        }
        EventHubConnectionConfig.createFromConnectionConfig = createFromConnectionConfig;
        /**
         * Validates the properties of connection config.
         * @param {ConnectionConfig} config The connection config to be validated.
         * @returns {void} void
         */
        function validate(config) {
            return exports.ConnectionConfig.validate(config, { isEntityPathRequired: true });
        }
        EventHubConnectionConfig.validate = validate;
    })(exports.EventHubConnectionConfig || (exports.EventHubConnectionConfig = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (IotHubConnectionConfig) {
        /**
         * Creates the connection config.
         * @ignore
         * @param {string} connectionString - The event hub connection string
         * @param {string} [path]           - The name/path of the entity (hub name) to which the connection needs to happen
         */
        function create(connectionString, path) {
            connectionString = String(connectionString);
            const parsedCS = parseConnectionString(connectionString);
            if (!path) {
                path = "messages/events";
            }
            const result = {
                connectionString: connectionString,
                hostName: parsedCS.HostName,
                host: parsedCS && parsedCS.HostName ? parsedCS.HostName.split(".")[0] : "",
                entityPath: path,
                sharedAccessKeyName: parsedCS.SharedAccessKeyName,
                sharedAccessKey: parsedCS.SharedAccessKey,
                deviceId: parsedCS.DeviceId
            };
            return result;
        }
        IotHubConnectionConfig.create = create;
        /**
         * Validates the properties of connection config.
         * @ignore
         * @param {ConnectionConfig} config The connection config to be validated.
         */
        function validate(config) {
            if (!config) {
                throw new TypeError("Missing configuration");
            }
            if (!config.hostName) {
                throw new TypeError("Missing 'hostName' in configuration");
            }
            config.hostName = String(config.hostName);
            if (!config.entityPath) {
                throw new TypeError("Missing 'entityPath' in configuration");
            }
            config.entityPath = String(config.entityPath);
            if (!config.sharedAccessKeyName) {
                throw new TypeError("Missing 'sharedAccessKeyName' in configuration");
            }
            config.sharedAccessKeyName = String(config.sharedAccessKeyName);
            if (!config.sharedAccessKey) {
                throw new TypeError("Missing 'sharedAccessKey' in configuration");
            }
            config.sharedAccessKey = String(config.sharedAccessKey);
            if (config.deviceId) {
                config.deviceId = String(config.deviceId);
            }
        }
        IotHubConnectionConfig.validate = validate;
        /**
         * Convert iothub connection config to eventhub connection config.
         * @ignore
         * @param {IotHubConnectionConfig} iotHubConfig
         */
        function convertToEventHubConnectionConfig(iotHubConfig) {
            validate(iotHubConfig);
            const config = {
                sharedAccessKey: iotHubConfig.sharedAccessKey,
                sharedAccessKeyName: iotHubConfig.sharedAccessKeyName,
                entityPath: iotHubConfig.entityPath,
                host: iotHubConfig.hostName,
                endpoint: `sb://${iotHubConfig.hostName}/`,
                connectionString: iotHubConfig.connectionString
            };
            return exports.EventHubConnectionConfig.createFromConnectionConfig(config);
        }
        IotHubConnectionConfig.convertToEventHubConnectionConfig = convertToEventHubConnectionConfig;
    })(exports.IotHubConnectionConfig || (exports.IotHubConnectionConfig = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    /**
     * @class CbsClient
     * Describes the EventHub/ServiceBus Cbs client that talks to the $cbs endopint over AMQP connection.
     */
    class CbsClient {
        /**
         * @constructor
         * @param {Connection} connection The AMQP conection.
         * @param {string} connectionLock A unique string (usually a guid) per connection.
         */
        constructor(connection, connectionLock) {
            /**
             * @property {string} endpoint CBS endpoint - "$cbs"
             */
            this.endpoint = cbsEndpoint;
            /**
             * @property {string} replyTo CBS replyTo - The reciever link name that the service should reply to.
             */
            this.replyTo = `${cbsReplyTo}-${lib_5()}`;
            /**
             * @property {string} cbsLock The unqiue lock name per $cbs session per connection that is used to
             * acquire the lock for establishing a cbs session if one does not exist for an aqmp connection.
             */
            this.cbsLock = `${negotiateCbsKey}-${lib_5()}`;
            this.connection = connection;
            this.connectionLock = connectionLock;
        }
        /**
         * Creates a singleton instance of the CBS session if it hasn't been initialized previously on
         * the given connection.
         * @returns {Promise<void>} Promise<void>.
         */
        init() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Acquire the lock and establish an amqp connection if it does not exist.
                    if (!this.connection.isOpen()) {
                        cbs("The CBS client is trying to establish an AMQP connection.");
                        yield defaultLock.acquire(this.connectionLock, () => {
                            return this.connection.open();
                        });
                    }
                    if (!this._isCbsSenderReceiverLinkOpen()) {
                        const rxOpt = {
                            source: {
                                address: this.endpoint
                            },
                            name: this.replyTo,
                            onSessionError: (context) => {
                                const id = context.connection.options.id;
                                const ehError = translate(context.session.error);
                                error$1("[%s] An error occurred on the session for request/response links " +
                                    "for $cbs: %O", id, ehError);
                            }
                        };
                        const srOpt = { target: { address: this.endpoint } };
                        cbs("[%s] Creating sender/receiver links on a session for $cbs endpoint.", this.connection.id);
                        this._cbsSenderReceiverLink = yield RequestResponseLink.create(this.connection, srOpt, rxOpt);
                        this._cbsSenderReceiverLink.sender.on(lib_8.senderError, (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.sender.error);
                            error$1("[%s] An error occurred on the cbs sender link.. %O", id, ehError);
                        });
                        this._cbsSenderReceiverLink.receiver.on(lib_7.receiverError, (context) => {
                            const id = context.connection.options.id;
                            const ehError = translate(context.receiver.error);
                            error$1("[%s] An error occurred on the cbs receiver link.. %O", id, ehError);
                        });
                        cbs("[%s] Successfully created the cbs sender '%s' and receiver '%s' " +
                            "links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
                    }
                    else {
                        cbs("[%s] CBS session is already present. Reusing the cbs sender '%s' " +
                            "and receiver '%s' links over cbs session.", this.connection.id, this._cbsSenderReceiverLink.sender.name, this._cbsSenderReceiverLink.receiver.name);
                    }
                }
                catch (err) {
                    err = translate(err);
                    error$1("[%s] An error occured while establishing the cbs links: %O", this.connection.id, err);
                    throw err;
                }
            });
        }
        /**
         * Negotiates the CBS claim with the EventHub/ServiceBus Service.
         * @param {string} audience The entity token audience for which the token is requested in one
         * of the following forms:
         *
         * - **ServiceBus**
         *    - **Sender**
         *        - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
         *        - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
         *
         *    - **Receiver**
         *         - `"sb://<yournamespace>.servicebus.windows.net/<queue-name>"`
         *         - `"sb://<yournamespace>.servicebus.windows.net/<topic-name>"`
         *
         *    - **ManagementClient**
         *         - `"sb://<your-namespace>.servicebus.windows.net/<queue-name>/$management"`.
         *         - `"sb://<your-namespace>.servicebus.windows.net/<topic-name>/$management"`.
         *
         * - **EventHubs**
         *     - **Sender**
         *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>"`
         *          - `"sb://<yournamespace>.servicebus.windows.net/<hubName>/Partitions/<partitionId>"`.
         *
         *     - **Receiver**
         *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/ConsumerGroups/<consumer-group-name>/Partitions/<partition-id>"`.
         *
         *     - **ManagementClient**
         *         - `"sb://<your-namespace>.servicebus.windows.net/<event-hub-name>/$management"`.
         * @param {TokenInfo} tokenObject The token object that needs to be sent in the put-token request.
         * @return {Promise<any>} Returns a Promise that resolves when $cbs authentication is successful
         * and rejects when an error occurs during $cbs authentication.
         */
        negotiateClaim(audience, tokenObject) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const request = {
                        body: tokenObject.token,
                        message_id: lib_5(),
                        reply_to: this.replyTo,
                        to: this.endpoint,
                        application_properties: {
                            operation: operationPutToken,
                            name: audience,
                            type: tokenObject.tokenType
                        }
                    };
                    const responseMessage = yield this._cbsSenderReceiverLink.sendRequest(request);
                    cbs("[%s] The CBS response is: %O", this.connection.id, responseMessage);
                    return this._fromAmqpMessageResponse(responseMessage);
                }
                catch (err) {
                    error$1("[%s] An error occurred while negotiating the cbs claim: %O", this.connection.id, err);
                    throw err;
                }
            });
        }
        /**
         * Closes the AMQP cbs session to the EventHub/ServiceBus for this client,
         * returning a promise that will be resolved when disconnection is completed.
         * @return {Promise<void>}
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this._isCbsSenderReceiverLinkOpen()) {
                        const cbsLink = this._cbsSenderReceiverLink;
                        this._cbsSenderReceiverLink = undefined;
                        yield cbsLink.close();
                        cbs("[%s] Successfully closed the cbs session.", this.connection.id);
                    }
                }
                catch (err) {
                    const msg = `An error occurred while closing the cbs link: ${err.stack ||
                    JSON.stringify(err)}.`;
                    error$1("[%s] %s", this.connection.id, msg);
                    throw new Error(msg);
                }
            });
        }
        /**
         * Removes the AMQP cbs session to the EventHub/ServiceBus for this client,
         * @returns {void} void
         */
        remove() {
            try {
                if (this._cbsSenderReceiverLink) {
                    const cbsLink = this._cbsSenderReceiverLink;
                    this._cbsSenderReceiverLink = undefined;
                    cbsLink.remove();
                    cbs("[%s] Successfully removed the cbs session.", this.connection.id);
                }
            }
            catch (err) {
                const msg = `An error occurred while removing the cbs link: ${err.stack ||
                JSON.stringify(err)}.`;
                error$1("[%s] %s", this.connection.id, msg);
                throw new Error(msg);
            }
        }
        /**
         * Indicates whether the cbs sender receiver link is open or closed.
         * @private
         * @return {boolean} `true` open, `false` closed.
         */
        _isCbsSenderReceiverLinkOpen() {
            return (this._cbsSenderReceiverLink && this._cbsSenderReceiverLink.isOpen());
        }
        _fromAmqpMessageResponse(msg) {
            const cbsResponse = {
                correlationId: msg.correlation_id,
                statusCode: msg.application_properties
                    ? msg.application_properties["status-code"]
                    : "",
                satusDescription: msg.application_properties
                    ? msg.application_properties["status-description"]
                    : ""
            };
            cbs("[%s] The deserialized CBS response is: %o", this.connection.id, cbsResponse);
            return cbsResponse;
        }
    }

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (MessageHeader) {
        /**
         * Converts MessageHeader to AmqpMessageHeader.
         *
         * @param {MessageHeader} props Message header.
         * @returns {AmqpMessageHeader} AmqpMessageHeader
         */
        function toAmqpMessageHeader(props) {
            const amqpHeader = {};
            if (props.deliveryCount != undefined) {
                amqpHeader.delivery_count = props.deliveryCount;
            }
            if (props.durable != undefined)
                amqpHeader.durable = props.durable;
            if (props.firstAcquirer != undefined) {
                amqpHeader.first_acquirer = props.firstAcquirer;
            }
            if (props.priority != undefined) {
                amqpHeader.priority = props.priority;
            }
            if (props.ttl != undefined) {
                amqpHeader.ttl = props.ttl;
            }
            msgHeader("To AmqpMessageHeader: %O", amqpHeader);
            return amqpHeader;
        }
        MessageHeader.toAmqpMessageHeader = toAmqpMessageHeader;
        /**
         * Converts AmqpMessageHeader to MessageHeader.
         *
         * @param {AmqpMessageHeader} props Amqp Message Header
         * @returns {MessageHeader} MessageHeader.
         */
        function fromAmqpMessageHeader(props) {
            const msgHeader$1 = {};
            if (props.delivery_count != undefined) {
                msgHeader$1.deliveryCount = props.delivery_count;
            }
            if (props.durable != undefined) {
                msgHeader$1.durable = props.durable;
            }
            if (props.first_acquirer != undefined) {
                msgHeader$1.firstAcquirer = props.first_acquirer;
            }
            if (props.priority != undefined) {
                msgHeader$1.priority = props.priority;
            }
            if (props.ttl != undefined) {
                msgHeader$1.ttl = props.ttl;
            }
            msgHeader("From AmqpMessageHeader: %O", msgHeader$1);
            return msgHeader$1;
        }
        MessageHeader.fromAmqpMessageHeader = fromAmqpMessageHeader;
    })(exports.MessageHeader || (exports.MessageHeader = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.
    (function (MessageProperties) {
        /**
         * Converts MessageProperties to AmqpMessageProperties.
         * @param {MessageProperties} props Message properties.
         * @returns {AmqpMessageProperties} AmqpMessageProperties.
         */
        function toAmqpMessageProperties(props) {
            const amqpProperties = {};
            if (props.absoluteExpiryTime != undefined) {
                amqpProperties.absolute_expiry_time = props.absoluteExpiryTime;
            }
            if (props.contentEncoding != undefined) {
                amqpProperties.content_encoding = props.contentEncoding;
            }
            if (props.contentType != undefined) {
                amqpProperties.content_type = props.contentType;
            }
            if (props.correlationId != undefined) {
                amqpProperties.correlation_id = props.correlationId;
            }
            if (props.creationTime != undefined) {
                amqpProperties.creation_time = props.creationTime;
            }
            if (props.groupId != undefined) {
                amqpProperties.group_id = props.groupId;
            }
            if (props.groupSequence != undefined) {
                amqpProperties.group_sequence = props.groupSequence;
            }
            if (props.messageId != undefined) {
                amqpProperties.message_id = props.messageId;
            }
            if (props.replyTo != undefined) {
                amqpProperties.reply_to = props.replyTo;
            }
            if (props.replyToGroupId != undefined) {
                amqpProperties.reply_to_group_id = props.replyToGroupId;
            }
            if (props.subject != undefined) {
                amqpProperties.subject = props.subject;
            }
            if (props.to != undefined) {
                amqpProperties.to = props.to;
            }
            if (props.userId != undefined) {
                amqpProperties.user_id = props.userId;
            }
            msgProperties("To AmqpMessageProperties: %O", amqpProperties);
            return amqpProperties;
        }
        MessageProperties.toAmqpMessageProperties = toAmqpMessageProperties;
        /**
         * Converts AmqpMessageProperties to MessageProperties.
         * @param {AmqpMessageProperties} props Amqp message properties.
         * @returns {MessageProperties} MessageProperties.
         */
        function fromAmqpMessageProperties(props) {
            const msgProperties$1 = {};
            if (props.absolute_expiry_time != undefined) {
                msgProperties$1.absoluteExpiryTime = props.absolute_expiry_time;
            }
            if (props.content_encoding != undefined) {
                msgProperties$1.contentEncoding = props.content_encoding;
            }
            if (props.content_type != undefined) {
                msgProperties$1.contentType = props.content_type;
            }
            if (props.correlation_id != undefined) {
                msgProperties$1.correlationId = props.correlation_id;
            }
            if (props.creation_time != undefined) {
                msgProperties$1.creationTime = props.creation_time;
            }
            if (props.group_id != undefined) {
                msgProperties$1.groupId = props.group_id;
            }
            if (props.group_sequence != undefined) {
                msgProperties$1.groupSequence = props.group_sequence;
            }
            if (props.message_id != undefined) {
                msgProperties$1.messageId = props.message_id;
            }
            if (props.reply_to != undefined) {
                msgProperties$1.replyTo = props.reply_to;
            }
            if (props.reply_to_group_id != undefined) {
                msgProperties$1.replyToGroupId = props.reply_to_group_id;
            }
            if (props.subject != undefined) {
                msgProperties$1.subject = props.subject;
            }
            if (props.to != undefined) {
                msgProperties$1.to = props.to;
            }
            if (props.user_id != undefined) {
                msgProperties$1.userId = props.user_id;
            }
            msgProperties("From AmqpMessageProperties: %O", msgProperties$1);
            return msgProperties$1;
        }
        MessageProperties.fromAmqpMessageProperties = fromAmqpMessageProperties;
    })(exports.MessageProperties || (exports.MessageProperties = {}));

    (function (ConnectionContextBase) {
        /**
         * Creates the base connection context.
         * @param {CreateConnectionContextBaseParameters} parameters Parameters to be provided to create
         * the base connection context.
         */
        function create(parameters) {
            exports.ConnectionConfig.validate(parameters.config, {
                isEntityPathRequired: parameters.isEntityPathRequired || false
            });
            const userAgent = parameters.connectionProperties.userAgent;
            if (userAgent.length > maxUserAgentLength) {
                throw new Error(`The user-agent string cannot be more than ${maxUserAgentLength} characters in length.` +
                    `The given user-agent string is: ${userAgent} with length: ${userAgent.length}`);
            }
            const connectionOptions = {
                transport: TLS,
                host: parameters.config.host,
                hostname: parameters.config.host,
                username: parameters.config.sharedAccessKeyName,
                port: 5671,
                reconnect: false,
                properties: {
                    product: parameters.connectionProperties.product,
                    version: parameters.connectionProperties.version,
                    "user-agent": userAgent,
                    platform: `(${arch()}-${type()}-${release()})`,
                    framework: `Node/${browser.version}`
                },
                operationTimeoutInSeconds: parameters.operationTimeoutInSeconds,
                idle_time_out: defaultConnectionIdleTimeoutInMs
            };
            if (parameters.config.webSocket ||
                (!isNode && typeof window !== "undefined" && window.WebSocket)) {
                const socket = parameters.config.webSocket || window.WebSocket;
                const host = parameters.config.host;
                const endpoint = parameters.config.webSocketEndpointPath || "";
                const socketOptions = parameters.config.webSocketConstructorOptions || {};
                connectionOptions.webSocketOptions = {
                    webSocket: socket,
                    url: `wss://${host}:443/${endpoint}`,
                    protocol: ["AMQPWSB10"],
                    options: socketOptions
                };
            }
            const connection = new lib_14(connectionOptions);
            const connectionLock = `${establishConnection}-${lib_5()}`;
            const connectionContextBase = {
                wasConnectionCloseCalled: false,
                connectionLock: connectionLock,
                negotiateClaimLock: `${negotiateClaim}-${lib_5()}`,
                connection: connection,
                connectionId: connection.id,
                cbsSession: new CbsClient(connection, connectionLock),
                config: parameters.config,
                tokenProvider: parameters.tokenProvider ||
                    new SasTokenProvider(parameters.config.endpoint, parameters.config.sharedAccessKeyName, parameters.config.sharedAccessKey),
                dataTransformer: parameters.dataTransformer || new DefaultDataTransformer()
            };
            return connectionContextBase;
        }
        ConnectionContextBase.create = create;
    })(exports.ConnectionContextBase || (exports.ConnectionContextBase = {}));

    // Copyright (c) Microsoft Corporation. All rights reserved.

    exports.AadTokenProvider = AadTokenProvider;
    exports.AsyncLock = asyncLock;
    exports.CbsClient = CbsClient;
    exports.Constants = constants;
    exports.DefaultDataTransformer = DefaultDataTransformer;
    exports.IotSasTokenProvider = IotSasTokenProvider;
    exports.MessagingError = MessagingError;
    exports.RequestResponseLink = RequestResponseLink;
    exports.SasTokenProvider = SasTokenProvider;
    exports.Timeout = Timeout;
    exports.defaultLock = defaultLock;
    exports.delay = delay;
    exports.executePromisesSequentially = executePromisesSequentially;
    exports.getNewAsyncLock = getNewAsyncLock;
    exports.isAmqpError = lib_19;
    exports.isIotHubConnectionString = isIotHubConnectionString;
    exports.isNode = isNode;
    exports.isSystemError = isSystemError;
    exports.parseConnectionString = parseConnectionString;
    exports.randomNumberFromInterval = randomNumberFromInterval;
    exports.retry = retry$1;
    exports.retryableErrors = retryableErrors;
    exports.translate = translate;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
